package org.zyf.javabasic.letcode.jzoffer;

/**
 * @author yanfengzhang
 * @description 给定二叉树的前序遍历和中序遍历的结果，请重建该二叉树并返回其根节点。
 * 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
 * 例如，输入前序遍历序列 [3,9,20,15,7] 和中序遍历序列 [9,3,15,20,7]，则重建二叉树并返回其根节点。
 * @date 2023/6/7  00:15
 */
public class BuildTree {
    /**
     * 根据前序遍历的特点，第一个元素是根节点。根据中序遍历的特点，根节点的左边是左子树的中序遍历结果，右边是右子树的中序遍历结果。
     * 	1.	定义一个递归函数 buildTree，接收前序遍历序列 preorder、中序遍历序列 inorder、前序遍历序列的起始位置 preStart、
     * 	前序遍历序列的结束位置 preEnd、中序遍历序列的起始位置 inStart、中序遍历序列的结束位置 inEnd。
     * 	2.	若 preStart > preEnd，说明当前子树为空，返回 null。
     * 	3.	创建根节点，值为前序遍历序列的第一个元素 preorder[preStart]。
     * 	4.	在中序遍历序列中找到根节点的位置，将中序遍历序列分为左子树和右子树的部分。
     * 	5.	根据左子树的长度，确定前序遍历序列中左子树和右子树的范围。
     * 	6.	递归构建左子树，调用 buildTree，传入相应的参数。
     * 	7.	递归构建右子树，调用 buildTree，传入相应的参数。
     * 	8.	返回根节点。
     * 通过递归构建二叉树，可以得到最终的二叉树结构。
     * 解题步骤：
     * 	1.	创建 buildTree 函数，传入前序遍历序列 preorder 和中序遍历序列 inorder。
     * 	2.	调用 buildTree 函数，传入相应的参数，返回重建后的二叉树的根节点。
     * 这样，就能得到重建的二叉树。
     * 注意：在实现中需要使用额外的数据结构，如数组、哈希表等，以便快速查找元素在中序遍历序列中的位置。
     */
    public void rr(){

    }
}

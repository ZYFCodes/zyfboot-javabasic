[
  {
    "articleId": 142623625,
    "title": "SpringBoot 服务性能优化15",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 750,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623625",
    "postTime": "2024-09-28 23:07:46",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142623621,
    "title": "SpringBoot 服务性能优化14",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623621",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 912,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623621",
    "postTime": "2024-09-28 23:07:06",
    "diggCount": 20,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142623609,
    "title": "SpringBoot 服务性能优化11",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623609",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 747,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623609",
    "postTime": "2024-09-28 23:06:19",
    "diggCount": 13,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142623600,
    "title": "SpringBoot 服务性能优化10",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623600",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 870,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623600",
    "postTime": "2024-09-28 23:05:41",
    "diggCount": 27,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142623589,
    "title": "SpringBoot 服务性能优化13",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623589",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 791,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623589",
    "postTime": "2024-09-28 23:05:34",
    "diggCount": 21,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142623572,
    "title": "SpringBoot 服务性能优化12",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623572",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 943,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623572",
    "postTime": "2024-09-28 23:05:29",
    "diggCount": 28,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142623592,
    "title": "SpringBoot 服务性能优化9",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623592",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 570,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623592",
    "postTime": "2024-09-28 23:04:54",
    "diggCount": 26,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142623581,
    "title": "SpringBoot 服务性能优化8",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623581",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 881,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623581",
    "postTime": "2024-09-28 23:03:47",
    "diggCount": 22,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142623551,
    "title": "SpringBoot 服务性能优化7",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623551",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 603,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623551",
    "postTime": "2024-09-28 23:03:02",
    "diggCount": 14,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142623538,
    "title": "SpringBoot 服务性能优化6",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623538",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 856,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623538",
    "postTime": "2024-09-28 23:02:57",
    "diggCount": 22,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142623522,
    "title": "SpringBoot 服务性能优化5",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623522",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 981,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623522",
    "postTime": "2024-09-28 23:02:54",
    "diggCount": 12,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142623509,
    "title": "SpringBoot 服务性能优化4",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 928,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623509",
    "postTime": "2024-09-28 23:02:50",
    "diggCount": 12,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142623562,
    "title": "SpringBoot 服务性能优化3",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623562",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 515,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623562",
    "postTime": "2024-09-28 23:02:46",
    "diggCount": 14,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142623516,
    "title": "SpringBoot 服务性能优化2",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623516",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 591,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623516",
    "postTime": "2024-09-28 23:01:12",
    "diggCount": 23,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142623500,
    "title": "SpringBoot 服务性能优化1",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623500",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 725,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623500",
    "postTime": "2024-09-28 23:01:08",
    "diggCount": 30,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142029042,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029042",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1031,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029042",
    "postTime": "2024-09-08 16:38:26",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142029082,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029082",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 903,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029082",
    "postTime": "2024-09-08 16:38:19",
    "diggCount": 13,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142029065,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029065",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 980,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029065",
    "postTime": "2024-09-08 16:37:29",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142029030,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029030",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 761,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029030",
    "postTime": "2024-09-08 16:35:59",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142029017,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029017",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029017",
    "postTime": "2024-09-08 16:35:55",
    "diggCount": 32,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142028980,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028980",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 715,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028980",
    "postTime": "2024-09-08 16:34:59",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142028928,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028928",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 765,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028928",
    "postTime": "2024-09-08 16:34:56",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142029006,
    "title": "【无标题】案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029006",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 735,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029006",
    "postTime": "2024-09-08 16:34:50",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142028950,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028950",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 872,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028950",
    "postTime": "2024-09-08 16:34:46",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142028911,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028911",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 796,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028911",
    "postTime": "2024-09-08 16:34:41",
    "diggCount": 11,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142028887,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028887",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 970,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028887",
    "postTime": "2024-09-08 16:34:37",
    "diggCount": 21,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142028861,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028861",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 876,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028861",
    "postTime": "2024-09-08 16:34:33",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142028990,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028990",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 698,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028990",
    "postTime": "2024-09-08 16:34:15",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142028967,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028967",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 711,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028967",
    "postTime": "2024-09-08 16:33:11",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142028919,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028919",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 787,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028919",
    "postTime": "2024-09-08 16:31:09",
    "diggCount": 10,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 141966709,
    "title": "超越常规：斐波那契数列的极速计算技术12",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966709",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 570,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966709",
    "postTime": "2024-09-06 18:28:10",
    "diggCount": 12,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b78200db214141e495f3ef8e45375a3a.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141966698,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966698",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 698,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966698",
    "postTime": "2024-09-06 18:27:39",
    "diggCount": 20,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141966682,
    "title": "超越常规：斐波那契数列的极速计算技术11",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966682",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 496,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966682",
    "postTime": "2024-09-06 18:27:05",
    "diggCount": 15,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141966674,
    "title": "超越常规：斐波那契数列的极速计算技术13",
    "description": "这个问题导致了斐波那契数列的产生，兔子的对数就对应了斐波那契数列的每一项。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966674",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 970,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966674",
    "postTime": "2024-09-06 18:26:30",
    "diggCount": 29,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141966662,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966662",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 802,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966662",
    "postTime": "2024-09-06 18:25:56",
    "diggCount": 17,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141966647,
    "title": "超越常规：斐波那契数列的极速计算技术8",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966647",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 889,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966647",
    "postTime": "2024-09-06 18:25:49",
    "diggCount": 5,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141966633,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966633",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 689,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966633",
    "postTime": "2024-09-06 18:25:40",
    "diggCount": 8,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141966615,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966615",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 501,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966615",
    "postTime": "2024-09-06 18:25:29",
    "diggCount": 24,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141966594,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966594",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 680,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966594",
    "postTime": "2024-09-06 18:25:24",
    "diggCount": 18,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141966579,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966579",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 520,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966579",
    "postTime": "2024-09-06 18:22:36",
    "diggCount": 16,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141966602,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966602",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 760,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966602",
    "postTime": "2024-09-06 18:22:20",
    "diggCount": 23,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141966555,
    "title": "超越常规：斐波那契数列的极速计算技术14",
    "description": "这个问题导致了斐波那契数列的产生，兔子的对数就对应了斐波那契数列的每一项。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966555",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1023,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966555",
    "postTime": "2024-09-06 18:21:27",
    "diggCount": 30,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141966570,
    "title": "超越常规：斐波那契数列的极速计算技术15",
    "description": "这个问题导致了斐波那契数列的产生，兔子的对数就对应了斐波那契数列的每一项。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966570",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 765,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966570",
    "postTime": "2024-09-06 18:21:22",
    "diggCount": 23,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 141966562,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966562",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 653,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966562",
    "postTime": "2024-09-06 18:21:02",
    "diggCount": 25,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141966545,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966545",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 517,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966545",
    "postTime": "2024-09-06 18:19:56",
    "diggCount": 15,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141934104,
    "title": "案例分析：大对象复用的目标和注意点15",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141934104",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 438,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934104",
    "postTime": "2024-09-05 16:14:34",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141934082,
    "title": "案例分析：大对象复用的目标和注意点14",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141934082",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 852,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934082",
    "postTime": "2024-09-05 16:13:59",
    "diggCount": 26,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141934061,
    "title": "案例分析：大对象复用的目标和注意点13",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141934061",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 490,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934061",
    "postTime": "2024-09-05 16:13:24",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141934044,
    "title": "案例分析：大对象复用的目标和注意点12",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141934044",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1084,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934044",
    "postTime": "2024-09-05 16:12:52",
    "diggCount": 29,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141933981,
    "title": "案例分析：大对象复用的目标和注意点11",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933981",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 365,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933981",
    "postTime": "2024-09-05 16:11:23",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141933949,
    "title": "案例分析：大对象复用的目标和注意点10",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933949",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 427,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933949",
    "postTime": "2024-09-05 16:10:47",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141933921,
    "title": "案例分析：大对象复用的目标和注意点9",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933921",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933921",
    "postTime": "2024-09-05 16:10:16",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141933901,
    "title": "案例分析：大对象复用的目标和注意点8",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933901",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933901",
    "postTime": "2024-09-05 16:09:45",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141933883,
    "title": "案例分析：大对象复用的目标和注意点7",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933883",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 622,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933883",
    "postTime": "2024-09-05 16:09:09",
    "diggCount": 16,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 141933764,
    "title": "案例分析：大对象复用的目标和注意点6",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933764",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 392,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933764",
    "postTime": "2024-09-05 16:05:49",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141933744,
    "title": "案例分析：大对象复用的目标和注意点5",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933744",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1056,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933744",
    "postTime": "2024-09-05 16:05:17",
    "diggCount": 22,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 141933722,
    "title": "案例分析：大对象复用的目标和注意点4",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933722",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 497,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933722",
    "postTime": "2024-09-05 16:04:45",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141933660,
    "title": "案例分析：大对象复用的目标和注意点3",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933660",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 722,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933660",
    "postTime": "2024-09-05 16:03:08",
    "diggCount": 22,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 141933646,
    "title": "案例分析：大对象复用的目标和注意点2",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933646",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 829,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933646",
    "postTime": "2024-09-05 16:02:35",
    "diggCount": 27,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141933560,
    "title": "案例分析：大对象复用的目标和注意点1",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933560",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 343,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933560",
    "postTime": "2024-09-05 16:00:47",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141888744,
    "title": "攻破工程级复杂缓存难题--企业实战18",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888744",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 865,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888744",
    "postTime": "2024-09-04 11:24:39",
    "diggCount": 7,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141888714,
    "title": "攻破工程级复杂缓存难题--企业实战23",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888714",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 688,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888714",
    "postTime": "2024-09-04 11:23:43",
    "diggCount": 27,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141888604,
    "title": "攻破工程级复杂缓存难题--企业实战21",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888604",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 879,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888604",
    "postTime": "2024-09-04 11:23:35",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141888691,
    "title": "攻破工程级复杂缓存难题--企业实战20",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888691",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 835,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888691",
    "postTime": "2024-09-04 11:23:28",
    "diggCount": 22,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141888646,
    "title": "攻破工程级复杂缓存难题--企业实战24",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888646",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 818,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888646",
    "postTime": "2024-09-04 11:22:20",
    "diggCount": 21,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141888316,
    "title": "攻破工程级复杂缓存难题--企业实战30",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888316",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 942,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888316",
    "postTime": "2024-09-04 11:22:14",
    "diggCount": 11,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141888352,
    "title": "攻破工程级复杂缓存难题--企业实战29",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888352",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 976,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888352",
    "postTime": "2024-09-04 11:22:08",
    "diggCount": 28,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141888382,
    "title": "攻破工程级复杂缓存难题--企业实战28",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888382",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 525,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888382",
    "postTime": "2024-09-04 11:22:03",
    "diggCount": 11,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141888468,
    "title": "攻破工程级复杂缓存难题--企业实战27",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888468",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 670,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888468",
    "postTime": "2024-09-04 11:21:58",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141888500,
    "title": "攻破工程级复杂缓存难题--企业实战26",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888500",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 568,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888500",
    "postTime": "2024-09-04 11:21:54",
    "diggCount": 18,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141888428,
    "title": "攻破工程级复杂缓存难题--企业实战25",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888428",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 837,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888428",
    "postTime": "2024-09-04 11:21:49",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141888529,
    "title": "攻破工程级复杂缓存难题--企业实战22",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888529",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 495,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888529",
    "postTime": "2024-09-04 11:21:41",
    "diggCount": 18,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141888572,
    "title": "攻破工程级复杂缓存难题--企业实战19",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888572",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 827,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888572",
    "postTime": "2024-09-04 11:21:31",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141888553,
    "title": "攻破工程级复杂缓存难题--企业实战17",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888553",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 591,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888553",
    "postTime": "2024-09-04 11:19:35",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141888402,
    "title": "攻破工程级复杂缓存难题--企业实战16",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888402",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 658,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888402",
    "postTime": "2024-09-04 11:15:24",
    "diggCount": 17,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141865187,
    "title": "攻破工程级复杂缓存难题--企业实战15",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865187",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 372,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865187",
    "postTime": "2024-09-03 16:25:19",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141865168,
    "title": "攻破工程级复杂缓存难题--企业实战14",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865168",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 485,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865168",
    "postTime": "2024-09-03 16:24:42",
    "diggCount": 6,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865153,
    "title": "攻破工程级复杂缓存难题--企业实战13",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865153",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 334,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865153",
    "postTime": "2024-09-03 16:24:10",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865125,
    "title": "攻破工程级复杂缓存难题--企业实战12",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865125",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 487,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865125",
    "postTime": "2024-09-03 16:23:16",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865106,
    "title": "攻破工程级复杂缓存难题--企业实战11",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865106",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 361,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865106",
    "postTime": "2024-09-03 16:22:46",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141865081,
    "title": "攻破工程级复杂缓存难题--企业实战10",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865081",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865081",
    "postTime": "2024-09-03 16:22:10",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141865052,
    "title": "攻破工程级复杂缓存难题--企业实战9",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865052",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 361,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865052",
    "postTime": "2024-09-03 16:21:37",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141865034,
    "title": "攻破工程级复杂缓存难题--企业实战8",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865034",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865034",
    "postTime": "2024-09-03 16:21:00",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141865020,
    "title": "攻破工程级复杂缓存难题--企业实战7",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865020",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 424,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865020",
    "postTime": "2024-09-03 16:20:29",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141864984,
    "title": "攻破工程级复杂缓存难题--企业实战6",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864984",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864984",
    "postTime": "2024-09-03 16:19:28",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141864962,
    "title": "攻破工程级复杂缓存难题--企业实战5",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864962",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864962",
    "postTime": "2024-09-03 16:18:56",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141864926,
    "title": "攻破工程级复杂缓存难题--企业实战4",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864926",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 603,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864926",
    "postTime": "2024-09-03 16:17:44",
    "diggCount": 12,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141864896,
    "title": "攻破工程级复杂缓存难题--企业实战3",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864896",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 388,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864896",
    "postTime": "2024-09-03 16:17:14",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141864847,
    "title": "攻破工程级复杂缓存难题--企业实战2",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864847",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864847",
    "postTime": "2024-09-03 16:15:49",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141864815,
    "title": "攻破工程级复杂缓存难题--企业实战1",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864815",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864815",
    "postTime": "2024-09-03 16:15:12",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141817502,
    "title": "JMC教程：优化Java应用性能的全流程指南",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817502",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 999,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817502",
    "postTime": "2024-09-02 13:30:14",
    "diggCount": 11,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141817416,
    "title": "JMC应用解析：深度挖掘Java性能数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817416",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 896,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817416",
    "postTime": "2024-09-02 13:25:08",
    "diggCount": 12,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141817398,
    "title": "提高Java应用性能的秘诀：JMC数据挖掘技巧",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817398",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 594,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817398",
    "postTime": "2024-09-02 13:24:21",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141817384,
    "title": "JMC的秘密武器：如何获取并分析Java性能数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817384",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1033,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817384",
    "postTime": "2024-09-02 13:23:41",
    "diggCount": 23,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141817354,
    "title": "JMC助力Java开发者：如何获取并提升应用性能",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817354",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 658,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817354",
    "postTime": "2024-09-02 13:23:24",
    "diggCount": 21,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141817334,
    "title": "轻松掌握Java性能：JMC实战技巧与应用",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817334",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 737,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817334",
    "postTime": "2024-09-02 13:22:55",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141817321,
    "title": "JMC让Java性能数据一目了然：从入门到精通",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817321",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 909,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817321",
    "postTime": "2024-09-02 13:22:31",
    "diggCount": 17,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141817303,
    "title": "Java应用性能优化必备：JMC详解与实战",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817303",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 857,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817303",
    "postTime": "2024-09-02 13:22:04",
    "diggCount": 13,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141817345,
    "title": "通过JMC洞悉Java应用瓶颈：性能数据获取全攻略",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817345",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 924,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817345",
    "postTime": "2024-09-02 13:21:39",
    "diggCount": 16,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141817328,
    "title": "Java性能监控的利器：如何用JMC获取关键数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817328",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 920,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817328",
    "postTime": "2024-09-02 13:20:26",
    "diggCount": 9,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141817310,
    "title": "JMC实战：如何快速获取Java应用的性能数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817310",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 371,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817310",
    "postTime": "2024-09-02 13:19:23",
    "diggCount": 4,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141817242,
    "title": "深入解读JMC：轻松获取Java应用的性能数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817242",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 971,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817242",
    "postTime": "2024-09-02 13:18:54",
    "diggCount": 13,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141817267,
    "title": "JMC揭秘：如何精准监控Java应用性能",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817267",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1387,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817267",
    "postTime": "2024-09-02 13:18:40",
    "diggCount": 26,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141817295,
    "title": "全面掌控Java性能：JMC的最佳实践指南",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817295",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1005,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817295",
    "postTime": "2024-09-02 13:18:20",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141817283,
    "title": "用JMC掌握Java性能：从数据获取到问题定位",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817283",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 841,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817283",
    "postTime": "2024-09-02 13:17:53",
    "diggCount": 24,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140890686,
    "title": "攻破工程级复杂缓存难题--企业实战",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/140890686",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 776,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140890686",
    "postTime": "2024-08-03 14:56:51",
    "diggCount": 11,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/176ebc03f391488b87eca1087643c7f7.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 140890666,
    "title": "攻破工程级复杂缓存难题--企业实战",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/140890666",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 808,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140890666",
    "postTime": "2024-08-03 14:55:28",
    "diggCount": 24,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c4d66207478f4feba58521200e3aa7d7.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140890651,
    "title": "攻破工程级复杂缓存难题--企业实战",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/140890651",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 435,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140890651",
    "postTime": "2024-08-03 14:54:42",
    "diggCount": 8,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140890639,
    "title": "攻破工程级复杂缓存难题--企业实战",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/140890639",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 761,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140890639",
    "postTime": "2024-08-03 14:54:13",
    "diggCount": 7,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4f94f8d326bf4e04a12ac612fe676060.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140890627,
    "title": "攻破工程级复杂缓存难题--企业实战",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/140890627",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 910,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140890627",
    "postTime": "2024-08-03 14:53:36",
    "diggCount": 17,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142904218,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904218",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 305,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904218",
    "postTime": "2024-10-13 21:00:53",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142904198,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904198",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 276,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904198",
    "postTime": "2024-10-13 20:59:35",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142904022,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904022",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904022",
    "postTime": "2024-10-13 20:59:23",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142904096,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904096",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904096",
    "postTime": "2024-10-13 20:59:20",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142904072,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904072",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 293,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904072",
    "postTime": "2024-10-13 20:59:17",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142904095,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904095",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904095",
    "postTime": "2024-10-13 20:59:14",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142904073,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904073",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 234,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904073",
    "postTime": "2024-10-13 20:59:06",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142904071,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904071",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904071",
    "postTime": "2024-10-13 20:59:04",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142904185,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904185",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 403,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904185",
    "postTime": "2024-10-13 20:59:00",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142904054,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904054",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904054",
    "postTime": "2024-10-13 20:51:24",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142904003,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904003",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904003",
    "postTime": "2024-10-13 20:51:20",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142903970,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903970",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 258,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903970",
    "postTime": "2024-10-13 20:51:17",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142903989,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903989",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 369,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903989",
    "postTime": "2024-10-13 20:51:13",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142903954,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903954",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 300,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903954",
    "postTime": "2024-10-13 20:51:10",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142903935,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903935",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 206,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903935",
    "postTime": "2024-10-13 20:51:07",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142058366,
    "title": "案例分析：并行计算让代码“飞”起来10",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058366",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 704,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058366",
    "postTime": "2024-09-09 14:32:01",
    "diggCount": 19,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142058346,
    "title": "案例分析：并行计算让代码“飞”起来9",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058346",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1206,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058346",
    "postTime": "2024-09-09 14:31:24",
    "diggCount": 30,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142058299,
    "title": "案例分析：并行计算让代码“飞”起来8",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058299",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 750,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058299",
    "postTime": "2024-09-09 14:30:00",
    "diggCount": 21,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142058248,
    "title": "案例分析：并行计算让代码“飞”起来7",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058248",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 822,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058248",
    "postTime": "2024-09-09 14:28:26",
    "diggCount": 7,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142058012,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058012",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 744,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058012",
    "postTime": "2024-09-09 14:21:34",
    "diggCount": 14,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142057981,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057981",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1088,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057981",
    "postTime": "2024-09-09 14:20:52",
    "diggCount": 30,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142057961,
    "title": "案例分析：并行计算让代码“飞”起来5",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057961",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 718,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057961",
    "postTime": "2024-09-09 14:20:21",
    "diggCount": 8,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142057939,
    "title": "案例分析：并行计算让代码“飞”起来4",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057939",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 789,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057939",
    "postTime": "2024-09-09 14:19:45",
    "diggCount": 13,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142057719,
    "title": "案例分析：并行计算让代码“飞”起来3",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057719",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 840,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057719",
    "postTime": "2024-09-09 14:14:07",
    "diggCount": 32,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142057683,
    "title": "案例分析：并行计算让代码“飞”起来2",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057683",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 853,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057683",
    "postTime": "2024-09-09 14:13:34",
    "diggCount": 29,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142057417,
    "title": "案例分析：并行计算让代码“飞”起来1",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057417",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 693,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057417",
    "postTime": "2024-09-09 14:06:38",
    "diggCount": 27,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/911f467a7ab14a9d82eb34c769006364.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142025499,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025499",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 813,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025499",
    "postTime": "2024-09-08 13:27:10",
    "diggCount": 13,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142025490,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025490",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 745,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025490",
    "postTime": "2024-09-08 13:26:26",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142025471,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025471",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 799,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025471",
    "postTime": "2024-09-08 13:25:14",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142025214,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025214",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 934,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025214",
    "postTime": "2024-09-08 13:25:05",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142025190,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025190",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 838,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025190",
    "postTime": "2024-09-08 13:25:01",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142025200,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 939,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025200",
    "postTime": "2024-09-08 13:00:54",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142025174,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025174",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 648,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025174",
    "postTime": "2024-09-08 13:00:41",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142025171,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025171",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1170,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025171",
    "postTime": "2024-09-08 12:59:48",
    "diggCount": 20,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142025159,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025159",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 562,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025159",
    "postTime": "2024-09-08 12:59:41",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142025135,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025135",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 805,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025135",
    "postTime": "2024-09-08 12:55:38",
    "diggCount": 7,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142025128,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025128",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 851,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025128",
    "postTime": "2024-09-08 12:54:01",
    "diggCount": 9,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142025117,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025117",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 857,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025117",
    "postTime": "2024-09-08 12:52:45",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142025102,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025102",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 659,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025102",
    "postTime": "2024-09-08 12:51:21",
    "diggCount": 11,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142025090,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025090",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 843,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025090",
    "postTime": "2024-09-08 12:50:10",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141929018,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory26",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141929018",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 866,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929018",
    "postTime": "2024-09-05 13:49:57",
    "diggCount": 21,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141929000,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory25",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141929000",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 731,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929000",
    "postTime": "2024-09-05 13:49:14",
    "diggCount": 17,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141928982,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory24",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928982",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 236,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928982",
    "postTime": "2024-09-05 13:48:43",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141928966,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory23",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928966",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 708,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928966",
    "postTime": "2024-09-05 13:48:10",
    "diggCount": 20,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141928944,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory22",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928944",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 690,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928944",
    "postTime": "2024-09-05 13:47:35",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141928929,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory21",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928929",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 459,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928929",
    "postTime": "2024-09-05 13:47:01",
    "diggCount": 12,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141928915,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory20",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928915",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 663,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928915",
    "postTime": "2024-09-05 13:46:24",
    "diggCount": 9,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141928906,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory19",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928906",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 480,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928906",
    "postTime": "2024-09-05 13:45:49",
    "diggCount": 21,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141928892,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory18",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928892",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 266,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928892",
    "postTime": "2024-09-05 13:45:14",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141928875,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory17",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 417,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928875",
    "postTime": "2024-09-05 13:44:38",
    "diggCount": 15,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141928857,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory16",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928857",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 910,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928857",
    "postTime": "2024-09-05 13:44:04",
    "diggCount": 18,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141833464,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory15",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 893,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833464",
    "postTime": "2024-09-03 00:26:11",
    "diggCount": 23,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141833463,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory13",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833463",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 462,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833463",
    "postTime": "2024-09-03 00:25:38",
    "diggCount": 21,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141833460,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory14",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833460",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 434,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833460",
    "postTime": "2024-09-03 00:24:47",
    "diggCount": 15,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141833453,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory12",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833453",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 903,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833453",
    "postTime": "2024-09-03 00:24:13",
    "diggCount": 25,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141833449,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory11",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 574,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833449",
    "postTime": "2024-09-03 00:23:39",
    "diggCount": 12,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141833445,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory10",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833445",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 740,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833445",
    "postTime": "2024-09-03 00:23:07",
    "diggCount": 11,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141833437,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory9",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833437",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 863,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833437",
    "postTime": "2024-09-03 00:22:37",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141833434,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory8",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833434",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 473,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833434",
    "postTime": "2024-09-03 00:22:03",
    "diggCount": 16,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141833428,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory7",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833428",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 860,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833428",
    "postTime": "2024-09-03 00:21:32",
    "diggCount": 6,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141818848,
    "title": "超越常规：斐波那契数列的极速计算技术15",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141818848",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 698,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818848",
    "postTime": "2024-09-02 14:22:43",
    "diggCount": 30,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140906698,
    "title": "瞬间完成：斐波那契数列高效计算背后的科学",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906698",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 940,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906698",
    "postTime": "2024-08-04 15:27:27",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd9b924443e24a799fcea73fa1c0d72f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140906681,
    "title": "超越常规：斐波那契数列的极速计算技术",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 721,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906681",
    "postTime": "2024-08-04 15:26:34",
    "diggCount": 23,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140906547,
    "title": "探秘斐波那契数列：如何在0.02毫秒内计算21亿",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906547",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 811,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906547",
    "postTime": "2024-08-04 15:26:08",
    "diggCount": 19,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5cdc602d7d1f4d978df45f6ec95f0d1b.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140906534,
    "title": "秒懂斐波那契：算法优化实现21亿级速度突破",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906534",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 891,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906534",
    "postTime": "2024-08-04 15:25:34",
    "diggCount": 17,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8362df828ff04f0da1ab371fc89315b6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140906659,
    "title": "斐波那契数列的惊人速度：算法优化实战分享",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906659",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 809,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906659",
    "postTime": "2024-08-04 15:25:07",
    "diggCount": 25,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b78200db214141e495f3ef8e45375a3a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140906517,
    "title": "斐波那契数列的极速计算：背后的算法魔法",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906517",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 576,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906517",
    "postTime": "2024-08-04 15:25:00",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/057f9d4eeef843a69a75c97502efdafc.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140906462,
    "title": "极致优化：斐波那契数列的高效算法揭秘",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906462",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 603,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906462",
    "postTime": "2024-08-04 15:24:34",
    "diggCount": 20,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1c1ac94bba7d4103b96c27d2d07aee11.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140906608,
    "title": "从慢到快：斐波那契数列高效计算的奥秘",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906608",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 643,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906608",
    "postTime": "2024-08-04 15:24:04",
    "diggCount": 16,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/cb559b31c6fc4e52be6f7636b45cef72.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140906630,
    "title": "从基础到高效：斐波那契数列计算的算法之旅",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906630",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 397,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906630",
    "postTime": "2024-08-04 15:23:24",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/df4542ac1df9499fbef6b045d9c29d27.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140906588,
    "title": "算法的魔力：斐波那契数列的极速计算揭秘",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906588",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 820,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906588",
    "postTime": "2024-08-04 15:23:05",
    "diggCount": 15,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c020e6a282c4fe1b75c2675e7231117.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140906599,
    "title": "探究斐波那契：从基础算法到高效实现",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906599",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 416,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906599",
    "postTime": "2024-08-04 15:22:12",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7eaf7ba453a54c74a93ff28ef736fd38.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140906525,
    "title": "斐波那契数列的速度革命：高效算法实现之路",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906525",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 597,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906525",
    "postTime": "2024-08-04 15:21:45",
    "diggCount": 9,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ff5943e5562f4da8b83570e866b6e04e.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 140906593,
    "title": "极限性能：21亿斐波那契数列在0.02毫秒内计算完成",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906593",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 592,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906593",
    "postTime": "2024-08-04 15:21:13",
    "diggCount": 21,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b78200db214141e495f3ef8e45375a3a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140906580,
    "title": "斐波那契数列的算法优化：实现超高速计算",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906580",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 461,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906580",
    "postTime": "2024-08-04 15:20:05",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/28057dbe2cd14de7800a18f236bd608a.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140887854,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "一、IOC容器的刷新环节快速回顾public abstract class AbstractApplicationContext implements ApplicationContext {     @Override    public void refresh() throws BeansException, IllegalStateException {        synchronized (this.startupShutdownMonitor) {            ",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887854",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 831,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887854",
    "postTime": "2024-08-03 11:34:51",
    "diggCount": 23,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140887837,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887837",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 818,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887837",
    "postTime": "2024-08-03 11:33:57",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140887813,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887813",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 782,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887813",
    "postTime": "2024-08-03 11:33:40",
    "diggCount": 6,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140887832,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887832",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 607,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887832",
    "postTime": "2024-08-03 11:33:24",
    "diggCount": 18,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140887799,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887799",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 616,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887799",
    "postTime": "2024-08-03 11:31:22",
    "diggCount": 22,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140887790,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887790",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 505,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887790",
    "postTime": "2024-08-03 11:30:49",
    "diggCount": 8,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140887778,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887778",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 901,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887778",
    "postTime": "2024-08-03 11:30:15",
    "diggCount": 14,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140887762,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887762",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 807,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887762",
    "postTime": "2024-08-03 11:29:22",
    "diggCount": 20,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140887745,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887745",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 476,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887745",
    "postTime": "2024-08-03 11:29:11",
    "diggCount": 22,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140887625,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 962,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887625",
    "postTime": "2024-08-03 11:28:04",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140742475,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742475",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 247,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742475",
    "postTime": "2024-07-27 22:36:46",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742484,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742484",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 276,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742484",
    "postTime": "2024-07-27 22:36:33",
    "diggCount": 7,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742523,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742523",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 178,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742523",
    "postTime": "2024-07-27 22:36:18",
    "diggCount": 1,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742536,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742536",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 163,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742536",
    "postTime": "2024-07-27 22:35:59",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742612,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742612",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 377,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742612",
    "postTime": "2024-07-27 22:35:36",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742559,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742559",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742559",
    "postTime": "2024-07-27 22:31:29",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742545,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742545",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742545",
    "postTime": "2024-07-27 22:30:44",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140742509,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 397,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742509",
    "postTime": "2024-07-27 22:27:48",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140742503,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742503",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 216,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742503",
    "postTime": "2024-07-27 22:27:13",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742493,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742493",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 289,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742493",
    "postTime": "2024-07-27 22:26:38",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142896693,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896693",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 141,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896693",
    "postTime": "2024-10-13 12:31:40",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896670,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896670",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 200,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896670",
    "postTime": "2024-10-13 12:29:42",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896628,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896628",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 129,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896628",
    "postTime": "2024-10-13 12:29:28",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896643,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896643",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 118,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896643",
    "postTime": "2024-10-13 12:29:25",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896656,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896656",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 140,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896656",
    "postTime": "2024-10-13 12:29:22",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896655,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896655",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 183,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896655",
    "postTime": "2024-10-13 12:29:18",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896612,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896612",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 162,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896612",
    "postTime": "2024-10-13 12:29:15",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896597,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896597",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 198,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896597",
    "postTime": "2024-10-13 12:29:08",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896663,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896663",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 139,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896663",
    "postTime": "2024-10-13 12:29:05",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896578,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896578",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 160,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896578",
    "postTime": "2024-10-13 12:29:02",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896570,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896570",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 96,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896570",
    "postTime": "2024-10-13 12:28:58",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896558,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896558",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 194,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896558",
    "postTime": "2024-10-13 12:28:55",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896546,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896546",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 190,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896546",
    "postTime": "2024-10-13 12:28:52",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896536,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896536",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 183,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896536",
    "postTime": "2024-10-13 12:28:48",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896527,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896527",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 133,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896527",
    "postTime": "2024-10-13 12:28:44",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142623925,
    "title": "SpringBoot 服务性能优化15",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623925",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 997,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623925",
    "postTime": "2024-09-28 23:27:49",
    "diggCount": 19,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142623920,
    "title": "SpringBoot 服务性能优化14",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623920",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 707,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623920",
    "postTime": "2024-09-28 23:27:17",
    "diggCount": 8,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142623900,
    "title": "SpringBoot 服务性能优化13",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623900",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 785,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623900",
    "postTime": "2024-09-28 23:26:16",
    "diggCount": 12,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142623886,
    "title": "SpringBoot 服务性能优化12",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623886",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 598,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623886",
    "postTime": "2024-09-28 23:25:13",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142623866,
    "title": "SpringBoot 服务性能优化11",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623866",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 866,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623866",
    "postTime": "2024-09-28 23:24:50",
    "diggCount": 21,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142623875,
    "title": "SpringBoot 服务性能优化10",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 953,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623875",
    "postTime": "2024-09-28 23:24:43",
    "diggCount": 28,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142623849,
    "title": "SpringBoot 服务性能优化9",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623849",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 933,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623849",
    "postTime": "2024-09-28 23:23:40",
    "diggCount": 28,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142623860,
    "title": "SpringBoot 服务性能优化7",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623860",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 237,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623860",
    "postTime": "2024-09-28 23:23:35",
    "diggCount": 5,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142623833,
    "title": "SpringBoot 服务性能优化8",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623833",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 622,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623833",
    "postTime": "2024-09-28 23:22:08",
    "diggCount": 9,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142623826,
    "title": "SpringBoot 服务性能优化5",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623826",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 945,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623826",
    "postTime": "2024-09-28 23:21:27",
    "diggCount": 20,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142623752,
    "title": "SpringBoot 服务性能优化6",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623752",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 905,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623752",
    "postTime": "2024-09-28 23:20:52",
    "diggCount": 9,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142623813,
    "title": "SpringBoot 服务性能优化4",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623813",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 220,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623813",
    "postTime": "2024-09-28 23:20:45",
    "diggCount": 3,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142623792,
    "title": "SpringBoot 服务性能优化3",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623792",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 613,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623792",
    "postTime": "2024-09-28 23:20:41",
    "diggCount": 21,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142623774,
    "title": "SpringBoot 服务性能优化2",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623774",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 991,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623774",
    "postTime": "2024-09-28 23:20:19",
    "diggCount": 19,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142623740,
    "title": "SpringBoot 服务性能优化1",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623740",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 775,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623740",
    "postTime": "2024-09-28 23:20:16",
    "diggCount": 19,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142029460,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029460",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 867,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029460",
    "postTime": "2024-09-08 16:55:55",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142029404,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029404",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 552,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029404",
    "postTime": "2024-09-08 16:55:26",
    "diggCount": 27,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142029449,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 835,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029449",
    "postTime": "2024-09-08 16:55:21",
    "diggCount": 27,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142029417,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029417",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1038,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029417",
    "postTime": "2024-09-08 16:54:01",
    "diggCount": 19,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142029381,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029381",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 596,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029381",
    "postTime": "2024-09-08 16:53:35",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142029393,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029393",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 849,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029393",
    "postTime": "2024-09-08 16:52:55",
    "diggCount": 7,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142029363,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029363",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 537,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029363",
    "postTime": "2024-09-08 16:52:06",
    "diggCount": 18,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142029337,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029337",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 566,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029337",
    "postTime": "2024-09-08 16:52:01",
    "diggCount": 10,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142029315,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029315",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 918,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029315",
    "postTime": "2024-09-08 16:51:51",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142029293,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029293",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 698,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029293",
    "postTime": "2024-09-08 16:51:44",
    "diggCount": 24,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142029271,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029271",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 897,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029271",
    "postTime": "2024-09-08 16:51:41",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142029257,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029257",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 915,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029257",
    "postTime": "2024-09-08 16:51:37",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142029348,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029348",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 636,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029348",
    "postTime": "2024-09-08 16:51:04",
    "diggCount": 10,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142029328,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029328",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 809,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029328",
    "postTime": "2024-09-08 16:50:01",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142029307,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029307",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 895,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029307",
    "postTime": "2024-09-08 16:48:54",
    "diggCount": 21,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141968569,
    "title": "【无标题】",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141968569",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 519,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141968569",
    "postTime": "2024-09-07 03:25:30",
    "diggCount": 17,
    "formatTime": "2024.09.07",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141934471,
    "title": "案例分析：大对象复用的目标和注意点5",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141934471",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 255,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934471",
    "postTime": "2024-09-05 16:23:40",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141934448,
    "title": "案例分析：大对象复用的目标和注意点4",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141934448",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934448",
    "postTime": "2024-09-05 16:23:09",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141934415,
    "title": "案例分析：大对象复用的目标和注意点3",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141934415",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934415",
    "postTime": "2024-09-05 16:22:16",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141934392,
    "title": "案例分析：大对象复用的目标和注意点2",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141934392",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 334,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934392",
    "postTime": "2024-09-05 16:21:45",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141934271,
    "title": "案例分析：大对象复用的目标和注意点1",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141934271",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 402,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934271",
    "postTime": "2024-09-05 16:18:59",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141888206,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法25",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141888206",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888206",
    "postTime": "2024-09-04 11:09:34",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141888180,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法21",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141888180",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888180",
    "postTime": "2024-09-04 11:09:03",
    "diggCount": 2,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141888142,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法20",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141888142",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 430,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888142",
    "postTime": "2024-09-04 11:08:00",
    "diggCount": 3,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141888082,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法18",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141888082",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888082",
    "postTime": "2024-09-04 11:06:25",
    "diggCount": 4,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141887951,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法22",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887951",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 190,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887951",
    "postTime": "2024-09-04 11:03:04",
    "diggCount": 5,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141887878,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法24",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887878",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887878",
    "postTime": "2024-09-04 11:00:59",
    "diggCount": 3,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141887860,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法19",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887860",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887860",
    "postTime": "2024-09-04 11:00:29",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141887840,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法26",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887840",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887840",
    "postTime": "2024-09-04 11:00:02",
    "diggCount": 4,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141887801,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法27",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887801",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 197,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887801",
    "postTime": "2024-09-04 10:59:46",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141887656,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法23",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887656",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 282,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887656",
    "postTime": "2024-09-04 10:59:34",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141887757,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法28",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887757",
    "postTime": "2024-09-04 10:59:21",
    "diggCount": 1,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141887722,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法29",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887722",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 260,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887722",
    "postTime": "2024-09-04 10:59:16",
    "diggCount": 2,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141887604,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法30",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887604",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 309,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887604",
    "postTime": "2024-09-04 10:59:11",
    "diggCount": 4,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141887691,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法17",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887691",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 321,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887691",
    "postTime": "2024-09-04 10:55:51",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141887640,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法16",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887640",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 208,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887640",
    "postTime": "2024-09-04 10:54:32",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141865676,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法15",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865676",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 402,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865676",
    "postTime": "2024-09-03 16:39:10",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865652,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法14",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865652",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 344,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865652",
    "postTime": "2024-09-03 16:38:36",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141865633,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法13",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865633",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865633",
    "postTime": "2024-09-03 16:38:03",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141865601,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法11",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865601",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 395,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865601",
    "postTime": "2024-09-03 16:37:10",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141865588,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法10",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865588",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 484,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865588",
    "postTime": "2024-09-03 16:36:31",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141865565,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法9",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865565",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865565",
    "postTime": "2024-09-03 16:35:54",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865548,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法8",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865548",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 418,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865548",
    "postTime": "2024-09-03 16:35:22",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865533,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法7",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865533",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 325,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865533",
    "postTime": "2024-09-03 16:34:49",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141865512,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法6",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865512",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865512",
    "postTime": "2024-09-03 16:34:15",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141865488,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法5",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865488",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865488",
    "postTime": "2024-09-03 16:33:35",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141865469,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法4",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865469",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 293,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865469",
    "postTime": "2024-09-03 16:33:02",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141865451,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法3",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865451",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865451",
    "postTime": "2024-09-03 16:32:26",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141865434,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法2",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865434",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 274,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865434",
    "postTime": "2024-09-03 16:31:52",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141865405,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法1",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865405",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865405",
    "postTime": "2024-09-03 16:31:21",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142865883,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865883",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 476,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865883",
    "postTime": "2024-10-11 23:57:34",
    "diggCount": 7,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142865859,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865859",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 662,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865859",
    "postTime": "2024-10-11 23:57:29",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142865884,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865884",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 414,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865884",
    "postTime": "2024-10-11 23:57:26",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142865899,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865899",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 854,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865899",
    "postTime": "2024-10-11 23:57:22",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142865873,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865873",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 555,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865873",
    "postTime": "2024-10-11 23:56:49",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142865890,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865890",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 784,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865890",
    "postTime": "2024-10-11 23:56:45",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142865839,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865839",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 730,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865839",
    "postTime": "2024-10-11 23:56:03",
    "diggCount": 6,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142865850,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865850",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 405,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865850",
    "postTime": "2024-10-11 23:55:59",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142865872,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865872",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 502,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865872",
    "postTime": "2024-10-11 23:55:56",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142865858,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865858",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 361,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865858",
    "postTime": "2024-10-11 23:55:21",
    "diggCount": 14,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142865831,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865831",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 749,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865831",
    "postTime": "2024-10-11 23:55:17",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142865820,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865820",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 428,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865820",
    "postTime": "2024-10-11 23:55:13",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142865804,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865804",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 377,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865804",
    "postTime": "2024-10-11 23:50:30",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142865793,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865793",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 787,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865793",
    "postTime": "2024-10-11 23:50:26",
    "diggCount": 16,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142865781,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865781",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 438,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865781",
    "postTime": "2024-10-11 23:50:22",
    "diggCount": 14,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142624122,
    "title": "SpringBoot 服务性能优化15",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624122",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 653,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624122",
    "postTime": "2024-09-28 23:43:59",
    "diggCount": 22,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142624115,
    "title": "SpringBoot 服务性能优化14",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624115",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 952,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624115",
    "postTime": "2024-09-28 23:43:19",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142624085,
    "title": "SpringBoot 服务性能优化12",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624085",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 536,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624085",
    "postTime": "2024-09-28 23:40:59",
    "diggCount": 8,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142624083,
    "title": "SpringBoot 服务性能优化11",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624083",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1071,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624083",
    "postTime": "2024-09-28 23:40:28",
    "diggCount": 26,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142624063,
    "title": "SpringBoot 服务性能优化13",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624063",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 815,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624063",
    "postTime": "2024-09-28 23:39:58",
    "diggCount": 25,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142624071,
    "title": "SpringBoot 服务性能优化10",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624071",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 767,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624071",
    "postTime": "2024-09-28 23:39:40",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142624056,
    "title": "SpringBoot 服务性能优化8",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624056",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 706,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624056",
    "postTime": "2024-09-28 23:38:18",
    "diggCount": 20,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142624047,
    "title": "SpringBoot 服务性能优化9",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624047",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 994,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624047",
    "postTime": "2024-09-28 23:37:48",
    "diggCount": 27,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142624035,
    "title": "SpringBoot 服务性能优化7",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624035",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 739,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624035",
    "postTime": "2024-09-28 23:36:31",
    "diggCount": 15,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142624021,
    "title": "SpringBoot 服务性能优化6",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624021",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 756,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624021",
    "postTime": "2024-09-28 23:36:13",
    "diggCount": 17,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142624012,
    "title": "SpringBoot 服务性能优化5",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624012",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 858,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624012",
    "postTime": "2024-09-28 23:36:08",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142623990,
    "title": "SpringBoot 服务性能优化4",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142623990",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623990",
    "postTime": "2024-09-28 23:33:55",
    "diggCount": 18,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142623984,
    "title": "SpringBoot 服务性能优化2",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142623984",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 712,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623984",
    "postTime": "2024-09-28 23:33:47",
    "diggCount": 30,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142623972,
    "title": "SpringBoot 服务性能优化1",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142623972",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1056,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623972",
    "postTime": "2024-09-28 23:33:44",
    "diggCount": 9,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142623960,
    "title": "SpringBoot 服务性能优化3",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142623960",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 731,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623960",
    "postTime": "2024-09-28 23:33:39",
    "diggCount": 18,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142029677,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029677",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 811,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029677",
    "postTime": "2024-09-08 17:08:05",
    "diggCount": 11,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142029613,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029613",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1016,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029613",
    "postTime": "2024-09-08 17:07:34",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142029666,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029666",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 727,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029666",
    "postTime": "2024-09-08 17:07:26",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142029658,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1105,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029658",
    "postTime": "2024-09-08 17:06:56",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142029558,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029558",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 551,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029558",
    "postTime": "2024-09-08 17:06:36",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142029646,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029646",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1094,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029646",
    "postTime": "2024-09-08 17:06:27",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142029539,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029539",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1104,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029539",
    "postTime": "2024-09-08 17:06:23",
    "diggCount": 24,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142029523,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029523",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 583,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029523",
    "postTime": "2024-09-08 17:06:19",
    "diggCount": 10,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142029507,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029507",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1125,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029507",
    "postTime": "2024-09-08 17:06:16",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142029634,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029634",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1051,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029634",
    "postTime": "2024-09-08 17:05:46",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142029625,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 940,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029625",
    "postTime": "2024-09-08 17:05:13",
    "diggCount": 20,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142029585,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029585",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 872,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029585",
    "postTime": "2024-09-08 17:04:33",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142029591,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029591",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 938,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029591",
    "postTime": "2024-09-08 17:03:18",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142029575,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029575",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 666,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029575",
    "postTime": "2024-09-08 17:02:16",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142029552,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029552",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 686,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029552",
    "postTime": "2024-09-08 17:01:10",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141934978,
    "title": "案例分析：大对象复用的目标和注意点10",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934978",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 426,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934978",
    "postTime": "2024-09-05 16:37:13",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141934954,
    "title": "案例分析：大对象复用的目标和注意点9",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934954",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 873,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934954",
    "postTime": "2024-09-05 16:36:41",
    "diggCount": 16,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141934934,
    "title": "案例分析：大对象复用的目标和注意点8",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934934",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1051,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934934",
    "postTime": "2024-09-05 16:35:51",
    "diggCount": 24,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 141934898,
    "title": "案例分析：大对象复用的目标和注意点7",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934898",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 823,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934898",
    "postTime": "2024-09-05 16:35:15",
    "diggCount": 20,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 141934858,
    "title": "案例分析：大对象复用的目标和注意点6",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934858",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 465,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934858",
    "postTime": "2024-09-05 16:33:37",
    "diggCount": 9,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141934829,
    "title": "案例分析：大对象复用的目标和注意点5",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934829",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934829",
    "postTime": "2024-09-05 16:32:51",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141934796,
    "title": "案例分析：大对象复用的目标和注意点4",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934796",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 362,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934796",
    "postTime": "2024-09-05 16:32:16",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141934771,
    "title": "案例分析：大对象复用的目标和注意点3",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934771",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934771",
    "postTime": "2024-09-05 16:31:44",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141934715,
    "title": "案例分析：大对象复用的目标和注意点2",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934715",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 401,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934715",
    "postTime": "2024-09-05 16:29:58",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141934681,
    "title": "案例分析：大对象复用的目标和注意点1",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 215,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934681",
    "postTime": "2024-09-05 16:29:08",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141886634,
    "title": "案例研究：缓冲区技术如何优化代码执行速度30",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886634",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1049,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886634",
    "postTime": "2024-09-04 10:29:30",
    "diggCount": 31,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/75e0b831dd114401a0f5634000ed0a60.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141886612,
    "title": "案例研究：缓冲区技术如何优化代码执行速度29",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886612",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 937,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886612",
    "postTime": "2024-09-04 10:28:55",
    "diggCount": 16,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6f940d11c337498391787cee80aceb3c.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141886580,
    "title": "案例研究：缓冲区技术如何优化代码执行速度28",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886580",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 819,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886580",
    "postTime": "2024-09-04 10:28:17",
    "diggCount": 28,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 141886559,
    "title": "案例研究：缓冲区技术如何优化代码执行速度27",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886559",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 923,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886559",
    "postTime": "2024-09-04 10:27:43",
    "diggCount": 28,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/051717ca00b6481490d33fad1452204e.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141886541,
    "title": "案例研究：缓冲区技术如何优化代码执行速度26",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886541",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 796,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886541",
    "postTime": "2024-09-04 10:27:07",
    "diggCount": 23,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141886528,
    "title": "案例研究：缓冲区技术如何优化代码执行速度25",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886528",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 783,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886528",
    "postTime": "2024-09-04 10:26:36",
    "diggCount": 16,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 141886500,
    "title": "案例研究：缓冲区技术如何优化代码执行速度24",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886500",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 851,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886500",
    "postTime": "2024-09-04 10:26:06",
    "diggCount": 30,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141886474,
    "title": "案例研究：缓冲区技术如何优化代码执行速度23",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886474",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 889,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886474",
    "postTime": "2024-09-04 10:25:34",
    "diggCount": 19,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141886427,
    "title": "案例研究：缓冲区技术如何优化代码执行速度22",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886427",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1127,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886427",
    "postTime": "2024-09-04 10:24:28",
    "diggCount": 12,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d9cd198d67af41d4b77c50d9a33c8398.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 141886406,
    "title": "案例研究：缓冲区技术如何优化代码执行速度21",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886406",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 765,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886406",
    "postTime": "2024-09-04 10:23:55",
    "diggCount": 28,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141886385,
    "title": "案例研究：缓冲区技术如何优化代码执行速度20",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886385",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 674,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886385",
    "postTime": "2024-09-04 10:23:23",
    "diggCount": 12,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141886373,
    "title": "案例研究：缓冲区技术如何优化代码执行速度19",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886373",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 745,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886373",
    "postTime": "2024-09-04 10:22:51",
    "diggCount": 14,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141886351,
    "title": "案例研究：缓冲区技术如何优化代码执行速度18",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886351",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 933,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886351",
    "postTime": "2024-09-04 10:22:20",
    "diggCount": 29,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141886306,
    "title": "案例研究：缓冲区技术如何优化代码执行速度17",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886306",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 768,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886306",
    "postTime": "2024-09-04 10:21:05",
    "diggCount": 17,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 141886295,
    "title": "案例研究：缓冲区技术如何优化代码执行速度16",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886295",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1188,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886295",
    "postTime": "2024-09-04 10:20:34",
    "diggCount": 7,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 141866226,
    "title": "案例研究：缓冲区技术如何优化代码执行速度15",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866226",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1073,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866226",
    "postTime": "2024-09-03 16:53:41",
    "diggCount": 12,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6f940d11c337498391787cee80aceb3c.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 141866200,
    "title": "案例研究：缓冲区技术如何优化代码执行速度11",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 425,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866200",
    "postTime": "2024-09-03 16:52:54",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/051717ca00b6481490d33fad1452204e.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141866182,
    "title": "案例研究：缓冲区技术如何优化代码执行速度6",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866182",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 688,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866182",
    "postTime": "2024-09-03 16:52:18",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d9cd198d67af41d4b77c50d9a33c8398.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 141866161,
    "title": "案例研究：缓冲区技术如何优化代码执行速度4",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866161",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 356,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866161",
    "postTime": "2024-09-03 16:51:44",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141866138,
    "title": "案例研究：缓冲区技术如何优化代码执行速度13",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866138",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 508,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866138",
    "postTime": "2024-09-03 16:51:10",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141866118,
    "title": "案例研究：缓冲区技术如何优化代码执行速度9",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866118",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 815,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866118",
    "postTime": "2024-09-03 16:50:38",
    "diggCount": 19,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141866093,
    "title": "案例研究：缓冲区技术如何优化代码执行速度5",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866093",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 464,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866093",
    "postTime": "2024-09-03 16:50:03",
    "diggCount": 7,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141866069,
    "title": "案例研究：缓冲区技术如何优化代码执行速度14",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866069",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866069",
    "postTime": "2024-09-03 16:49:28",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141866006,
    "title": "案例研究：缓冲区技术如何优化代码执行速度12",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866006",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1168,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866006",
    "postTime": "2024-09-03 16:49:11",
    "diggCount": 26,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141866048,
    "title": "案例研究：缓冲区技术如何优化代码执行速度10",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866048",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1095,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866048",
    "postTime": "2024-09-03 16:48:56",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140891326,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891326",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 665,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891326",
    "postTime": "2024-08-03 15:29:55",
    "diggCount": 23,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140891318,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891318",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 524,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891318",
    "postTime": "2024-08-03 15:29:15",
    "diggCount": 10,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140891304,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 605,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891304",
    "postTime": "2024-08-03 15:28:39",
    "diggCount": 21,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140891285,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891285",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 910,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891285",
    "postTime": "2024-08-03 15:28:30",
    "diggCount": 17,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 140891257,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891257",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 778,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891257",
    "postTime": "2024-08-03 15:28:24",
    "diggCount": 11,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140891238,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891238",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 971,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891238",
    "postTime": "2024-08-03 15:28:19",
    "diggCount": 28,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140891217,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891217",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891217",
    "postTime": "2024-08-03 15:23:43",
    "diggCount": 14,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140891194,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891194",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 629,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891194",
    "postTime": "2024-08-03 15:23:36",
    "diggCount": 15,
    "formatTime": "2024.08.03",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 143030464,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 221,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030464",
    "postTime": "2024-10-17 22:53:09",
    "diggCount": 7,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 143030345,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030345",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 222,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030345",
    "postTime": "2024-10-17 22:53:05",
    "diggCount": 6,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143030391,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030391",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 507,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030391",
    "postTime": "2024-10-17 22:52:59",
    "diggCount": 9,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143030364,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030364",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030364",
    "postTime": "2024-10-17 22:52:55",
    "diggCount": 2,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143030378,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030378",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 224,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030378",
    "postTime": "2024-10-17 22:52:46",
    "diggCount": 2,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 143030377,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030377",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 286,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030377",
    "postTime": "2024-10-17 22:52:41",
    "diggCount": 13,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143030429,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030429",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 414,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030429",
    "postTime": "2024-10-17 22:52:38",
    "diggCount": 5,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143030403,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030403",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030403",
    "postTime": "2024-10-17 22:50:48",
    "diggCount": 6,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143030414,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030414",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030414",
    "postTime": "2024-10-17 22:50:42",
    "diggCount": 10,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143030332,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030332",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 324,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030332",
    "postTime": "2024-10-17 22:49:25",
    "diggCount": 3,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143030314,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030314",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 228,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030314",
    "postTime": "2024-10-17 22:49:21",
    "diggCount": 6,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143030301,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030301",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030301",
    "postTime": "2024-10-17 22:49:13",
    "diggCount": 4,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143030287,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030287",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 363,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030287",
    "postTime": "2024-10-17 22:43:32",
    "diggCount": 5,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 143030269,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030269",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 511,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030269",
    "postTime": "2024-10-17 22:43:28",
    "diggCount": 10,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143030286,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030286",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 370,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030286",
    "postTime": "2024-10-17 22:43:23",
    "diggCount": 8,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142624250,
    "title": "SpringBoot 服务性能优化15",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624250",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 924,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624250",
    "postTime": "2024-09-28 23:57:17",
    "diggCount": 19,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142624243,
    "title": "SpringBoot 服务性能优化12",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624243",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 843,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624243",
    "postTime": "2024-09-28 23:56:28",
    "diggCount": 29,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142624239,
    "title": "SpringBoot 服务性能优化13",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624239",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 811,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624239",
    "postTime": "2024-09-28 23:55:46",
    "diggCount": 21,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142624235,
    "title": "SpringBoot 服务性能优化9",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624235",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 884,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624235",
    "postTime": "2024-09-28 23:55:14",
    "diggCount": 15,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142624229,
    "title": "SpringBoot 服务性能优化14",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624229",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 848,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624229",
    "postTime": "2024-09-28 23:55:02",
    "diggCount": 17,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142624219,
    "title": "SpringBoot 服务性能优化11",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624219",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 900,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624219",
    "postTime": "2024-09-28 23:54:05",
    "diggCount": 15,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142624212,
    "title": "SpringBoot 服务性能优化10",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624212",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 736,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624212",
    "postTime": "2024-09-28 23:53:53",
    "diggCount": 27,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142624205,
    "title": "SpringBoot 服务性能优化8",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624205",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 951,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624205",
    "postTime": "2024-09-28 23:52:53",
    "diggCount": 27,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142624182,
    "title": "SpringBoot 服务性能优化7",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624182",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 815,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624182",
    "postTime": "2024-09-28 23:52:24",
    "diggCount": 15,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142624202,
    "title": "SpringBoot 服务性能优化6",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624202",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1051,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624202",
    "postTime": "2024-09-28 23:52:17",
    "diggCount": 19,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142624190,
    "title": "SpringBoot 服务性能优化5",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624190",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 959,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624190",
    "postTime": "2024-09-28 23:51:13",
    "diggCount": 12,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142624176,
    "title": "SpringBoot 服务性能优化4",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624176",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 953,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624176",
    "postTime": "2024-09-28 23:49:55",
    "diggCount": 26,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142624170,
    "title": "SpringBoot 服务性能优化3",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624170",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1018,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624170",
    "postTime": "2024-09-28 23:49:22",
    "diggCount": 11,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142624164,
    "title": "SpringBoot 服务性能优化2",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624164",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 900,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624164",
    "postTime": "2024-09-28 23:49:16",
    "diggCount": 21,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142624161,
    "title": "SpringBoot 服务性能优化1",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624161",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 851,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624161",
    "postTime": "2024-09-28 23:49:08",
    "diggCount": 24,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142029909,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029909",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 363,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029909",
    "postTime": "2024-09-08 17:22:02",
    "diggCount": 3,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142029898,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029898",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 660,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029898",
    "postTime": "2024-09-08 17:21:23",
    "diggCount": 20,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142029888,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029888",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 774,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029888",
    "postTime": "2024-09-08 17:20:45",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142029875,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 712,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029875",
    "postTime": "2024-09-08 17:20:12",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142029852,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029852",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 623,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029852",
    "postTime": "2024-09-08 17:20:07",
    "diggCount": 26,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142029866,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029866",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1248,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029866",
    "postTime": "2024-09-08 17:19:59",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142029807,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029807",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029807",
    "postTime": "2024-09-08 17:18:11",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142029837,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029837",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 885,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029837",
    "postTime": "2024-09-08 17:18:05",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142029820,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029820",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1087,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029820",
    "postTime": "2024-09-08 17:17:53",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142029775,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029775",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 620,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029775",
    "postTime": "2024-09-08 17:17:50",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 141887292,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践19",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887292",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 800,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887292",
    "postTime": "2024-09-04 10:45:40",
    "diggCount": 23,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141887062,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践21",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887062",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 616,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887062",
    "postTime": "2024-09-04 10:44:15",
    "diggCount": 16,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141887102,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践22",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887102",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 855,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887102",
    "postTime": "2024-09-04 10:44:10",
    "diggCount": 12,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141887018,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践23",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887018",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 433,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887018",
    "postTime": "2024-09-04 10:44:05",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141887139,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践24",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887139",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 789,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887139",
    "postTime": "2024-09-04 10:44:00",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141887210,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践27",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887210",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 736,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887210",
    "postTime": "2024-09-04 10:43:42",
    "diggCount": 14,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141887189,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践20",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887189",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 622,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887189",
    "postTime": "2024-09-04 10:43:09",
    "diggCount": 13,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141886968,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践17",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141886968",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 912,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886968",
    "postTime": "2024-09-04 10:38:58",
    "diggCount": 25,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141886994,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践30",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141886994",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 761,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886994",
    "postTime": "2024-09-04 10:38:36",
    "diggCount": 15,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141886906,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践16",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141886906",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 474,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886906",
    "postTime": "2024-09-04 10:36:20",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141866675,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践15",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866675",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 228,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866675",
    "postTime": "2024-09-03 17:06:10",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141866660,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践14",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866660",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866660",
    "postTime": "2024-09-03 17:05:35",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141866634,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践13",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866634",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 238,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866634",
    "postTime": "2024-09-03 17:05:04",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141866613,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践12",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866613",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 408,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866613",
    "postTime": "2024-09-03 17:04:30",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141866590,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践11",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866590",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 316,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866590",
    "postTime": "2024-09-03 17:04:00",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141866570,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践10",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866570",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 286,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866570",
    "postTime": "2024-09-03 17:03:27",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141866554,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践9",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866554",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 667,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866554",
    "postTime": "2024-09-03 17:02:46",
    "diggCount": 17,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141866537,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践9",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866537",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 721,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866537",
    "postTime": "2024-09-03 17:02:12",
    "diggCount": 18,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141866512,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践8",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866512",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 610,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866512",
    "postTime": "2024-09-03 17:01:36",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141866490,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践7",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866490",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866490",
    "postTime": "2024-09-03 17:00:54",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141866465,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践6",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866465",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866465",
    "postTime": "2024-09-03 17:00:19",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141866427,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践4",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866427",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 277,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866427",
    "postTime": "2024-09-03 16:59:10",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141866407,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践3",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866407",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 633,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866407",
    "postTime": "2024-09-03 16:58:37",
    "diggCount": 21,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141866333,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践2",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866333",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 445,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866333",
    "postTime": "2024-09-03 16:56:45",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141866312,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践1",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866312",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 918,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866312",
    "postTime": "2024-09-03 16:56:11",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141818752,
    "title": "打造 ContextManager：ThreadLocal 技术的深度应用",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818752",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 897,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818752",
    "postTime": "2024-09-02 14:19:25",
    "diggCount": 7,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141818733,
    "title": "ThreadLocal 与上下文管理的完美结合：ContextManager 解析",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818733",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 560,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818733",
    "postTime": "2024-09-02 14:18:43",
    "diggCount": 11,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141818721,
    "title": "实现 ContextManager 的 ThreadLocal 技术探秘",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818721",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 681,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818721",
    "postTime": "2024-09-02 14:18:12",
    "diggCount": 9,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141818700,
    "title": "灵活上下文管理：ThreadLocal 助力 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818700",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 895,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818700",
    "postTime": "2024-09-02 14:17:42",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141818679,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818679",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 549,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818679",
    "postTime": "2024-09-02 14:17:04",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141818671,
    "title": "高效上下文管理：ThreadLocal 在 ContextManager 中的应用",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818671",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 696,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818671",
    "postTime": "2024-09-02 14:16:58",
    "diggCount": 14,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141818635,
    "title": "从零开始：基于 ThreadLocal 的 ContextManager 构建之道",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818635",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818635",
    "postTime": "2024-09-02 14:15:26",
    "diggCount": 17,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141818623,
    "title": "ThreadLocal 技术详解：打造高效的 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818623",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 814,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818623",
    "postTime": "2024-09-02 14:14:53",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141818593,
    "title": "轻松管理上下文：ThreadLocal 助力 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818593",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 587,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818593",
    "postTime": "2024-09-02 14:13:59",
    "diggCount": 30,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141818551,
    "title": "线程安全的上下文管理：ContextManager 的 ThreadLocal 实现",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818551",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1009,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818551",
    "postTime": "2024-09-02 14:13:53",
    "diggCount": 14,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141818573,
    "title": "上下文管理的艺术：ThreadLocal 如何赋能 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818573",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 880,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818573",
    "postTime": "2024-09-02 14:13:14",
    "diggCount": 11,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141818521,
    "title": "ContextManager 实战：ThreadLocal 的最佳实践",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818521",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1176,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818521",
    "postTime": "2024-09-02 14:12:02",
    "diggCount": 23,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141818499,
    "title": "如何用 ThreadLocal 构建强大的 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818499",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 838,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818499",
    "postTime": "2024-09-02 14:11:58",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141818538,
    "title": "深入剖析：基于 ThreadLocal 实现的 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818538",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 840,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818538",
    "postTime": "2024-09-02 14:11:48",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141818456,
    "title": "揭秘 ContextManager：ThreadLocal 在上下文管理中的应用",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818456",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 589,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818456",
    "postTime": "2024-09-02 14:09:04",
    "diggCount": 18,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140891717,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891717",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 424,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891717",
    "postTime": "2024-08-03 15:48:40",
    "diggCount": 5,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140891704,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891704",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 243,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891704",
    "postTime": "2024-08-03 15:47:50",
    "diggCount": 4,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bbc7e571f77c42288248778eaf6473ce.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140891690,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891690",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 919,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891690",
    "postTime": "2024-08-03 15:47:30",
    "diggCount": 13,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b43905959810494090a9c4ca5017e885.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140891494,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891494",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 641,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891494",
    "postTime": "2024-08-03 15:47:11",
    "diggCount": 22,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/22a31904b5494b8ca1dcec579fb0ed09.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140891605,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891605",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 763,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891605",
    "postTime": "2024-08-03 15:46:43",
    "diggCount": 8,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f7ed4a451e144b299b86f08642df1bf.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140891655,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891655",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 241,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891655",
    "postTime": "2024-08-03 15:45:48",
    "diggCount": 5,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/00267d299cd4409c8dc6d65414ca50b0.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140891644,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891644",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 861,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891644",
    "postTime": "2024-08-03 15:45:06",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/af3eef3342424f56b2c6046e10bb285c.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140891626,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891626",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 713,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891626",
    "postTime": "2024-08-03 15:44:09",
    "diggCount": 16,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e3f02390d71b406783f7de4248a04ebc.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140891595,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891595",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 884,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891595",
    "postTime": "2024-08-03 15:42:52",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6e07b5fa98e943e7ad62b2e47ee211ad.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140891572,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891572",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 867,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891572",
    "postTime": "2024-08-03 15:42:29",
    "diggCount": 26,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/dec3a8721a964a698b662c85cc2a2d83.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140891551,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891551",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 832,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891551",
    "postTime": "2024-08-03 15:41:38",
    "diggCount": 17,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c6c9ff3fa05f4c7fb8eab179e766e7f7.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142934088,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934088",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 498,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934088",
    "postTime": "2024-10-15 09:03:37",
    "diggCount": 14,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142934068,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934068",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 683,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934068",
    "postTime": "2024-10-15 09:03:33",
    "diggCount": 19,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142934200,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934200",
    "postTime": "2024-10-15 09:03:30",
    "diggCount": 17,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142934152,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934152",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 648,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934152",
    "postTime": "2024-10-15 09:03:27",
    "diggCount": 10,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142934128,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934128",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 538,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934128",
    "postTime": "2024-10-15 09:03:23",
    "diggCount": 9,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142934230,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934230",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 647,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934230",
    "postTime": "2024-10-15 09:03:20",
    "diggCount": 28,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142934114,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934114",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 608,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934114",
    "postTime": "2024-10-15 09:03:17",
    "diggCount": 19,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142934178,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934178",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 713,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934178",
    "postTime": "2024-10-15 09:03:14",
    "diggCount": 19,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142934177,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934177",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 677,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934177",
    "postTime": "2024-10-15 09:03:11",
    "diggCount": 18,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142934046,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934046",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 621,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934046",
    "postTime": "2024-10-15 09:03:08",
    "diggCount": 24,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142934045,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934045",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 769,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934045",
    "postTime": "2024-10-15 09:03:04",
    "diggCount": 15,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142934026,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934026",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 592,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934026",
    "postTime": "2024-10-15 09:03:01",
    "diggCount": 8,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142933986,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142933986",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 505,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933986",
    "postTime": "2024-10-15 09:02:58",
    "diggCount": 16,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142934005,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934005",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 879,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934005",
    "postTime": "2024-10-15 09:02:55",
    "diggCount": 21,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142933961,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142933961",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 964,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933961",
    "postTime": "2024-10-15 09:02:50",
    "diggCount": 14,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142896842,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896842",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 222,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896842",
    "postTime": "2024-10-13 13:04:45",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142896985,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896985",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 408,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896985",
    "postTime": "2024-10-13 13:04:42",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142896984,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896984",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896984",
    "postTime": "2024-10-13 13:04:38",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142896959,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896959",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 263,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896959",
    "postTime": "2024-10-13 13:04:35",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897039,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142897039",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 336,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897039",
    "postTime": "2024-10-13 13:04:31",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897006,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142897006",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 378,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897006",
    "postTime": "2024-10-13 13:04:24",
    "diggCount": 7,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142896958,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896958",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896958",
    "postTime": "2024-10-13 12:58:02",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142896973,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896973",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 357,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896973",
    "postTime": "2024-10-13 12:57:58",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142896947,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896947",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 371,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896947",
    "postTime": "2024-10-13 12:55:29",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142896936,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896936",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 270,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896936",
    "postTime": "2024-10-13 12:53:24",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142896916,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896916",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896916",
    "postTime": "2024-10-13 12:53:20",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142896917,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896917",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896917",
    "postTime": "2024-10-13 12:53:14",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142896902,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896902",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 376,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896902",
    "postTime": "2024-10-13 12:53:10",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142896881,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896881",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 259,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896881",
    "postTime": "2024-10-13 12:50:53",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142896865,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896865",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 204,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896865",
    "postTime": "2024-10-13 12:50:50",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142866127,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866127",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 188,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866127",
    "postTime": "2024-10-12 00:20:53",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866116,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866116",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 248,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866116",
    "postTime": "2024-10-12 00:19:55",
    "diggCount": 7,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866108,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866108",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 154,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866108",
    "postTime": "2024-10-12 00:19:14",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866104,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866104",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 191,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866104",
    "postTime": "2024-10-12 00:18:42",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866101,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866101",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 142,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866101",
    "postTime": "2024-10-12 00:18:12",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866047,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866047",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 187,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866047",
    "postTime": "2024-10-12 00:17:45",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866067,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866067",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 119,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866067",
    "postTime": "2024-10-12 00:17:41",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866098,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866098",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 186,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866098",
    "postTime": "2024-10-12 00:17:33",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866085,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866085",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 175,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866085",
    "postTime": "2024-10-12 00:17:20",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866072,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866072",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 180,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866072",
    "postTime": "2024-10-12 00:17:16",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866095,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866095",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 186,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866095",
    "postTime": "2024-10-12 00:16:57",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866052,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866052",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 88,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866052",
    "postTime": "2024-10-12 00:13:56",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866062,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866062",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 106,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866062",
    "postTime": "2024-10-12 00:13:51",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866037,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866037",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 192,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866037",
    "postTime": "2024-10-12 00:11:52",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866026,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866026",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 94,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866026",
    "postTime": "2024-10-12 00:11:48",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142799888,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799888",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 819,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799888",
    "postTime": "2024-10-10 07:46:30",
    "diggCount": 15,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142799945,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799945",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 714,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799945",
    "postTime": "2024-10-10 07:46:25",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142799916,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799916",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 796,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799916",
    "postTime": "2024-10-10 07:46:19",
    "diggCount": 18,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142799950,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799950",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 786,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799950",
    "postTime": "2024-10-10 07:46:14",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142799935,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799935",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 903,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799935",
    "postTime": "2024-10-10 07:46:10",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142799944,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799944",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 802,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799944",
    "postTime": "2024-10-10 07:46:07",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142799928,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799928",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 674,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799928",
    "postTime": "2024-10-10 07:46:02",
    "diggCount": 21,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142799936,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799936",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 971,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799936",
    "postTime": "2024-10-10 07:45:59",
    "diggCount": 16,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142799956,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799956",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 707,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799956",
    "postTime": "2024-10-10 07:45:55",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142799924,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799924",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 439,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799924",
    "postTime": "2024-10-10 07:45:51",
    "diggCount": 13,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142799912,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799912",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 518,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799912",
    "postTime": "2024-10-10 00:47:37",
    "diggCount": 20,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142799905,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799905",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 736,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799905",
    "postTime": "2024-10-10 00:46:59",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142799892,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799892",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 569,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799892",
    "postTime": "2024-10-10 00:46:53",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142799896,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799896",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 522,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799896",
    "postTime": "2024-10-10 00:46:49",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142799883,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799883",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 832,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799883",
    "postTime": "2024-10-10 00:46:40",
    "diggCount": 21,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142700508,
    "title": "洋钱罐高频编程考题：二叉树的右视图（中等）",
    "description": "要从二叉树的右侧查看并返回节点值，我们可以使用层序遍历（广度优先遍历）来实现。具体来说，我们需要从右侧依次访问每一层的节点，并从每一层的最右侧节点开始返回结果。，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700508",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700508",
    "postTime": "2024-10-04 10:24:08",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b6e4941ea10b490a8db4b67f420a3305.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700502,
    "title": "洋钱罐高频编程考题：二叉搜索树中第 K 小的元素（中等）",
    "description": "小元素，我们可以利用 BST 的中序遍历特性。中序遍历 BST 会以升序方式访问所有节点，因此第。：中序遍历 BST 的结果是一个升序排列的节点值列表。可以使用递归或迭代的方式进行中序遍历。：在遍历过程中，维护一个计数器来记录已经遍历的节点数量，当计数器等于。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第。要查找二叉搜索树（BST）中的第。小的元素就是中序遍历结果中的第。小的元素（从 1 开始计数）。给定一个二叉搜索树的根节点。小的值，你将如何优化算法？时，返回当前节点的值。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700502",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700502",
    "postTime": "2024-10-04 10:23:34",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7be7b92a469348fe9165d76356a1a0fc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700492,
    "title": "洋钱罐高频编程考题：验证二叉搜索树（中等）",
    "description": "根节点的值是 5 ，但是右子节点的值是 4。，判断其是否是一个有效的二叉搜索树。给你一个二叉树的根节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700492",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 409,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700492",
    "postTime": "2024-10-04 10:22:59",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/33d363efcf4c482ab02d62a67441d97d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700485,
    "title": "洋钱罐高频编程考题：将有序数组转换为二叉搜索树（简单）",
    "description": "要将一个升序排列的整数数组转换为一棵平衡二叉搜索树（BST），我们可以利用递归方法构建树。这是因为一个平衡的BST的中序遍历应该是升序排列的，因此我们可以通过递归的方式选择中间的元素作为根节点，递归构建左右子树，从而保持平衡。：由于数组已经是升序排列的，选择中间元素作为根节点可以保证树的高度平衡。[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。排列，请你将其转换为一棵 平衡 二叉搜索树。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700485",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 424,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700485",
    "postTime": "2024-10-04 10:22:28",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f674c50e28b4432a9ebe786a773e0764.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700478,
    "title": "洋钱罐高频编程考题：二叉树的层序遍历（中等）",
    "description": "层序遍历（二叉树的宽度优先遍历）可以使用队列（FIFO）来实现。我们逐层遍历树中的节点，每次处理一层的所有节点，并将它们的子节点加入队列中。（即逐层地，从左到右访问所有节点）。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700478",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 241,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700478",
    "postTime": "2024-10-04 10:21:51",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a728c2c3636420b9248f8fe0400e427.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700472,
    "title": "洋钱罐高频编程考题：二叉树的直径（简单）",
    "description": "要找到二叉树的直径，我们需要找到树中任意两个节点之间的最长路径。：直径是树中两个节点之间最长的路径长度。这个路径可能会经过树的根节点，也可能不会。3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。因此，整体的空间复杂度主要由递归栈的深度决定，对于最坏情况下是。：通过递归计算每个节点的左右子树的深度，返回节点的最大深度。这条路径可能经过也可能不经过根节点。是指树中任意两个节点之间最长路径的。给你一棵二叉树的根节点，返回该树的。由它们之间边数表示。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700472",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700472",
    "postTime": "2024-10-04 10:21:19",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/82d34823cc444d24b5582f303808b59d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700464,
    "title": "洋钱罐高频编程考题：对称二叉树（简单）",
    "description": "要检查一个二叉树是否是轴对称的，我们可以使用递归或迭代的方法。这里提供了两种方法的解题思路和复杂度分析。：可以使用队列来模拟递归检查过程，通过层次遍历来比较每层的节点对称性。：我们需要检查左右子树是否对称。你可以运用递归和迭代两种方法解决这个问题吗？给你一个二叉树的根节点。， 检查它是否轴对称。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 488,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700464",
    "postTime": "2024-10-04 10:20:32",
    "diggCount": 12,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f1d3ad76cc91463f8ff63d44ab93ecfa.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142700458,
    "title": "洋钱罐高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700458",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 416,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700458",
    "postTime": "2024-10-04 10:20:01",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142700453,
    "title": "洋钱罐高频编程考题：二叉树的最大深度（简单）",
    "description": "是指从根节点到最远叶子节点的最长路径上的节点数。递归方法较为简洁直观。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700453",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 185,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700453",
    "postTime": "2024-10-04 10:19:31",
    "diggCount": 6,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caef40e28a5e46a09db40b2d1e1b1cab.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700426,
    "title": "洋钱罐高频编程考题：二叉树的中序遍历（简单）",
    "description": "要实现二叉树的中序遍历，最常见的方式是使用递归。递归算法很简单，你可以通过迭代算法完成吗？迭代方法使用栈来替代递归。给定一个二叉树的根节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700426",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700426",
    "postTime": "2024-10-04 10:17:12",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f3ef3b4a0148408e818b215f1792b710.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700421,
    "title": "洋钱罐高频编程考题：LRU 缓存（中等）",
    "description": "/ 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.put(4, 4);// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}// 缓存是 {1=1, 2=2}要实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，可以使用。// 返回 -1 (未找到)lRUCache.get(1);// 返回 -1 (未找到)lRUCache.put(1, 1);// 缓存是 {1=1}lRUCache.get(1);",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700421",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 527,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700421",
    "postTime": "2024-10-04 10:16:37",
    "diggCount": 23,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c37c6a5ba9734596a43ad012b2d6b2ef.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142700416,
    "title": "洋钱罐高频编程考题：合并 K 个升序链表 （困难）",
    "description": "对于每个节点的插入和删除操作，优先队列的时间复杂度为 O(log k)，其中 k 是链表的数量。总的时间复杂度为 O(N log k)，其中 N 是所有节点的总数。要将多个有序链表合并成一个有序链表，可以使用优先队列（最小堆）来实现，这样能够有效地将多个链表中的最小节点逐步合并，最终形成一个有序的链表。：空间复杂度主要取决于优先队列的存储空间，最坏情况下为 O(k)。请你将所有链表合并到一个升序链表中，返回合并后的链表。给你一个链表数组，每个链表都已经按升序排列。将它们合并到一个有序链表中得到。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700416",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 233,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700416",
    "postTime": "2024-10-04 10:16:06",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/751dafd55ff34389bdf5fe2439f17feb.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700410,
    "title": "洋钱罐高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700410",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 303,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700410",
    "postTime": "2024-10-04 10:15:33",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700399,
    "title": "洋钱罐高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700399",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 546,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700399",
    "postTime": "2024-10-04 10:15:01",
    "diggCount": 13,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700386,
    "title": "洋钱罐高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700386",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700386",
    "postTime": "2024-10-04 10:14:29",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142697258,
    "title": "洋钱罐高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697258",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 349,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697258",
    "postTime": "2024-10-03 22:33:12",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142697250,
    "title": "高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697250",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 371,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697250",
    "postTime": "2024-10-03 22:32:33",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697243,
    "title": "洋钱罐高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697243",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697243",
    "postTime": "2024-10-03 22:31:57",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142697241,
    "title": "洋钱罐高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697241",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 350,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697241",
    "postTime": "2024-10-03 22:31:19",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697233,
    "title": "洋钱罐高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697233",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1030,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697233",
    "postTime": "2024-10-03 22:30:46",
    "diggCount": 13,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142685629,
    "title": "洋钱罐高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685629",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685629",
    "postTime": "2024-10-02 21:41:07",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685623,
    "title": "洋钱罐高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685623",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 219,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685623",
    "postTime": "2024-10-02 21:40:34",
    "diggCount": 8,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685616,
    "title": "洋钱罐高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685616",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 237,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685616",
    "postTime": "2024-10-02 21:40:03",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685610,
    "title": "洋钱罐高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685610",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 314,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685610",
    "postTime": "2024-10-02 21:39:27",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685595,
    "title": "洋钱罐高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685595",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 327,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685595",
    "postTime": "2024-10-02 21:38:39",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142697225,
    "title": "洋钱罐高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697225",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697225",
    "postTime": "2024-10-03 22:30:16",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142697220,
    "title": "洋钱罐高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697220",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1048,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697220",
    "postTime": "2024-10-03 22:29:40",
    "diggCount": 26,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142697212,
    "title": "洋钱罐高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697212",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697212",
    "postTime": "2024-10-03 22:29:07",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697203,
    "title": "洋钱罐高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697203",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 285,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697203",
    "postTime": "2024-10-03 22:28:37",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142697195,
    "title": "洋钱罐高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697195",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 251,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697195",
    "postTime": "2024-10-03 22:28:03",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142697193,
    "title": "洋钱罐高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697193",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 340,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697193",
    "postTime": "2024-10-03 22:27:31",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697184,
    "title": "洋钱罐高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697184",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 133,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697184",
    "postTime": "2024-10-03 22:26:58",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142697178,
    "title": "洋钱罐高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697178",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 416,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697178",
    "postTime": "2024-10-03 22:26:26",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697172,
    "title": "洋钱罐高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697172",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 213,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697172",
    "postTime": "2024-10-03 22:25:50",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142697167,
    "title": "洋钱罐高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697167",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 153,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697167",
    "postTime": "2024-10-03 22:25:13",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142685725,
    "title": "洋钱罐高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685725",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 264,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685725",
    "postTime": "2024-10-02 21:47:16",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142685716,
    "title": "洋钱罐高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685716",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 235,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685716",
    "postTime": "2024-10-02 21:46:40",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685712,
    "title": "洋钱罐高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685712",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 260,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685712",
    "postTime": "2024-10-02 21:46:08",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685693,
    "title": "洋钱罐高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685693",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 391,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685693",
    "postTime": "2024-10-02 21:45:29",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142685684,
    "title": "洋钱罐高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685684",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 246,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685684",
    "postTime": "2024-10-02 21:44:52",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685673,
    "title": "洋钱罐高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685673",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685673",
    "postTime": "2024-10-02 21:44:18",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142685664,
    "title": "洋钱罐高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685664",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 363,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685664",
    "postTime": "2024-10-02 21:43:43",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685659,
    "title": "洋钱罐高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685659",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 237,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685659",
    "postTime": "2024-10-02 21:43:07",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142685649,
    "title": "洋钱罐高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685649",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 220,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685649",
    "postTime": "2024-10-02 21:42:37",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685639,
    "title": "洋钱罐高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685639",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 248,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685639",
    "postTime": "2024-10-02 21:42:01",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142934693,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934693",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 537,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934693",
    "postTime": "2024-10-16 08:06:09",
    "diggCount": 20,
    "formatTime": "前天 08:06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142934820,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934820",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 508,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934820",
    "postTime": "2024-10-16 08:06:05",
    "diggCount": 14,
    "formatTime": "前天 08:06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142934844,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934844",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 663,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934844",
    "postTime": "2024-10-16 08:06:01",
    "diggCount": 6,
    "formatTime": "前天 08:06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142934754,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934754",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 730,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934754",
    "postTime": "2024-10-16 08:05:57",
    "diggCount": 10,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142934843,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934843",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 461,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934843",
    "postTime": "2024-10-16 08:05:54",
    "diggCount": 17,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142934788,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934788",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 444,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934788",
    "postTime": "2024-10-16 08:05:50",
    "diggCount": 14,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142934723,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934723",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 760,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934723",
    "postTime": "2024-10-16 08:05:46",
    "diggCount": 15,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142934789,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934789",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 798,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934789",
    "postTime": "2024-10-16 08:05:43",
    "diggCount": 11,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142934722,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934722",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 768,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934722",
    "postTime": "2024-10-16 08:05:39",
    "diggCount": 8,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142934662,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934662",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 565,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934662",
    "postTime": "2024-10-16 08:05:34",
    "diggCount": 11,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142934663,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934663",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 599,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934663",
    "postTime": "2024-10-16 08:05:30",
    "diggCount": 21,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142934638,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934638",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 623,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934638",
    "postTime": "2024-10-16 08:05:26",
    "diggCount": 18,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142934607,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934607",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 878,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934607",
    "postTime": "2024-10-16 08:05:21",
    "diggCount": 12,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142934582,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934582",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 610,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934582",
    "postTime": "2024-10-16 08:05:08",
    "diggCount": 20,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142934554,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934554",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 515,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934554",
    "postTime": "2024-10-16 08:05:03",
    "diggCount": 10,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142897240,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897240",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 365,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897240",
    "postTime": "2024-10-13 13:26:52",
    "diggCount": 11,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897212,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897212",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897212",
    "postTime": "2024-10-13 13:26:49",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897189,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897189",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 263,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897189",
    "postTime": "2024-10-13 13:26:47",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897180,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897180",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 272,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897180",
    "postTime": "2024-10-13 13:26:44",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897220,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897220",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 353,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897220",
    "postTime": "2024-10-13 13:26:42",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142897200,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897200",
    "postTime": "2024-10-13 13:26:40",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142897199,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897199",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 241,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897199",
    "postTime": "2024-10-13 13:26:37",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897162,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897162",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897162",
    "postTime": "2024-10-13 13:26:35",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897163,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897163",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 206,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897163",
    "postTime": "2024-10-13 13:26:32",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897149,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897149",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 389,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897149",
    "postTime": "2024-10-13 13:26:30",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142897135,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897135",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 261,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897135",
    "postTime": "2024-10-13 13:26:27",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142897124,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897124",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 274,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897124",
    "postTime": "2024-10-13 13:26:25",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897125,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897125",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 332,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897125",
    "postTime": "2024-10-13 13:26:22",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142897113,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897113",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 229,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897113",
    "postTime": "2024-10-13 13:26:18",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897255,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897255",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897255",
    "postTime": "2024-10-13 13:26:15",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142877650,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877650",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 153,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877650",
    "postTime": "2024-10-12 14:59:20",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877607,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877607",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 195,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877607",
    "postTime": "2024-10-12 14:59:15",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877578,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877578",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 174,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877578",
    "postTime": "2024-10-12 14:59:11",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877874,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877874",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 227,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877874",
    "postTime": "2024-10-12 14:59:08",
    "diggCount": 8,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877813,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877813",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 180,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877813",
    "postTime": "2024-10-12 14:59:05",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877840,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877840",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 103,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877840",
    "postTime": "2024-10-12 14:59:02",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877839,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877839",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 108,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877839",
    "postTime": "2024-10-12 14:59:00",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877841,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877841",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 131,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877841",
    "postTime": "2024-10-12 14:58:57",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877661,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877661",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 173,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877661",
    "postTime": "2024-10-12 14:58:54",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877630,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877630",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877630",
    "postTime": "2024-10-12 14:58:51",
    "diggCount": 7,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877595,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877595",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 191,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877595",
    "postTime": "2024-10-12 14:58:49",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877734,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877734",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 144,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877734",
    "postTime": "2024-10-12 14:58:44",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877695,
    "title": "FairSync extends Sync 线程抢锁分析3​直接代码中分析",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3​直接代码中分析。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877695",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 124,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877695",
    "postTime": "2024-10-12 14:58:40",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878324,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142878324",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 129,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878324",
    "postTime": "2024-10-12 14:58:37",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877556,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877556",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 178,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877556",
    "postTime": "2024-10-12 14:36:53",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142806553,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806553",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 505,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806553",
    "postTime": "2024-10-10 08:07:51",
    "diggCount": 12,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142806168,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806168",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 441,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806168",
    "postTime": "2024-10-10 08:07:47",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142806394,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806394",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 515,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806394",
    "postTime": "2024-10-10 08:07:43",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142806304,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 592,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806304",
    "postTime": "2024-10-10 08:07:40",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142806660,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806660",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 825,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806660",
    "postTime": "2024-10-10 08:07:36",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142806606,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806606",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 826,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806606",
    "postTime": "2024-10-10 08:07:32",
    "diggCount": 6,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142806485,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806485",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 666,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806485",
    "postTime": "2024-10-10 08:02:02",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142806396,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806396",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806396",
    "postTime": "2024-10-10 08:01:59",
    "diggCount": 15,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142806395,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806395",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 436,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806395",
    "postTime": "2024-10-10 08:01:52",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142806049,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806049",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 662,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806049",
    "postTime": "2024-10-10 08:01:48",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142805960,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142805960",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 664,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142805960",
    "postTime": "2024-10-10 07:56:45",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142805869,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142805869",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 635,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142805869",
    "postTime": "2024-10-10 07:55:38",
    "diggCount": 13,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142805775,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142805775",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 474,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142805775",
    "postTime": "2024-10-10 07:55:35",
    "diggCount": 6,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142805677,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析23",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142805677",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 609,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142805677",
    "postTime": "2024-10-10 07:55:31",
    "diggCount": 21,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142805476,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142805476",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 950,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142805476",
    "postTime": "2024-10-10 07:55:28",
    "diggCount": 12,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142697120,
    "title": "58同城高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697120",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697120",
    "postTime": "2024-10-03 22:20:46",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142697109,
    "title": "58同城高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697109",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 235,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697109",
    "postTime": "2024-10-03 22:20:09",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142697105,
    "title": "58同城高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697105",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697105",
    "postTime": "2024-10-03 22:19:35",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697098,
    "title": "58同城高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697098",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 725,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697098",
    "postTime": "2024-10-03 22:19:01",
    "diggCount": 19,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142697094,
    "title": "58同城高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697094",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 321,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697094",
    "postTime": "2024-10-03 22:18:30",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697084,
    "title": "58同城高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697084",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 660,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697084",
    "postTime": "2024-10-03 22:17:54",
    "diggCount": 15,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142697075,
    "title": "58同城高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697075",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697075",
    "postTime": "2024-10-03 22:17:22",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697068,
    "title": "58同城高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697068",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 286,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697068",
    "postTime": "2024-10-03 22:16:33",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142697059,
    "title": "58同城高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697059",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 312,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697059",
    "postTime": "2024-10-03 22:15:56",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697051,
    "title": "58同城高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697051",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697051",
    "postTime": "2024-10-03 22:15:07",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685539,
    "title": "58同城高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685539",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685539",
    "postTime": "2024-10-02 21:33:24",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685533,
    "title": "58同城高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685533",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 337,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685533",
    "postTime": "2024-10-02 21:32:49",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685525,
    "title": "58同城高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685525",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 143,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685525",
    "postTime": "2024-10-02 21:32:17",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142685516,
    "title": "59同城高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685516",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 165,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685516",
    "postTime": "2024-10-02 21:31:37",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142685505,
    "title": "58同城高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685505",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685505",
    "postTime": "2024-10-02 21:30:46",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142685498,
    "title": "58同城高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685498",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 268,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685498",
    "postTime": "2024-10-02 21:30:02",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142685492,
    "title": "58同城高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685492",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685492",
    "postTime": "2024-10-02 21:29:30",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685486,
    "title": "58同城高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685486",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685486",
    "postTime": "2024-10-02 21:28:59",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685479,
    "title": "58同城高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685479",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 373,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685479",
    "postTime": "2024-10-02 21:28:17",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685470,
    "title": "58同城高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685470",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685470",
    "postTime": "2024-10-02 21:27:12",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685465,
    "title": "58同城高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685465",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 395,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685465",
    "postTime": "2024-10-02 21:26:37",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685459,
    "title": "高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685459",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685459",
    "postTime": "2024-10-02 21:25:59",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685450,
    "title": "58同城高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685450",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685450",
    "postTime": "2024-10-02 21:25:19",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685443,
    "title": "58同城高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685443",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 246,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685443",
    "postTime": "2024-10-02 21:24:41",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685433,
    "title": "58同城高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685433",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 405,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685433",
    "postTime": "2024-10-02 21:23:58",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700667,
    "title": "58同城高频编程考题：二叉树的右视图（中等）",
    "description": "要从二叉树的右侧查看并返回节点值，我们可以使用层序遍历（广度优先遍历）来实现。具体来说，我们需要从右侧依次访问每一层的节点，并从每一层的最右侧节点开始返回结果。，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700667",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 258,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700667",
    "postTime": "2024-10-04 10:35:44",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b6e4941ea10b490a8db4b67f420a3305.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700660,
    "title": "59同城高频编程考题：二叉搜索树中第 K 小的元素（中等）",
    "description": "小元素，我们可以利用 BST 的中序遍历特性。中序遍历 BST 会以升序方式访问所有节点，因此第。：中序遍历 BST 的结果是一个升序排列的节点值列表。可以使用递归或迭代的方式进行中序遍历。：在遍历过程中，维护一个计数器来记录已经遍历的节点数量，当计数器等于。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第。要查找二叉搜索树（BST）中的第。小的元素就是中序遍历结果中的第。小的元素（从 1 开始计数）。给定一个二叉搜索树的根节点。小的值，你将如何优化算法？时，返回当前节点的值。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700660",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 234,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700660",
    "postTime": "2024-10-04 10:35:06",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7be7b92a469348fe9165d76356a1a0fc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142700650,
    "title": "58同城高频编程考题：验证二叉搜索树（中等）",
    "description": "根节点的值是 5 ，但是右子节点的值是 4。，判断其是否是一个有效的二叉搜索树。给你一个二叉树的根节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700650",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700650",
    "postTime": "2024-10-04 10:34:08",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/33d363efcf4c482ab02d62a67441d97d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700643,
    "title": "58同城高频编程考题：将有序数组转换为二叉搜索树（简单）",
    "description": "要将一个升序排列的整数数组转换为一棵平衡二叉搜索树（BST），我们可以利用递归方法构建树。这是因为一个平衡的BST的中序遍历应该是升序排列的，因此我们可以通过递归的方式选择中间的元素作为根节点，递归构建左右子树，从而保持平衡。：由于数组已经是升序排列的，选择中间元素作为根节点可以保证树的高度平衡。[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。排列，请你将其转换为一棵 平衡 二叉搜索树。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700643",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 320,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700643",
    "postTime": "2024-10-04 10:33:35",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f674c50e28b4432a9ebe786a773e0764.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142700633,
    "title": "58同城高频编程考题：二叉树的层序遍历（中等）",
    "description": "层序遍历（二叉树的宽度优先遍历）可以使用队列（FIFO）来实现。我们逐层遍历树中的节点，每次处理一层的所有节点，并将它们的子节点加入队列中。（即逐层地，从左到右访问所有节点）。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700633",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700633",
    "postTime": "2024-10-04 10:32:57",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a728c2c3636420b9248f8fe0400e427.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700628,
    "title": "58同城高频编程考题：二叉树的直径（简单）",
    "description": "要找到二叉树的直径，我们需要找到树中任意两个节点之间的最长路径。：直径是树中两个节点之间最长的路径长度。这个路径可能会经过树的根节点，也可能不会。3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。因此，整体的空间复杂度主要由递归栈的深度决定，对于最坏情况下是。：通过递归计算每个节点的左右子树的深度，返回节点的最大深度。这条路径可能经过也可能不经过根节点。是指树中任意两个节点之间最长路径的。给你一棵二叉树的根节点，返回该树的。由它们之间边数表示。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700628",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 416,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700628",
    "postTime": "2024-10-04 10:32:24",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/82d34823cc444d24b5582f303808b59d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142700604,
    "title": "58同城高频编程考题：对称二叉树（简单）",
    "description": "要检查一个二叉树是否是轴对称的，我们可以使用递归或迭代的方法。这里提供了两种方法的解题思路和复杂度分析。：可以使用队列来模拟递归检查过程，通过层次遍历来比较每层的节点对称性。：我们需要检查左右子树是否对称。你可以运用递归和迭代两种方法解决这个问题吗？给你一个二叉树的根节点。， 检查它是否轴对称。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700604",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 502,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700604",
    "postTime": "2024-10-04 10:30:49",
    "diggCount": 12,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f1d3ad76cc91463f8ff63d44ab93ecfa.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142700595,
    "title": "洋钱罐高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700595",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700595",
    "postTime": "2024-10-04 10:30:14",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142700584,
    "title": "58同城高频编程考题：二叉树的最大深度（简单）",
    "description": "是指从根节点到最远叶子节点的最长路径上的节点数。递归方法较为简洁直观。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700584",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700584",
    "postTime": "2024-10-04 10:29:44",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caef40e28a5e46a09db40b2d1e1b1cab.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142700576,
    "title": "58同城高频编程考题：二叉树的中序遍历（简单）",
    "description": "要实现二叉树的中序遍历，最常见的方式是使用递归。递归算法很简单，你可以通过迭代算法完成吗？迭代方法使用栈来替代递归。给定一个二叉树的根节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700576",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 336,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700576",
    "postTime": "2024-10-04 10:29:09",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f3ef3b4a0148408e818b215f1792b710.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700565,
    "title": "58同城高频编程考题：LRU 缓存（中等）",
    "description": "/ 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.put(4, 4);// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}// 缓存是 {1=1, 2=2}要实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，可以使用。// 返回 -1 (未找到)lRUCache.get(1);// 返回 -1 (未找到)lRUCache.put(1, 1);// 缓存是 {1=1}lRUCache.get(1);",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700565",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 628,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700565",
    "postTime": "2024-10-04 10:28:34",
    "diggCount": 23,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c37c6a5ba9734596a43ad012b2d6b2ef.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700560,
    "title": "58同城高频编程考题：合并 K 个升序链表 （困难）",
    "description": "对于每个节点的插入和删除操作，优先队列的时间复杂度为 O(log k)，其中 k 是链表的数量。总的时间复杂度为 O(N log k)，其中 N 是所有节点的总数。要将多个有序链表合并成一个有序链表，可以使用优先队列（最小堆）来实现，这样能够有效地将多个链表中的最小节点逐步合并，最终形成一个有序的链表。：空间复杂度主要取决于优先队列的存储空间，最坏情况下为 O(k)。请你将所有链表合并到一个升序链表中，返回合并后的链表。给你一个链表数组，每个链表都已经按升序排列。将它们合并到一个有序链表中得到。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700560",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 408,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700560",
    "postTime": "2024-10-04 10:28:03",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/751dafd55ff34389bdf5fe2439f17feb.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700555,
    "title": "58同城高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700555",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 313,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700555",
    "postTime": "2024-10-04 10:27:32",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700549,
    "title": "58同城高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700549",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 462,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700549",
    "postTime": "2024-10-04 10:27:01",
    "diggCount": 19,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142700540,
    "title": "58同城高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700540",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700540",
    "postTime": "2024-10-04 10:26:27",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697155,
    "title": "58同城高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697155",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 258,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697155",
    "postTime": "2024-10-03 22:23:30",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142697147,
    "title": "58同城高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697147",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 164,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697147",
    "postTime": "2024-10-03 22:22:56",
    "diggCount": 10,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142697142,
    "title": "58同城高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697142",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 234,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697142",
    "postTime": "2024-10-03 22:22:25",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142697134,
    "title": "58同城高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697134",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 177,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697134",
    "postTime": "2024-10-03 22:21:50",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697125,
    "title": "58同城高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697125",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697125",
    "postTime": "2024-10-03 22:21:16",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142993388,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993388",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 784,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993388",
    "postTime": "2024-10-16 22:35:13",
    "diggCount": 9,
    "formatTime": "前天 22:35",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142993258,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993258",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 535,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993258",
    "postTime": "2024-10-16 22:34:31",
    "diggCount": 15,
    "formatTime": "前天 22:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142993369,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993369",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 611,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993369",
    "postTime": "2024-10-16 22:34:27",
    "diggCount": 16,
    "formatTime": "前天 22:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142993358,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993358",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 481,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993358",
    "postTime": "2024-10-16 22:33:51",
    "diggCount": 11,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142993328,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993328",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 353,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993328",
    "postTime": "2024-10-16 22:33:46",
    "diggCount": 18,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142993273,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993273",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 549,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993273",
    "postTime": "2024-10-16 22:33:43",
    "diggCount": 6,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142993291,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993291",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 370,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993291",
    "postTime": "2024-10-16 22:33:40",
    "diggCount": 19,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142993309,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993309",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 564,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993309",
    "postTime": "2024-10-16 22:33:36",
    "diggCount": 9,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142993233,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993233",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 688,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993233",
    "postTime": "2024-10-16 22:33:19",
    "diggCount": 10,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142993343,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993343",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 625,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993343",
    "postTime": "2024-10-16 22:33:15",
    "diggCount": 19,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142993214,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993214",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 704,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993214",
    "postTime": "2024-10-16 22:29:21",
    "diggCount": 15,
    "formatTime": "前天 22:29",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142993167,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993167",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 589,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993167",
    "postTime": "2024-10-16 22:28:17",
    "diggCount": 14,
    "formatTime": "前天 22:28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142993192,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993192",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 566,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993192",
    "postTime": "2024-10-16 22:28:13",
    "diggCount": 7,
    "formatTime": "前天 22:28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142993144,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993144",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 422,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993144",
    "postTime": "2024-10-16 22:28:09",
    "diggCount": 17,
    "formatTime": "前天 22:28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142993129,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993129",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 439,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993129",
    "postTime": "2024-10-16 22:28:04",
    "diggCount": 9,
    "formatTime": "前天 22:28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142897437,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897437",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897437",
    "postTime": "2024-10-13 13:52:20",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142897490,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897490",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 277,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897490",
    "postTime": "2024-10-13 13:52:17",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897478,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897478",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 261,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897478",
    "postTime": "2024-10-13 13:52:13",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897465,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897465",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 231,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897465",
    "postTime": "2024-10-13 13:52:10",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897454,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897454",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 302,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897454",
    "postTime": "2024-10-13 13:52:04",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897505,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897505",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 306,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897505",
    "postTime": "2024-10-13 13:52:01",
    "diggCount": 10,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897491,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897491",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897491",
    "postTime": "2024-10-13 13:51:58",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897447,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897447",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897447",
    "postTime": "2024-10-13 13:51:55",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897495,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897495",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897495",
    "postTime": "2024-10-13 13:51:53",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897466,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897466",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 365,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897466",
    "postTime": "2024-10-13 13:51:50",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142897419,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897419",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897419",
    "postTime": "2024-10-13 13:51:47",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897426,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897426",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897426",
    "postTime": "2024-10-13 13:51:44",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142897411,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897411",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 352,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897411",
    "postTime": "2024-10-13 13:51:41",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897398,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897398",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 384,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897398",
    "postTime": "2024-10-13 13:51:37",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142897374,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897374",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 204,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897374",
    "postTime": "2024-10-13 13:51:33",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142878529,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878529",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 156,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878529",
    "postTime": "2024-10-12 15:23:55",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878495,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878495",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 202,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878495",
    "postTime": "2024-10-12 15:23:52",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878657,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878657",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 171,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878657",
    "postTime": "2024-10-12 15:23:50",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878685,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878685",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 143,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878685",
    "postTime": "2024-10-12 15:23:47",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878716,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878716",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 86,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878716",
    "postTime": "2024-10-12 15:23:45",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878659,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878659",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 113,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878659",
    "postTime": "2024-10-12 15:23:42",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878624,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878624",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 112,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878624",
    "postTime": "2024-10-12 15:23:40",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878658,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 192,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878658",
    "postTime": "2024-10-12 15:23:38",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878583,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878583",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 327,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878583",
    "postTime": "2024-10-12 15:23:31",
    "diggCount": 9,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878545,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878545",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 103,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878545",
    "postTime": "2024-10-12 15:23:28",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878511,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878511",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 205,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878511",
    "postTime": "2024-10-12 15:23:25",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878478,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878478",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 51,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878478",
    "postTime": "2024-10-12 15:23:23",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142879153,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142879153",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 182,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142879153",
    "postTime": "2024-10-12 15:23:20",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878451,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878451",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 169,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878451",
    "postTime": "2024-10-12 15:03:21",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878468,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878468",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 93,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878468",
    "postTime": "2024-10-12 15:03:12",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142808655,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808655",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 650,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808655",
    "postTime": "2024-10-10 08:30:36",
    "diggCount": 12,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142808461,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808461",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 651,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808461",
    "postTime": "2024-10-10 08:30:33",
    "diggCount": 6,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142808073,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808073",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 823,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808073",
    "postTime": "2024-10-10 08:30:30",
    "diggCount": 13,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142807980,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807980",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 842,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807980",
    "postTime": "2024-10-10 08:30:27",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142808560,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808560",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 920,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808560",
    "postTime": "2024-10-10 08:30:25",
    "diggCount": 22,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142808756,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808756",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 734,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808756",
    "postTime": "2024-10-10 08:30:22",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142808168,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808168",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 663,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808168",
    "postTime": "2024-10-10 08:30:19",
    "diggCount": 20,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142808268,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808268",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 702,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808268",
    "postTime": "2024-10-10 08:30:03",
    "diggCount": 5,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142808559,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808559",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 881,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808559",
    "postTime": "2024-10-10 08:30:00",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142808334,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808334",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 914,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808334",
    "postTime": "2024-10-10 08:29:57",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142807829,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807829",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 825,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807829",
    "postTime": "2024-10-10 08:20:48",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142807733,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807733",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 429,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807733",
    "postTime": "2024-10-10 08:20:45",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142807632,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807632",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 788,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807632",
    "postTime": "2024-10-10 08:20:42",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142807535,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807535",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 952,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807535",
    "postTime": "2024-10-10 08:20:38",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142807428,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807428",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 828,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807428",
    "postTime": "2024-10-10 08:20:33",
    "diggCount": 29,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700817,
    "title": "抖音高频编程考题：二叉树的右视图（中等）",
    "description": "要从二叉树的右侧查看并返回节点值，我们可以使用层序遍历（广度优先遍历）来实现。具体来说，我们需要从右侧依次访问每一层的节点，并从每一层的最右侧节点开始返回结果。，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700817",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 409,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700817",
    "postTime": "2024-10-04 10:47:45",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b6e4941ea10b490a8db4b67f420a3305.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142700810,
    "title": "抖音高频编程考题：二叉搜索树中第 K 小的元素（中等）",
    "description": "小元素，我们可以利用 BST 的中序遍历特性。中序遍历 BST 会以升序方式访问所有节点，因此第。：中序遍历 BST 的结果是一个升序排列的节点值列表。可以使用递归或迭代的方式进行中序遍历。：在遍历过程中，维护一个计数器来记录已经遍历的节点数量，当计数器等于。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第。要查找二叉搜索树（BST）中的第。小的元素就是中序遍历结果中的第。小的元素（从 1 开始计数）。给定一个二叉搜索树的根节点。小的值，你将如何优化算法？时，返回当前节点的值。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700810",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700810",
    "postTime": "2024-10-04 10:47:11",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7be7b92a469348fe9165d76356a1a0fc.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700791,
    "title": "抖音高频编程考题：验证二叉搜索树（中等）",
    "description": "根节点的值是 5 ，但是右子节点的值是 4。，判断其是否是一个有效的二叉搜索树。给你一个二叉树的根节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700791",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 274,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700791",
    "postTime": "2024-10-04 10:45:49",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/33d363efcf4c482ab02d62a67441d97d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700773,
    "title": "抖音高频编程考题：将有序数组转换为二叉搜索树（简单）",
    "description": "要将一个升序排列的整数数组转换为一棵平衡二叉搜索树（BST），我们可以利用递归方法构建树。这是因为一个平衡的BST的中序遍历应该是升序排列的，因此我们可以通过递归的方式选择中间的元素作为根节点，递归构建左右子树，从而保持平衡。：由于数组已经是升序排列的，选择中间元素作为根节点可以保证树的高度平衡。[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。排列，请你将其转换为一棵 平衡 二叉搜索树。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700773",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 431,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700773",
    "postTime": "2024-10-04 10:44:01",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f674c50e28b4432a9ebe786a773e0764.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700763,
    "title": "抖音高频编程考题：二叉树的层序遍历（中等）",
    "description": "层序遍历（二叉树的宽度优先遍历）可以使用队列（FIFO）来实现。我们逐层遍历树中的节点，每次处理一层的所有节点，并将它们的子节点加入队列中。（即逐层地，从左到右访问所有节点）。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700763",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700763",
    "postTime": "2024-10-04 10:43:26",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a728c2c3636420b9248f8fe0400e427.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700756,
    "title": "抖音高频编程考题：对称二叉树（简单）",
    "description": "要检查一个二叉树是否是轴对称的，我们可以使用递归或迭代的方法。这里提供了两种方法的解题思路和复杂度分析。：可以使用队列来模拟递归检查过程，通过层次遍历来比较每层的节点对称性。：我们需要检查左右子树是否对称。你可以运用递归和迭代两种方法解决这个问题吗？给你一个二叉树的根节点。， 检查它是否轴对称。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700756",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 825,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700756",
    "postTime": "2024-10-04 10:42:55",
    "diggCount": 13,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f1d3ad76cc91463f8ff63d44ab93ecfa.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700748,
    "title": "抖音高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700748",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 406,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700748",
    "postTime": "2024-10-04 10:42:21",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142700742,
    "title": "抖音高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700742",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 394,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700742",
    "postTime": "2024-10-04 10:41:50",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700738,
    "title": "抖音高频编程考题：二叉树的最大深度（简单）",
    "description": "是指从根节点到最远叶子节点的最长路径上的节点数。递归方法较为简洁直观。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700738",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 273,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700738",
    "postTime": "2024-10-04 10:41:18",
    "diggCount": 9,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caef40e28a5e46a09db40b2d1e1b1cab.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142700732,
    "title": "抖音高频编程考题：二叉树的中序遍历（简单）",
    "description": "要实现二叉树的中序遍历，最常见的方式是使用递归。递归算法很简单，你可以通过迭代算法完成吗？迭代方法使用栈来替代递归。给定一个二叉树的根节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700732",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 414,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700732",
    "postTime": "2024-10-04 10:40:41",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f3ef3b4a0148408e818b215f1792b710.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700721,
    "title": "抖音​高频编程考题：LRU 缓存（中等）",
    "description": "/ 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.put(4, 4);// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}// 缓存是 {1=1, 2=2}要实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，可以使用。// 返回 -1 (未找到)lRUCache.get(1);// 返回 -1 (未找到)lRUCache.put(1, 1);// 缓存是 {1=1}lRUCache.get(1);",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700721",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 869,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700721",
    "postTime": "2024-10-04 10:39:56",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c37c6a5ba9734596a43ad012b2d6b2ef.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142700711,
    "title": "抖音高频编程考题：合并 K 个升序链表 （困难）",
    "description": "对于每个节点的插入和删除操作，优先队列的时间复杂度为 O(log k)，其中 k 是链表的数量。总的时间复杂度为 O(N log k)，其中 N 是所有节点的总数。要将多个有序链表合并成一个有序链表，可以使用优先队列（最小堆）来实现，这样能够有效地将多个链表中的最小节点逐步合并，最终形成一个有序的链表。：空间复杂度主要取决于优先队列的存储空间，最坏情况下为 O(k)。请你将所有链表合并到一个升序链表中，返回合并后的链表。给你一个链表数组，每个链表都已经按升序排列。将它们合并到一个有序链表中得到。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700711",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 357,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700711",
    "postTime": "2024-10-04 10:39:12",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/751dafd55ff34389bdf5fe2439f17feb.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700702,
    "title": "抖音高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700702",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 437,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700702",
    "postTime": "2024-10-04 10:38:37",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700694,
    "title": "抖音高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700694",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 838,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700694",
    "postTime": "2024-10-04 10:38:03",
    "diggCount": 11,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700687,
    "title": "抖音高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700687",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700687",
    "postTime": "2024-10-04 10:37:26",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697001,
    "title": "抖音高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142697001",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697001",
    "postTime": "2024-10-03 22:10:24",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142696994,
    "title": "抖音高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696994",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696994",
    "postTime": "2024-10-03 22:09:47",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696989,
    "title": "抖音高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696989",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696989",
    "postTime": "2024-10-03 22:09:15",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696930,
    "title": "抖音高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696930",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 436,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696930",
    "postTime": "2024-10-03 22:03:21",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696923,
    "title": "抖音高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696923",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 590,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696923",
    "postTime": "2024-10-03 22:02:47",
    "diggCount": 23,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142696916,
    "title": "抖音高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696916",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696916",
    "postTime": "2024-10-03 22:02:14",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696911,
    "title": "抖音高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696911",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 773,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696911",
    "postTime": "2024-10-03 22:01:43",
    "diggCount": 28,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142696905,
    "title": "抖音高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696905",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 351,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696905",
    "postTime": "2024-10-03 22:01:11",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696899,
    "title": "抖音高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696899",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 166,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696899",
    "postTime": "2024-10-03 22:00:41",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142696889,
    "title": "抖音高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696889",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 409,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696889",
    "postTime": "2024-10-03 22:00:05",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142696884,
    "title": "抖音高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696884",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 384,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696884",
    "postTime": "2024-10-03 21:59:32",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696878,
    "title": "抖音高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696878",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 125,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696878",
    "postTime": "2024-10-03 21:58:58",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142696871,
    "title": "抖音高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696871",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 334,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696871",
    "postTime": "2024-10-03 21:58:22",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142696862,
    "title": "抖音高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696862",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696862",
    "postTime": "2024-10-03 21:57:46",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696852,
    "title": "抖音高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696852",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 166,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696852",
    "postTime": "2024-10-03 21:57:12",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142685370,
    "title": "抖音高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685370",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 332,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685370",
    "postTime": "2024-10-02 21:18:11",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685361,
    "title": "抖音高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685361",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685361",
    "postTime": "2024-10-02 21:17:35",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685352,
    "title": "抖音高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685352",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 230,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685352",
    "postTime": "2024-10-02 21:16:56",
    "diggCount": 8,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142685340,
    "title": "抖音高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685340",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 154,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685340",
    "postTime": "2024-10-02 21:16:25",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142685331,
    "title": "高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685331",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 251,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685331",
    "postTime": "2024-10-02 21:15:49",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685323,
    "title": "抖音高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685323",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 352,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685323",
    "postTime": "2024-10-02 21:15:17",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685318,
    "title": "抖音高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685318",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685318",
    "postTime": "2024-10-02 21:14:45",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685304,
    "title": "抖音高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 351,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685304",
    "postTime": "2024-10-02 21:14:13",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685299,
    "title": "抖音高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685299",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 269,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685299",
    "postTime": "2024-10-02 21:13:39",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685288,
    "title": "抖音高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685288",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 384,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685288",
    "postTime": "2024-10-02 21:13:06",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142685279,
    "title": "抖音高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685279",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685279",
    "postTime": "2024-10-02 21:12:27",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142685270,
    "title": "抖音高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685270",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 279,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685270",
    "postTime": "2024-10-02 21:11:49",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685261,
    "title": "抖音高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685261",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 436,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685261",
    "postTime": "2024-10-02 21:11:15",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685253,
    "title": "抖音高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685253",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685253",
    "postTime": "2024-10-02 21:10:38",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685243,
    "title": "抖音高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685243",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 321,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685243",
    "postTime": "2024-10-02 21:10:01",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 5
  }
]
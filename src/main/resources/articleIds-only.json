[
  {
    "articleId": 142623625,
    "title": "SpringBoot 服务性能优化15",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 750,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623625",
    "postTime": "2024-09-28 23:07:46",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142623621,
    "title": "SpringBoot 服务性能优化14",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623621",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 912,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623621",
    "postTime": "2024-09-28 23:07:06",
    "diggCount": 20,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142623609,
    "title": "SpringBoot 服务性能优化11",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623609",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 747,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623609",
    "postTime": "2024-09-28 23:06:19",
    "diggCount": 13,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142623600,
    "title": "SpringBoot 服务性能优化10",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623600",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 870,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623600",
    "postTime": "2024-09-28 23:05:41",
    "diggCount": 27,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142623589,
    "title": "SpringBoot 服务性能优化13",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623589",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 791,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623589",
    "postTime": "2024-09-28 23:05:34",
    "diggCount": 21,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142623572,
    "title": "SpringBoot 服务性能优化12",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623572",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 943,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623572",
    "postTime": "2024-09-28 23:05:29",
    "diggCount": 28,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142623592,
    "title": "SpringBoot 服务性能优化9",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623592",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 570,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623592",
    "postTime": "2024-09-28 23:04:54",
    "diggCount": 26,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142623581,
    "title": "SpringBoot 服务性能优化8",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623581",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 881,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623581",
    "postTime": "2024-09-28 23:03:47",
    "diggCount": 22,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142623551,
    "title": "SpringBoot 服务性能优化7",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623551",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 603,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623551",
    "postTime": "2024-09-28 23:03:02",
    "diggCount": 14,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142623538,
    "title": "SpringBoot 服务性能优化6",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623538",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 856,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623538",
    "postTime": "2024-09-28 23:02:57",
    "diggCount": 22,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142623522,
    "title": "SpringBoot 服务性能优化5",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623522",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 981,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623522",
    "postTime": "2024-09-28 23:02:54",
    "diggCount": 12,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142623509,
    "title": "SpringBoot 服务性能优化4",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 928,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623509",
    "postTime": "2024-09-28 23:02:50",
    "diggCount": 12,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c5dece5567a84cf0942e4c1ed7b93e89.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142623562,
    "title": "SpringBoot 服务性能优化3",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623562",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 515,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623562",
    "postTime": "2024-09-28 23:02:46",
    "diggCount": 14,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142623516,
    "title": "SpringBoot 服务性能优化2",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623516",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 591,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623516",
    "postTime": "2024-09-28 23:01:12",
    "diggCount": 23,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142623500,
    "title": "SpringBoot 服务性能优化1",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142623500",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 725,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623500",
    "postTime": "2024-09-28 23:01:08",
    "diggCount": 30,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142029042,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029042",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1031,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029042",
    "postTime": "2024-09-08 16:38:26",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142029082,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029082",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 903,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029082",
    "postTime": "2024-09-08 16:38:19",
    "diggCount": 13,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142029065,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029065",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 980,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029065",
    "postTime": "2024-09-08 16:37:29",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142029030,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029030",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 761,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029030",
    "postTime": "2024-09-08 16:35:59",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142029017,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029017",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029017",
    "postTime": "2024-09-08 16:35:55",
    "diggCount": 32,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142028980,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028980",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 715,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028980",
    "postTime": "2024-09-08 16:34:59",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142028928,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028928",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 765,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028928",
    "postTime": "2024-09-08 16:34:56",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142029006,
    "title": "【无标题】案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142029006",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 735,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029006",
    "postTime": "2024-09-08 16:34:50",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142028950,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028950",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 872,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028950",
    "postTime": "2024-09-08 16:34:46",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142028911,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028911",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 796,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028911",
    "postTime": "2024-09-08 16:34:41",
    "diggCount": 11,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142028887,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028887",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 970,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028887",
    "postTime": "2024-09-08 16:34:37",
    "diggCount": 21,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142028861,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028861",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 876,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028861",
    "postTime": "2024-09-08 16:34:33",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142028990,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028990",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 698,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028990",
    "postTime": "2024-09-08 16:34:15",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142028967,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028967",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 711,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028967",
    "postTime": "2024-09-08 16:33:11",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142028919,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/142028919",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 787,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028919",
    "postTime": "2024-09-08 16:31:09",
    "diggCount": 10,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 141966709,
    "title": "超越常规：斐波那契数列的极速计算技术12",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966709",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 570,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966709",
    "postTime": "2024-09-06 18:28:10",
    "diggCount": 12,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b78200db214141e495f3ef8e45375a3a.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141966698,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966698",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 698,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966698",
    "postTime": "2024-09-06 18:27:39",
    "diggCount": 20,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141966682,
    "title": "超越常规：斐波那契数列的极速计算技术11",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966682",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 496,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966682",
    "postTime": "2024-09-06 18:27:05",
    "diggCount": 15,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141966674,
    "title": "超越常规：斐波那契数列的极速计算技术13",
    "description": "这个问题导致了斐波那契数列的产生，兔子的对数就对应了斐波那契数列的每一项。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966674",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 970,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966674",
    "postTime": "2024-09-06 18:26:30",
    "diggCount": 29,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141966662,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966662",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 802,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966662",
    "postTime": "2024-09-06 18:25:56",
    "diggCount": 17,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141966647,
    "title": "超越常规：斐波那契数列的极速计算技术8",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966647",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 889,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966647",
    "postTime": "2024-09-06 18:25:49",
    "diggCount": 5,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141966633,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966633",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 689,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966633",
    "postTime": "2024-09-06 18:25:40",
    "diggCount": 8,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141966615,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966615",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 501,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966615",
    "postTime": "2024-09-06 18:25:29",
    "diggCount": 24,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141966594,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966594",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 680,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966594",
    "postTime": "2024-09-06 18:25:24",
    "diggCount": 18,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141966579,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966579",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 520,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966579",
    "postTime": "2024-09-06 18:22:36",
    "diggCount": 16,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141966602,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966602",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 760,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966602",
    "postTime": "2024-09-06 18:22:20",
    "diggCount": 23,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141966555,
    "title": "超越常规：斐波那契数列的极速计算技术14",
    "description": "这个问题导致了斐波那契数列的产生，兔子的对数就对应了斐波那契数列的每一项。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966555",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1023,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966555",
    "postTime": "2024-09-06 18:21:27",
    "diggCount": 30,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141966570,
    "title": "超越常规：斐波那契数列的极速计算技术15",
    "description": "这个问题导致了斐波那契数列的产生，兔子的对数就对应了斐波那契数列的每一项。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966570",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 765,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966570",
    "postTime": "2024-09-06 18:21:22",
    "diggCount": 23,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 141966562,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966562",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 653,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966562",
    "postTime": "2024-09-06 18:21:02",
    "diggCount": 25,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141966545,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141966545",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 517,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966545",
    "postTime": "2024-09-06 18:19:56",
    "diggCount": 15,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141934104,
    "title": "案例分析：大对象复用的目标和注意点15",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141934104",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 438,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934104",
    "postTime": "2024-09-05 16:14:34",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141934082,
    "title": "案例分析：大对象复用的目标和注意点14",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141934082",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 852,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934082",
    "postTime": "2024-09-05 16:13:59",
    "diggCount": 26,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141934061,
    "title": "案例分析：大对象复用的目标和注意点13",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141934061",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 490,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934061",
    "postTime": "2024-09-05 16:13:24",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141934044,
    "title": "案例分析：大对象复用的目标和注意点12",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141934044",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1084,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934044",
    "postTime": "2024-09-05 16:12:52",
    "diggCount": 29,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141933981,
    "title": "案例分析：大对象复用的目标和注意点11",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933981",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 365,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933981",
    "postTime": "2024-09-05 16:11:23",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141933949,
    "title": "案例分析：大对象复用的目标和注意点10",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933949",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 427,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933949",
    "postTime": "2024-09-05 16:10:47",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141933921,
    "title": "案例分析：大对象复用的目标和注意点9",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933921",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933921",
    "postTime": "2024-09-05 16:10:16",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141933901,
    "title": "案例分析：大对象复用的目标和注意点8",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933901",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933901",
    "postTime": "2024-09-05 16:09:45",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141933883,
    "title": "案例分析：大对象复用的目标和注意点7",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933883",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 622,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933883",
    "postTime": "2024-09-05 16:09:09",
    "diggCount": 16,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 141933764,
    "title": "案例分析：大对象复用的目标和注意点6",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933764",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 392,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933764",
    "postTime": "2024-09-05 16:05:49",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141933744,
    "title": "案例分析：大对象复用的目标和注意点5",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933744",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1056,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933744",
    "postTime": "2024-09-05 16:05:17",
    "diggCount": 22,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 141933722,
    "title": "案例分析：大对象复用的目标和注意点4",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933722",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 497,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933722",
    "postTime": "2024-09-05 16:04:45",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141933660,
    "title": "案例分析：大对象复用的目标和注意点3",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933660",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 722,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933660",
    "postTime": "2024-09-05 16:03:08",
    "diggCount": 22,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 141933646,
    "title": "案例分析：大对象复用的目标和注意点2",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933646",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 829,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933646",
    "postTime": "2024-09-05 16:02:35",
    "diggCount": 27,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141933560,
    "title": "案例分析：大对象复用的目标和注意点1",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141933560",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 343,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933560",
    "postTime": "2024-09-05 16:00:47",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141888744,
    "title": "攻破工程级复杂缓存难题--企业实战18",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888744",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 865,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888744",
    "postTime": "2024-09-04 11:24:39",
    "diggCount": 7,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141888714,
    "title": "攻破工程级复杂缓存难题--企业实战23",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888714",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 688,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888714",
    "postTime": "2024-09-04 11:23:43",
    "diggCount": 27,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141888604,
    "title": "攻破工程级复杂缓存难题--企业实战21",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888604",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 879,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888604",
    "postTime": "2024-09-04 11:23:35",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141888691,
    "title": "攻破工程级复杂缓存难题--企业实战20",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888691",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 835,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888691",
    "postTime": "2024-09-04 11:23:28",
    "diggCount": 22,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141888646,
    "title": "攻破工程级复杂缓存难题--企业实战24",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888646",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 818,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888646",
    "postTime": "2024-09-04 11:22:20",
    "diggCount": 21,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141888316,
    "title": "攻破工程级复杂缓存难题--企业实战30",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888316",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 942,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888316",
    "postTime": "2024-09-04 11:22:14",
    "diggCount": 11,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141888352,
    "title": "攻破工程级复杂缓存难题--企业实战29",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888352",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 976,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888352",
    "postTime": "2024-09-04 11:22:08",
    "diggCount": 28,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141888382,
    "title": "攻破工程级复杂缓存难题--企业实战28",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888382",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 525,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888382",
    "postTime": "2024-09-04 11:22:03",
    "diggCount": 11,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141888468,
    "title": "攻破工程级复杂缓存难题--企业实战27",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888468",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 670,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888468",
    "postTime": "2024-09-04 11:21:58",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141888500,
    "title": "攻破工程级复杂缓存难题--企业实战26",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888500",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 568,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888500",
    "postTime": "2024-09-04 11:21:54",
    "diggCount": 18,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141888428,
    "title": "攻破工程级复杂缓存难题--企业实战25",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888428",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 837,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888428",
    "postTime": "2024-09-04 11:21:49",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141888529,
    "title": "攻破工程级复杂缓存难题--企业实战22",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888529",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 495,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888529",
    "postTime": "2024-09-04 11:21:41",
    "diggCount": 18,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141888572,
    "title": "攻破工程级复杂缓存难题--企业实战19",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888572",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 827,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888572",
    "postTime": "2024-09-04 11:21:31",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141888553,
    "title": "攻破工程级复杂缓存难题--企业实战17",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888553",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 591,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888553",
    "postTime": "2024-09-04 11:19:35",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141888402,
    "title": "攻破工程级复杂缓存难题--企业实战16",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141888402",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 658,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888402",
    "postTime": "2024-09-04 11:15:24",
    "diggCount": 17,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141865187,
    "title": "攻破工程级复杂缓存难题--企业实战15",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865187",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 372,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865187",
    "postTime": "2024-09-03 16:25:19",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141865168,
    "title": "攻破工程级复杂缓存难题--企业实战14",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865168",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 485,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865168",
    "postTime": "2024-09-03 16:24:42",
    "diggCount": 6,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865153,
    "title": "攻破工程级复杂缓存难题--企业实战13",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865153",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 334,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865153",
    "postTime": "2024-09-03 16:24:10",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865125,
    "title": "攻破工程级复杂缓存难题--企业实战12",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865125",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 487,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865125",
    "postTime": "2024-09-03 16:23:16",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865106,
    "title": "攻破工程级复杂缓存难题--企业实战11",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865106",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 361,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865106",
    "postTime": "2024-09-03 16:22:46",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141865081,
    "title": "攻破工程级复杂缓存难题--企业实战10",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865081",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865081",
    "postTime": "2024-09-03 16:22:10",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141865052,
    "title": "攻破工程级复杂缓存难题--企业实战9",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865052",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 361,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865052",
    "postTime": "2024-09-03 16:21:37",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141865034,
    "title": "攻破工程级复杂缓存难题--企业实战8",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865034",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865034",
    "postTime": "2024-09-03 16:21:00",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141865020,
    "title": "攻破工程级复杂缓存难题--企业实战7",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141865020",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 424,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865020",
    "postTime": "2024-09-03 16:20:29",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141864984,
    "title": "攻破工程级复杂缓存难题--企业实战6",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864984",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864984",
    "postTime": "2024-09-03 16:19:28",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141864962,
    "title": "攻破工程级复杂缓存难题--企业实战5",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864962",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864962",
    "postTime": "2024-09-03 16:18:56",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141864926,
    "title": "攻破工程级复杂缓存难题--企业实战4",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864926",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 603,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864926",
    "postTime": "2024-09-03 16:17:44",
    "diggCount": 12,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141864896,
    "title": "攻破工程级复杂缓存难题--企业实战3",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864896",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 388,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864896",
    "postTime": "2024-09-03 16:17:14",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141864847,
    "title": "攻破工程级复杂缓存难题--企业实战2",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864847",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864847",
    "postTime": "2024-09-03 16:15:49",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141864815,
    "title": "攻破工程级复杂缓存难题--企业实战1",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141864815",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864815",
    "postTime": "2024-09-03 16:15:12",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141817502,
    "title": "JMC教程：优化Java应用性能的全流程指南",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817502",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 999,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817502",
    "postTime": "2024-09-02 13:30:14",
    "diggCount": 11,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141817416,
    "title": "JMC应用解析：深度挖掘Java性能数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817416",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 896,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817416",
    "postTime": "2024-09-02 13:25:08",
    "diggCount": 12,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141817398,
    "title": "提高Java应用性能的秘诀：JMC数据挖掘技巧",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817398",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 594,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817398",
    "postTime": "2024-09-02 13:24:21",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141817384,
    "title": "JMC的秘密武器：如何获取并分析Java性能数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817384",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1033,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817384",
    "postTime": "2024-09-02 13:23:41",
    "diggCount": 23,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141817354,
    "title": "JMC助力Java开发者：如何获取并提升应用性能",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817354",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 658,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817354",
    "postTime": "2024-09-02 13:23:24",
    "diggCount": 21,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141817334,
    "title": "轻松掌握Java性能：JMC实战技巧与应用",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817334",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 737,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817334",
    "postTime": "2024-09-02 13:22:55",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141817321,
    "title": "JMC让Java性能数据一目了然：从入门到精通",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817321",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 909,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817321",
    "postTime": "2024-09-02 13:22:31",
    "diggCount": 17,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141817303,
    "title": "Java应用性能优化必备：JMC详解与实战",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817303",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 857,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817303",
    "postTime": "2024-09-02 13:22:04",
    "diggCount": 13,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141817345,
    "title": "通过JMC洞悉Java应用瓶颈：性能数据获取全攻略",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817345",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 924,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817345",
    "postTime": "2024-09-02 13:21:39",
    "diggCount": 16,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141817328,
    "title": "Java性能监控的利器：如何用JMC获取关键数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817328",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 920,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817328",
    "postTime": "2024-09-02 13:20:26",
    "diggCount": 9,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141817310,
    "title": "JMC实战：如何快速获取Java应用的性能数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817310",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 371,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817310",
    "postTime": "2024-09-02 13:19:23",
    "diggCount": 4,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141817242,
    "title": "深入解读JMC：轻松获取Java应用的性能数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817242",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 971,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817242",
    "postTime": "2024-09-02 13:18:54",
    "diggCount": 13,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141817267,
    "title": "JMC揭秘：如何精准监控Java应用性能",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817267",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1387,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817267",
    "postTime": "2024-09-02 13:18:40",
    "diggCount": 26,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141817295,
    "title": "全面掌控Java性能：JMC的最佳实践指南",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817295",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1005,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817295",
    "postTime": "2024-09-02 13:18:20",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141817283,
    "title": "用JMC掌握Java性能：从数据获取到问题定位",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/141817283",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 841,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817283",
    "postTime": "2024-09-02 13:17:53",
    "diggCount": 24,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15beeeaba7514fae87d1902ca5c233e4.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140890686,
    "title": "攻破工程级复杂缓存难题--企业实战",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/140890686",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 776,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140890686",
    "postTime": "2024-08-03 14:56:51",
    "diggCount": 11,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/176ebc03f391488b87eca1087643c7f7.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 140890666,
    "title": "攻破工程级复杂缓存难题--企业实战",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/140890666",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 808,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140890666",
    "postTime": "2024-08-03 14:55:28",
    "diggCount": 24,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c4d66207478f4feba58521200e3aa7d7.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140890651,
    "title": "攻破工程级复杂缓存难题--企业实战",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/140890651",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 435,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140890651",
    "postTime": "2024-08-03 14:54:42",
    "diggCount": 8,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a1d8996538e4e339accb4d42e8e04af.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140890639,
    "title": "攻破工程级复杂缓存难题--企业实战",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/140890639",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 761,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140890639",
    "postTime": "2024-08-03 14:54:13",
    "diggCount": 7,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4f94f8d326bf4e04a12ac612fe676060.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140890627,
    "title": "攻破工程级复杂缓存难题--企业实战",
    "description": "本地缓存适用于频繁访问且少变更的数据，如API信息和业务基础信息，而双缓存方案则通过Tair和Squirrel的组合，实现主备缓存切换和高可用性。然而，缓存系统也面临着诸多挑战，如缓存穿透、缓存雪崩、缓存击穿和热点key问题。分布式缓存通过将数据存储在独立的缓存服务器上，并提供高效的访问接口，极大地提升了数据的访问速度和系统的伸缩性。如果你住的地方附近有便利的超市，随时可以买到新鲜的食物，且你目前的家庭成员不多，消耗量不大，那么大规模囤粮不仅占用储物空间，还可能造成浪费（因为食品有保质期）。",
    "url": "https://blog.csdn.net/2401_86608273/article/details/140890627",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 910,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140890627",
    "postTime": "2024-08-03 14:53:36",
    "diggCount": 17,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92ae7d27e2214a03969e20476ff23efc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142904218,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904218",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 305,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904218",
    "postTime": "2024-10-13 21:00:53",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142904198,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904198",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 276,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904198",
    "postTime": "2024-10-13 20:59:35",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142904022,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904022",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904022",
    "postTime": "2024-10-13 20:59:23",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142904096,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904096",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904096",
    "postTime": "2024-10-13 20:59:20",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142904072,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904072",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 293,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904072",
    "postTime": "2024-10-13 20:59:17",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142904095,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904095",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904095",
    "postTime": "2024-10-13 20:59:14",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142904073,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904073",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 234,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904073",
    "postTime": "2024-10-13 20:59:06",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142904071,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904071",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904071",
    "postTime": "2024-10-13 20:59:04",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142904185,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904185",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 403,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904185",
    "postTime": "2024-10-13 20:59:00",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142904054,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904054",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904054",
    "postTime": "2024-10-13 20:51:24",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142904003,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904003",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904003",
    "postTime": "2024-10-13 20:51:20",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142903970,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903970",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 258,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903970",
    "postTime": "2024-10-13 20:51:17",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142903989,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903989",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 369,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903989",
    "postTime": "2024-10-13 20:51:13",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142903954,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903954",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 300,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903954",
    "postTime": "2024-10-13 20:51:10",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142903935,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903935",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 206,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903935",
    "postTime": "2024-10-13 20:51:07",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142058366,
    "title": "案例分析：并行计算让代码“飞”起来10",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058366",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 704,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058366",
    "postTime": "2024-09-09 14:32:01",
    "diggCount": 19,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142058346,
    "title": "案例分析：并行计算让代码“飞”起来9",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058346",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1206,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058346",
    "postTime": "2024-09-09 14:31:24",
    "diggCount": 30,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142058299,
    "title": "案例分析：并行计算让代码“飞”起来8",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058299",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 750,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058299",
    "postTime": "2024-09-09 14:30:00",
    "diggCount": 21,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142058248,
    "title": "案例分析：并行计算让代码“飞”起来7",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058248",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 822,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058248",
    "postTime": "2024-09-09 14:28:26",
    "diggCount": 7,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142058012,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058012",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 744,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058012",
    "postTime": "2024-09-09 14:21:34",
    "diggCount": 14,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142057981,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057981",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1088,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057981",
    "postTime": "2024-09-09 14:20:52",
    "diggCount": 30,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142057961,
    "title": "案例分析：并行计算让代码“飞”起来5",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057961",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 718,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057961",
    "postTime": "2024-09-09 14:20:21",
    "diggCount": 8,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142057939,
    "title": "案例分析：并行计算让代码“飞”起来4",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057939",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 789,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057939",
    "postTime": "2024-09-09 14:19:45",
    "diggCount": 13,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142057719,
    "title": "案例分析：并行计算让代码“飞”起来3",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057719",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 840,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057719",
    "postTime": "2024-09-09 14:14:07",
    "diggCount": 32,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142057683,
    "title": "案例分析：并行计算让代码“飞”起来2",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057683",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 853,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057683",
    "postTime": "2024-09-09 14:13:34",
    "diggCount": 29,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142057417,
    "title": "案例分析：并行计算让代码“飞”起来1",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057417",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 693,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057417",
    "postTime": "2024-09-09 14:06:38",
    "diggCount": 27,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/911f467a7ab14a9d82eb34c769006364.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142025499,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025499",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 813,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025499",
    "postTime": "2024-09-08 13:27:10",
    "diggCount": 13,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142025490,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025490",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 745,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025490",
    "postTime": "2024-09-08 13:26:26",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142025471,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025471",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 799,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025471",
    "postTime": "2024-09-08 13:25:14",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142025214,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025214",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 934,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025214",
    "postTime": "2024-09-08 13:25:05",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142025190,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025190",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 838,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025190",
    "postTime": "2024-09-08 13:25:01",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142025200,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 939,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025200",
    "postTime": "2024-09-08 13:00:54",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142025174,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025174",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 648,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025174",
    "postTime": "2024-09-08 13:00:41",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142025171,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025171",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1170,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025171",
    "postTime": "2024-09-08 12:59:48",
    "diggCount": 20,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142025159,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025159",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 562,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025159",
    "postTime": "2024-09-08 12:59:41",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142025135,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025135",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 805,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025135",
    "postTime": "2024-09-08 12:55:38",
    "diggCount": 7,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142025128,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025128",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 851,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025128",
    "postTime": "2024-09-08 12:54:01",
    "diggCount": 9,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142025117,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025117",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 857,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025117",
    "postTime": "2024-09-08 12:52:45",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142025102,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025102",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 659,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025102",
    "postTime": "2024-09-08 12:51:21",
    "diggCount": 11,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142025090,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025090",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 843,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025090",
    "postTime": "2024-09-08 12:50:10",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141929018,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory26",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141929018",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 866,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929018",
    "postTime": "2024-09-05 13:49:57",
    "diggCount": 21,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141929000,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory25",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141929000",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 731,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929000",
    "postTime": "2024-09-05 13:49:14",
    "diggCount": 17,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141928982,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory24",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928982",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 236,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928982",
    "postTime": "2024-09-05 13:48:43",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141928966,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory23",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928966",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 708,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928966",
    "postTime": "2024-09-05 13:48:10",
    "diggCount": 20,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141928944,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory22",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928944",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 690,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928944",
    "postTime": "2024-09-05 13:47:35",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141928929,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory21",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928929",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 459,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928929",
    "postTime": "2024-09-05 13:47:01",
    "diggCount": 12,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141928915,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory20",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928915",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 663,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928915",
    "postTime": "2024-09-05 13:46:24",
    "diggCount": 9,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141928906,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory19",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928906",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 480,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928906",
    "postTime": "2024-09-05 13:45:49",
    "diggCount": 21,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141928892,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory18",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928892",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 266,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928892",
    "postTime": "2024-09-05 13:45:14",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141928875,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory17",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 417,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928875",
    "postTime": "2024-09-05 13:44:38",
    "diggCount": 15,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141928857,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory16",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928857",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 910,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928857",
    "postTime": "2024-09-05 13:44:04",
    "diggCount": 18,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141833464,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory15",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 893,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833464",
    "postTime": "2024-09-03 00:26:11",
    "diggCount": 23,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141833463,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory13",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833463",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 462,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833463",
    "postTime": "2024-09-03 00:25:38",
    "diggCount": 21,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141833460,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory14",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833460",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 434,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833460",
    "postTime": "2024-09-03 00:24:47",
    "diggCount": 15,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141833453,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory12",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833453",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 903,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833453",
    "postTime": "2024-09-03 00:24:13",
    "diggCount": 25,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141833449,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory11",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 574,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833449",
    "postTime": "2024-09-03 00:23:39",
    "diggCount": 12,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141833445,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory10",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833445",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 740,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833445",
    "postTime": "2024-09-03 00:23:07",
    "diggCount": 11,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141833437,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory9",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833437",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 863,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833437",
    "postTime": "2024-09-03 00:22:37",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141833434,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory8",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833434",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 473,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833434",
    "postTime": "2024-09-03 00:22:03",
    "diggCount": 16,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141833428,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory7",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833428",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 860,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833428",
    "postTime": "2024-09-03 00:21:32",
    "diggCount": 6,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141818848,
    "title": "超越常规：斐波那契数列的极速计算技术15",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141818848",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 698,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818848",
    "postTime": "2024-09-02 14:22:43",
    "diggCount": 30,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140906698,
    "title": "瞬间完成：斐波那契数列高效计算背后的科学",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906698",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 940,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906698",
    "postTime": "2024-08-04 15:27:27",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd9b924443e24a799fcea73fa1c0d72f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140906681,
    "title": "超越常规：斐波那契数列的极速计算技术",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 721,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906681",
    "postTime": "2024-08-04 15:26:34",
    "diggCount": 23,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140906547,
    "title": "探秘斐波那契数列：如何在0.02毫秒内计算21亿",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906547",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 811,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906547",
    "postTime": "2024-08-04 15:26:08",
    "diggCount": 19,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5cdc602d7d1f4d978df45f6ec95f0d1b.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140906534,
    "title": "秒懂斐波那契：算法优化实现21亿级速度突破",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906534",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 891,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906534",
    "postTime": "2024-08-04 15:25:34",
    "diggCount": 17,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8362df828ff04f0da1ab371fc89315b6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140906659,
    "title": "斐波那契数列的惊人速度：算法优化实战分享",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906659",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 809,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906659",
    "postTime": "2024-08-04 15:25:07",
    "diggCount": 25,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b78200db214141e495f3ef8e45375a3a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140906517,
    "title": "斐波那契数列的极速计算：背后的算法魔法",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906517",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 576,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906517",
    "postTime": "2024-08-04 15:25:00",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/057f9d4eeef843a69a75c97502efdafc.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140906462,
    "title": "极致优化：斐波那契数列的高效算法揭秘",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906462",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 603,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906462",
    "postTime": "2024-08-04 15:24:34",
    "diggCount": 20,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1c1ac94bba7d4103b96c27d2d07aee11.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140906608,
    "title": "从慢到快：斐波那契数列高效计算的奥秘",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906608",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 643,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906608",
    "postTime": "2024-08-04 15:24:04",
    "diggCount": 16,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/cb559b31c6fc4e52be6f7636b45cef72.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140906630,
    "title": "从基础到高效：斐波那契数列计算的算法之旅",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906630",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 397,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906630",
    "postTime": "2024-08-04 15:23:24",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/df4542ac1df9499fbef6b045d9c29d27.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140906588,
    "title": "算法的魔力：斐波那契数列的极速计算揭秘",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906588",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 820,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906588",
    "postTime": "2024-08-04 15:23:05",
    "diggCount": 15,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c020e6a282c4fe1b75c2675e7231117.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140906599,
    "title": "探究斐波那契：从基础算法到高效实现",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906599",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 416,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906599",
    "postTime": "2024-08-04 15:22:12",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7eaf7ba453a54c74a93ff28ef736fd38.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140906525,
    "title": "斐波那契数列的速度革命：高效算法实现之路",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906525",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 597,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906525",
    "postTime": "2024-08-04 15:21:45",
    "diggCount": 9,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ff5943e5562f4da8b83570e866b6e04e.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 140906593,
    "title": "极限性能：21亿斐波那契数列在0.02毫秒内计算完成",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906593",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 592,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906593",
    "postTime": "2024-08-04 15:21:13",
    "diggCount": 21,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b78200db214141e495f3ef8e45375a3a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140906580,
    "title": "斐波那契数列的算法优化：实现超高速计算",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906580",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 461,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906580",
    "postTime": "2024-08-04 15:20:05",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/28057dbe2cd14de7800a18f236bd608a.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140887854,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "一、IOC容器的刷新环节快速回顾public abstract class AbstractApplicationContext implements ApplicationContext {     @Override    public void refresh() throws BeansException, IllegalStateException {        synchronized (this.startupShutdownMonitor) {            ",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887854",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 831,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887854",
    "postTime": "2024-08-03 11:34:51",
    "diggCount": 23,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140887837,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887837",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 818,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887837",
    "postTime": "2024-08-03 11:33:57",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140887813,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887813",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 782,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887813",
    "postTime": "2024-08-03 11:33:40",
    "diggCount": 6,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140887832,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887832",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 607,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887832",
    "postTime": "2024-08-03 11:33:24",
    "diggCount": 18,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140887799,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887799",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 616,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887799",
    "postTime": "2024-08-03 11:31:22",
    "diggCount": 22,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140887790,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887790",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 505,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887790",
    "postTime": "2024-08-03 11:30:49",
    "diggCount": 8,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140887778,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887778",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 901,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887778",
    "postTime": "2024-08-03 11:30:15",
    "diggCount": 14,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140887762,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887762",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 807,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887762",
    "postTime": "2024-08-03 11:29:22",
    "diggCount": 20,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140887745,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887745",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 476,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887745",
    "postTime": "2024-08-03 11:29:11",
    "diggCount": 22,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140887625,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 962,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887625",
    "postTime": "2024-08-03 11:28:04",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140742475,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742475",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 247,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742475",
    "postTime": "2024-07-27 22:36:46",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742484,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742484",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 276,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742484",
    "postTime": "2024-07-27 22:36:33",
    "diggCount": 7,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742523,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742523",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 178,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742523",
    "postTime": "2024-07-27 22:36:18",
    "diggCount": 1,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742536,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742536",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 163,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742536",
    "postTime": "2024-07-27 22:35:59",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742612,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742612",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 377,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742612",
    "postTime": "2024-07-27 22:35:36",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742559,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742559",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742559",
    "postTime": "2024-07-27 22:31:29",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742545,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742545",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742545",
    "postTime": "2024-07-27 22:30:44",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140742509,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 397,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742509",
    "postTime": "2024-07-27 22:27:48",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140742503,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742503",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 216,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742503",
    "postTime": "2024-07-27 22:27:13",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742493,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742493",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 289,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742493",
    "postTime": "2024-07-27 22:26:38",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142896693,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896693",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 141,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896693",
    "postTime": "2024-10-13 12:31:40",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896670,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896670",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 200,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896670",
    "postTime": "2024-10-13 12:29:42",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896628,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896628",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 129,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896628",
    "postTime": "2024-10-13 12:29:28",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896643,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896643",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 118,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896643",
    "postTime": "2024-10-13 12:29:25",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896656,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896656",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 140,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896656",
    "postTime": "2024-10-13 12:29:22",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896655,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896655",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 183,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896655",
    "postTime": "2024-10-13 12:29:18",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896612,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896612",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 162,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896612",
    "postTime": "2024-10-13 12:29:15",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896597,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896597",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 198,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896597",
    "postTime": "2024-10-13 12:29:08",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896663,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896663",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 139,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896663",
    "postTime": "2024-10-13 12:29:05",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896578,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896578",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 160,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896578",
    "postTime": "2024-10-13 12:29:02",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896570,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896570",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 96,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896570",
    "postTime": "2024-10-13 12:28:58",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896558,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896558",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 194,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896558",
    "postTime": "2024-10-13 12:28:55",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896546,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896546",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 190,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896546",
    "postTime": "2024-10-13 12:28:52",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896536,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896536",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 183,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896536",
    "postTime": "2024-10-13 12:28:48",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896527,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142896527",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 133,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896527",
    "postTime": "2024-10-13 12:28:44",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a19ddea45a38484f965716928e6993a4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142623925,
    "title": "SpringBoot 服务性能优化15",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623925",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 997,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623925",
    "postTime": "2024-09-28 23:27:49",
    "diggCount": 19,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142623920,
    "title": "SpringBoot 服务性能优化14",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623920",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 707,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623920",
    "postTime": "2024-09-28 23:27:17",
    "diggCount": 8,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142623900,
    "title": "SpringBoot 服务性能优化13",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623900",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 785,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623900",
    "postTime": "2024-09-28 23:26:16",
    "diggCount": 12,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142623886,
    "title": "SpringBoot 服务性能优化12",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623886",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 598,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623886",
    "postTime": "2024-09-28 23:25:13",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142623866,
    "title": "SpringBoot 服务性能优化11",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623866",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 866,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623866",
    "postTime": "2024-09-28 23:24:50",
    "diggCount": 21,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142623875,
    "title": "SpringBoot 服务性能优化10",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 953,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623875",
    "postTime": "2024-09-28 23:24:43",
    "diggCount": 28,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142623849,
    "title": "SpringBoot 服务性能优化9",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623849",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 933,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623849",
    "postTime": "2024-09-28 23:23:40",
    "diggCount": 28,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142623860,
    "title": "SpringBoot 服务性能优化7",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623860",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 237,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623860",
    "postTime": "2024-09-28 23:23:35",
    "diggCount": 5,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142623833,
    "title": "SpringBoot 服务性能优化8",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623833",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 622,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623833",
    "postTime": "2024-09-28 23:22:08",
    "diggCount": 9,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142623826,
    "title": "SpringBoot 服务性能优化5",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623826",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 945,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623826",
    "postTime": "2024-09-28 23:21:27",
    "diggCount": 20,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142623752,
    "title": "SpringBoot 服务性能优化6",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623752",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 905,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623752",
    "postTime": "2024-09-28 23:20:52",
    "diggCount": 9,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142623813,
    "title": "SpringBoot 服务性能优化4",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623813",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 220,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623813",
    "postTime": "2024-09-28 23:20:45",
    "diggCount": 3,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142623792,
    "title": "SpringBoot 服务性能优化3",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623792",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 613,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623792",
    "postTime": "2024-09-28 23:20:41",
    "diggCount": 21,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142623774,
    "title": "SpringBoot 服务性能优化2",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623774",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 991,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623774",
    "postTime": "2024-09-28 23:20:19",
    "diggCount": 19,
    "formatTime": "2024.09.28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b1fc04c02954f42840099982db96c18.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142623740,
    "title": "SpringBoot 服务性能优化1",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142623740",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 775,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623740",
    "postTime": "2024-09-28 23:20:16",
    "diggCount": 19,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142029460,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029460",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 867,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029460",
    "postTime": "2024-09-08 16:55:55",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142029404,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029404",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 552,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029404",
    "postTime": "2024-09-08 16:55:26",
    "diggCount": 27,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142029449,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 835,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029449",
    "postTime": "2024-09-08 16:55:21",
    "diggCount": 27,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142029417,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029417",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1038,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029417",
    "postTime": "2024-09-08 16:54:01",
    "diggCount": 19,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142029381,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029381",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 596,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029381",
    "postTime": "2024-09-08 16:53:35",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142029393,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029393",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 849,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029393",
    "postTime": "2024-09-08 16:52:55",
    "diggCount": 7,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142029363,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029363",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 537,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029363",
    "postTime": "2024-09-08 16:52:06",
    "diggCount": 18,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142029337,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029337",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 566,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029337",
    "postTime": "2024-09-08 16:52:01",
    "diggCount": 10,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142029315,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029315",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 918,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029315",
    "postTime": "2024-09-08 16:51:51",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142029293,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029293",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 698,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029293",
    "postTime": "2024-09-08 16:51:44",
    "diggCount": 24,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142029271,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029271",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 897,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029271",
    "postTime": "2024-09-08 16:51:41",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142029257,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029257",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 915,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029257",
    "postTime": "2024-09-08 16:51:37",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142029348,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029348",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 636,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029348",
    "postTime": "2024-09-08 16:51:04",
    "diggCount": 10,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142029328,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029328",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 809,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029328",
    "postTime": "2024-09-08 16:50:01",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142029307,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/142029307",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 895,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029307",
    "postTime": "2024-09-08 16:48:54",
    "diggCount": 21,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141968569,
    "title": "【无标题】",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141968569",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 519,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141968569",
    "postTime": "2024-09-07 03:25:30",
    "diggCount": 17,
    "formatTime": "2024.09.07",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141934471,
    "title": "案例分析：大对象复用的目标和注意点5",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141934471",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 255,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934471",
    "postTime": "2024-09-05 16:23:40",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141934448,
    "title": "案例分析：大对象复用的目标和注意点4",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141934448",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934448",
    "postTime": "2024-09-05 16:23:09",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141934415,
    "title": "案例分析：大对象复用的目标和注意点3",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141934415",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934415",
    "postTime": "2024-09-05 16:22:16",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141934392,
    "title": "案例分析：大对象复用的目标和注意点2",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141934392",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 334,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934392",
    "postTime": "2024-09-05 16:21:45",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141934271,
    "title": "案例分析：大对象复用的目标和注意点1",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141934271",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 402,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934271",
    "postTime": "2024-09-05 16:18:59",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141888206,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法25",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141888206",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888206",
    "postTime": "2024-09-04 11:09:34",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141888180,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法21",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141888180",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888180",
    "postTime": "2024-09-04 11:09:03",
    "diggCount": 2,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141888142,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法20",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141888142",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 430,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888142",
    "postTime": "2024-09-04 11:08:00",
    "diggCount": 3,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141888082,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法18",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141888082",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888082",
    "postTime": "2024-09-04 11:06:25",
    "diggCount": 4,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141887951,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法22",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887951",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 190,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887951",
    "postTime": "2024-09-04 11:03:04",
    "diggCount": 5,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141887878,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法24",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887878",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887878",
    "postTime": "2024-09-04 11:00:59",
    "diggCount": 3,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141887860,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法19",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887860",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887860",
    "postTime": "2024-09-04 11:00:29",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141887840,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法26",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887840",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887840",
    "postTime": "2024-09-04 11:00:02",
    "diggCount": 4,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141887801,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法27",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887801",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 197,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887801",
    "postTime": "2024-09-04 10:59:46",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141887656,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法23",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887656",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 282,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887656",
    "postTime": "2024-09-04 10:59:34",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141887757,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法28",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887757",
    "postTime": "2024-09-04 10:59:21",
    "diggCount": 1,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141887722,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法29",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887722",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 260,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887722",
    "postTime": "2024-09-04 10:59:16",
    "diggCount": 2,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141887604,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法30",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887604",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 309,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887604",
    "postTime": "2024-09-04 10:59:11",
    "diggCount": 4,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141887691,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法17",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887691",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 321,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887691",
    "postTime": "2024-09-04 10:55:51",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141887640,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法16",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141887640",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 208,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887640",
    "postTime": "2024-09-04 10:54:32",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141865676,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法15",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865676",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 402,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865676",
    "postTime": "2024-09-03 16:39:10",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865652,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法14",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865652",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 344,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865652",
    "postTime": "2024-09-03 16:38:36",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141865633,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法13",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865633",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865633",
    "postTime": "2024-09-03 16:38:03",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141865601,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法11",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865601",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 395,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865601",
    "postTime": "2024-09-03 16:37:10",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141865588,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法10",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865588",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 484,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865588",
    "postTime": "2024-09-03 16:36:31",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141865565,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法9",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865565",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865565",
    "postTime": "2024-09-03 16:35:54",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865548,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法8",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865548",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 418,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865548",
    "postTime": "2024-09-03 16:35:22",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141865533,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法7",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865533",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 325,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865533",
    "postTime": "2024-09-03 16:34:49",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141865512,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法6",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865512",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865512",
    "postTime": "2024-09-03 16:34:15",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141865488,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法5",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865488",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865488",
    "postTime": "2024-09-03 16:33:35",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141865469,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法4",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865469",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 293,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865469",
    "postTime": "2024-09-03 16:33:02",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141865451,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法3",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865451",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865451",
    "postTime": "2024-09-03 16:32:26",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141865434,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法2",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865434",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 274,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865434",
    "postTime": "2024-09-03 16:31:52",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141865405,
    "title": "ThreadLocal中的内存泄漏问题及JDK处理方法1",
    "description": "由图可知，ThreadLocal.ThreadLocalMap 对应的Entry中，key为ThreadLocal对象的弱引用，方法执行对应栈帧中的ThreadLocal引用为强引用。而Entry中value对应的是变量实体对象的强引用，因此释放一个ThreadLocal对象，是无法释放ThreadLocal.ThreadLocalMap中对应的value对象的，也就造成了内存泄漏。但是日常开发中会经常使用线程池等线程池化技术，释放线程对象的条件往往无法达到。",
    "url": "https://blog.csdn.net/2401_86608312/article/details/141865405",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141865405",
    "postTime": "2024-09-03 16:31:21",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6d627cff7e314dffafdee79a786ed66a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142865883,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865883",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 476,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865883",
    "postTime": "2024-10-11 23:57:34",
    "diggCount": 7,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142865859,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865859",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 662,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865859",
    "postTime": "2024-10-11 23:57:29",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142865884,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865884",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 414,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865884",
    "postTime": "2024-10-11 23:57:26",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142865899,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865899",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 854,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865899",
    "postTime": "2024-10-11 23:57:22",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142865873,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865873",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 555,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865873",
    "postTime": "2024-10-11 23:56:49",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142865890,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865890",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 784,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865890",
    "postTime": "2024-10-11 23:56:45",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142865839,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865839",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 730,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865839",
    "postTime": "2024-10-11 23:56:03",
    "diggCount": 6,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142865850,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865850",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 405,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865850",
    "postTime": "2024-10-11 23:55:59",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142865872,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865872",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 502,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865872",
    "postTime": "2024-10-11 23:55:56",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142865858,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865858",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 361,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865858",
    "postTime": "2024-10-11 23:55:21",
    "diggCount": 14,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142865831,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865831",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 749,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865831",
    "postTime": "2024-10-11 23:55:17",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142865820,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865820",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 428,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865820",
    "postTime": "2024-10-11 23:55:13",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142865804,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865804",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 377,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865804",
    "postTime": "2024-10-11 23:50:30",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142865793,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865793",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 787,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865793",
    "postTime": "2024-10-11 23:50:26",
    "diggCount": 16,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142865781,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142865781",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 438,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865781",
    "postTime": "2024-10-11 23:50:22",
    "diggCount": 14,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6b30b2b07ff74b9dba661bdb64e60694.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142624122,
    "title": "SpringBoot 服务性能优化15",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624122",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 653,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624122",
    "postTime": "2024-09-28 23:43:59",
    "diggCount": 22,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142624115,
    "title": "SpringBoot 服务性能优化14",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624115",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 952,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624115",
    "postTime": "2024-09-28 23:43:19",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142624085,
    "title": "SpringBoot 服务性能优化12",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624085",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 536,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624085",
    "postTime": "2024-09-28 23:40:59",
    "diggCount": 8,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142624083,
    "title": "SpringBoot 服务性能优化11",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624083",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1071,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624083",
    "postTime": "2024-09-28 23:40:28",
    "diggCount": 26,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142624063,
    "title": "SpringBoot 服务性能优化13",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624063",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 815,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624063",
    "postTime": "2024-09-28 23:39:58",
    "diggCount": 25,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142624071,
    "title": "SpringBoot 服务性能优化10",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624071",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 767,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624071",
    "postTime": "2024-09-28 23:39:40",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142624056,
    "title": "SpringBoot 服务性能优化8",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624056",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 706,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624056",
    "postTime": "2024-09-28 23:38:18",
    "diggCount": 20,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142624047,
    "title": "SpringBoot 服务性能优化9",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624047",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 994,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624047",
    "postTime": "2024-09-28 23:37:48",
    "diggCount": 27,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142624035,
    "title": "SpringBoot 服务性能优化7",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624035",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 739,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624035",
    "postTime": "2024-09-28 23:36:31",
    "diggCount": 15,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142624021,
    "title": "SpringBoot 服务性能优化6",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624021",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 756,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624021",
    "postTime": "2024-09-28 23:36:13",
    "diggCount": 17,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142624012,
    "title": "SpringBoot 服务性能优化5",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142624012",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 858,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624012",
    "postTime": "2024-09-28 23:36:08",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142623990,
    "title": "SpringBoot 服务性能优化4",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142623990",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623990",
    "postTime": "2024-09-28 23:33:55",
    "diggCount": 18,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142623984,
    "title": "SpringBoot 服务性能优化2",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142623984",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 712,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623984",
    "postTime": "2024-09-28 23:33:47",
    "diggCount": 30,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142623972,
    "title": "SpringBoot 服务性能优化1",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142623972",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1056,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623972",
    "postTime": "2024-09-28 23:33:44",
    "diggCount": 9,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142623960,
    "title": "SpringBoot 服务性能优化3",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142623960",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 731,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623960",
    "postTime": "2024-09-28 23:33:39",
    "diggCount": 18,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142029677,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029677",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 811,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029677",
    "postTime": "2024-09-08 17:08:05",
    "diggCount": 11,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142029613,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029613",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1016,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029613",
    "postTime": "2024-09-08 17:07:34",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142029666,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029666",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 727,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029666",
    "postTime": "2024-09-08 17:07:26",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142029658,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1105,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029658",
    "postTime": "2024-09-08 17:06:56",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142029558,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029558",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 551,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029558",
    "postTime": "2024-09-08 17:06:36",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142029646,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029646",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1094,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029646",
    "postTime": "2024-09-08 17:06:27",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142029539,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029539",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1104,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029539",
    "postTime": "2024-09-08 17:06:23",
    "diggCount": 24,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142029523,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029523",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 583,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029523",
    "postTime": "2024-09-08 17:06:19",
    "diggCount": 10,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142029507,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029507",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1125,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029507",
    "postTime": "2024-09-08 17:06:16",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142029634,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029634",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1051,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029634",
    "postTime": "2024-09-08 17:05:46",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142029625,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 940,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029625",
    "postTime": "2024-09-08 17:05:13",
    "diggCount": 20,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142029585,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029585",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 872,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029585",
    "postTime": "2024-09-08 17:04:33",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142029591,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029591",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 938,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029591",
    "postTime": "2024-09-08 17:03:18",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142029575,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029575",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 666,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029575",
    "postTime": "2024-09-08 17:02:16",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142029552,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/142029552",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 686,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029552",
    "postTime": "2024-09-08 17:01:10",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141934978,
    "title": "案例分析：大对象复用的目标和注意点10",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934978",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 426,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934978",
    "postTime": "2024-09-05 16:37:13",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141934954,
    "title": "案例分析：大对象复用的目标和注意点9",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934954",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 873,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934954",
    "postTime": "2024-09-05 16:36:41",
    "diggCount": 16,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141934934,
    "title": "案例分析：大对象复用的目标和注意点8",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934934",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1051,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934934",
    "postTime": "2024-09-05 16:35:51",
    "diggCount": 24,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 141934898,
    "title": "案例分析：大对象复用的目标和注意点7",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934898",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 823,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934898",
    "postTime": "2024-09-05 16:35:15",
    "diggCount": 20,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 141934858,
    "title": "案例分析：大对象复用的目标和注意点6",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934858",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 465,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934858",
    "postTime": "2024-09-05 16:33:37",
    "diggCount": 9,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141934829,
    "title": "案例分析：大对象复用的目标和注意点5",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934829",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934829",
    "postTime": "2024-09-05 16:32:51",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141934796,
    "title": "案例分析：大对象复用的目标和注意点4",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934796",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 362,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934796",
    "postTime": "2024-09-05 16:32:16",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141934771,
    "title": "案例分析：大对象复用的目标和注意点3",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934771",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934771",
    "postTime": "2024-09-05 16:31:44",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141934715,
    "title": "案例分析：大对象复用的目标和注意点2",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934715",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 401,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934715",
    "postTime": "2024-09-05 16:29:58",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141934681,
    "title": "案例分析：大对象复用的目标和注意点1",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141934681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 215,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141934681",
    "postTime": "2024-09-05 16:29:08",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141886634,
    "title": "案例研究：缓冲区技术如何优化代码执行速度30",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886634",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1049,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886634",
    "postTime": "2024-09-04 10:29:30",
    "diggCount": 31,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/75e0b831dd114401a0f5634000ed0a60.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141886612,
    "title": "案例研究：缓冲区技术如何优化代码执行速度29",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886612",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 937,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886612",
    "postTime": "2024-09-04 10:28:55",
    "diggCount": 16,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6f940d11c337498391787cee80aceb3c.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141886580,
    "title": "案例研究：缓冲区技术如何优化代码执行速度28",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886580",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 819,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886580",
    "postTime": "2024-09-04 10:28:17",
    "diggCount": 28,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 141886559,
    "title": "案例研究：缓冲区技术如何优化代码执行速度27",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886559",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 923,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886559",
    "postTime": "2024-09-04 10:27:43",
    "diggCount": 28,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/051717ca00b6481490d33fad1452204e.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141886541,
    "title": "案例研究：缓冲区技术如何优化代码执行速度26",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886541",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 796,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886541",
    "postTime": "2024-09-04 10:27:07",
    "diggCount": 23,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141886528,
    "title": "案例研究：缓冲区技术如何优化代码执行速度25",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886528",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 783,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886528",
    "postTime": "2024-09-04 10:26:36",
    "diggCount": 16,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 141886500,
    "title": "案例研究：缓冲区技术如何优化代码执行速度24",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886500",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 851,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886500",
    "postTime": "2024-09-04 10:26:06",
    "diggCount": 30,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141886474,
    "title": "案例研究：缓冲区技术如何优化代码执行速度23",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886474",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 889,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886474",
    "postTime": "2024-09-04 10:25:34",
    "diggCount": 19,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141886427,
    "title": "案例研究：缓冲区技术如何优化代码执行速度22",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886427",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1127,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886427",
    "postTime": "2024-09-04 10:24:28",
    "diggCount": 12,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d9cd198d67af41d4b77c50d9a33c8398.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 141886406,
    "title": "案例研究：缓冲区技术如何优化代码执行速度21",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886406",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 765,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886406",
    "postTime": "2024-09-04 10:23:55",
    "diggCount": 28,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141886385,
    "title": "案例研究：缓冲区技术如何优化代码执行速度20",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886385",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 674,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886385",
    "postTime": "2024-09-04 10:23:23",
    "diggCount": 12,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141886373,
    "title": "案例研究：缓冲区技术如何优化代码执行速度19",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886373",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 745,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886373",
    "postTime": "2024-09-04 10:22:51",
    "diggCount": 14,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141886351,
    "title": "案例研究：缓冲区技术如何优化代码执行速度18",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886351",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 933,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886351",
    "postTime": "2024-09-04 10:22:20",
    "diggCount": 29,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141886306,
    "title": "案例研究：缓冲区技术如何优化代码执行速度17",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886306",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 768,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886306",
    "postTime": "2024-09-04 10:21:05",
    "diggCount": 17,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 141886295,
    "title": "案例研究：缓冲区技术如何优化代码执行速度16",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141886295",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1188,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886295",
    "postTime": "2024-09-04 10:20:34",
    "diggCount": 7,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 141866226,
    "title": "案例研究：缓冲区技术如何优化代码执行速度15",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866226",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1073,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866226",
    "postTime": "2024-09-03 16:53:41",
    "diggCount": 12,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6f940d11c337498391787cee80aceb3c.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 141866200,
    "title": "案例研究：缓冲区技术如何优化代码执行速度11",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 425,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866200",
    "postTime": "2024-09-03 16:52:54",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/051717ca00b6481490d33fad1452204e.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141866182,
    "title": "案例研究：缓冲区技术如何优化代码执行速度6",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866182",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 688,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866182",
    "postTime": "2024-09-03 16:52:18",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d9cd198d67af41d4b77c50d9a33c8398.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 141866161,
    "title": "案例研究：缓冲区技术如何优化代码执行速度4",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866161",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 356,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866161",
    "postTime": "2024-09-03 16:51:44",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141866138,
    "title": "案例研究：缓冲区技术如何优化代码执行速度13",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866138",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 508,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866138",
    "postTime": "2024-09-03 16:51:10",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141866118,
    "title": "案例研究：缓冲区技术如何优化代码执行速度9",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866118",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 815,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866118",
    "postTime": "2024-09-03 16:50:38",
    "diggCount": 19,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141866093,
    "title": "案例研究：缓冲区技术如何优化代码执行速度5",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866093",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 464,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866093",
    "postTime": "2024-09-03 16:50:03",
    "diggCount": 7,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141866069,
    "title": "案例研究：缓冲区技术如何优化代码执行速度14",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866069",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866069",
    "postTime": "2024-09-03 16:49:28",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141866006,
    "title": "案例研究：缓冲区技术如何优化代码执行速度12",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866006",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1168,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866006",
    "postTime": "2024-09-03 16:49:11",
    "diggCount": 26,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141866048,
    "title": "案例研究：缓冲区技术如何优化代码执行速度10",
    "description": "SLF4J 是 Java 里标准的日志记录库，它是一个允许你使用任何 Java 日志记录库的抽象适配层，最常用的实现是 Logback，支持修改后自动 reload，它比 Java 自带的 JUL 还要流行。这同样和生产者的缓冲区有关。这就是一个权衡的问题，缓冲区开得太大，会增加单次读写的时间，同时内存价格很高，不能无限制使用，缓冲流的默认缓冲区大小是 8192 字节，也就是 8KB，算是一个比较折中的值。，它在记录日志时，使用了一个缓冲队列，当缓冲的内容达到一定的阈值时，才会把缓冲区的内容写到文件里。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/141866048",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1095,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866048",
    "postTime": "2024-09-03 16:48:56",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a9a99c314abe4f4bbbcbd76d4a85dbed.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140891326,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891326",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 665,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891326",
    "postTime": "2024-08-03 15:29:55",
    "diggCount": 23,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140891318,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891318",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 524,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891318",
    "postTime": "2024-08-03 15:29:15",
    "diggCount": 10,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140891304,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 605,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891304",
    "postTime": "2024-08-03 15:28:39",
    "diggCount": 21,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140891285,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891285",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 910,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891285",
    "postTime": "2024-08-03 15:28:30",
    "diggCount": 17,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 140891257,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891257",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 778,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891257",
    "postTime": "2024-08-03 15:28:24",
    "diggCount": 11,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140891238,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891238",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 971,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891238",
    "postTime": "2024-08-03 15:28:19",
    "diggCount": 28,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140891217,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891217",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891217",
    "postTime": "2024-08-03 15:23:43",
    "diggCount": 14,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c2ee405eea2d4cbfa51063ec882f31b9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140891194,
    "title": "ThreadLocal部分核心源码回顾",
    "description": "不相等情况：不相等情况，以get(ThreadLocal2)为例计算下标为4，且4存在Entry，但key相等，这个时候则为往后迭代寻找key相等的元素，如果寻找过程中发现了有key = null的元素则回进行探测式清理操作。从散列表该下标开始往后查key相等的元素，如果找到则做清除操作，引用置为null，GC的时候key就会置为null，然后执行探测式清理处理。主要包含两种情况，一种是hash计算出下标，该下标对应的Entry.key和我们传入的key相等的情况，另外一种就是不相等的情况。",
    "url": "https://blog.csdn.net/2401_86608357/article/details/140891194",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 629,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891194",
    "postTime": "2024-08-03 15:23:36",
    "diggCount": 15,
    "formatTime": "2024.08.03",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 143030464,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 221,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030464",
    "postTime": "2024-10-17 22:53:09",
    "diggCount": 7,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 143030345,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030345",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 222,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030345",
    "postTime": "2024-10-17 22:53:05",
    "diggCount": 6,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143030391,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030391",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 507,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030391",
    "postTime": "2024-10-17 22:52:59",
    "diggCount": 9,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143030364,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030364",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030364",
    "postTime": "2024-10-17 22:52:55",
    "diggCount": 2,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143030378,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030378",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 224,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030378",
    "postTime": "2024-10-17 22:52:46",
    "diggCount": 2,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 143030377,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030377",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 286,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030377",
    "postTime": "2024-10-17 22:52:41",
    "diggCount": 13,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143030429,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030429",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 414,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030429",
    "postTime": "2024-10-17 22:52:38",
    "diggCount": 5,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143030403,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030403",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030403",
    "postTime": "2024-10-17 22:50:48",
    "diggCount": 6,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143030414,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030414",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030414",
    "postTime": "2024-10-17 22:50:42",
    "diggCount": 10,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143030332,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030332",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 324,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030332",
    "postTime": "2024-10-17 22:49:25",
    "diggCount": 3,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143030314,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030314",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 228,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030314",
    "postTime": "2024-10-17 22:49:21",
    "diggCount": 6,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143030301,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030301",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030301",
    "postTime": "2024-10-17 22:49:13",
    "diggCount": 4,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143030287,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030287",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 363,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030287",
    "postTime": "2024-10-17 22:43:32",
    "diggCount": 5,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 143030269,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030269",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 511,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030269",
    "postTime": "2024-10-17 22:43:28",
    "diggCount": 10,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143030286,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/143030286",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 370,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143030286",
    "postTime": "2024-10-17 22:43:23",
    "diggCount": 8,
    "formatTime": "1 小时前",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142624250,
    "title": "SpringBoot 服务性能优化15",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624250",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 924,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624250",
    "postTime": "2024-09-28 23:57:17",
    "diggCount": 19,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142624243,
    "title": "SpringBoot 服务性能优化12",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624243",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 843,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624243",
    "postTime": "2024-09-28 23:56:28",
    "diggCount": 29,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142624239,
    "title": "SpringBoot 服务性能优化13",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624239",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 811,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624239",
    "postTime": "2024-09-28 23:55:46",
    "diggCount": 21,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142624235,
    "title": "SpringBoot 服务性能优化9",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624235",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 884,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624235",
    "postTime": "2024-09-28 23:55:14",
    "diggCount": 15,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142624229,
    "title": "SpringBoot 服务性能优化14",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624229",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 848,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624229",
    "postTime": "2024-09-28 23:55:02",
    "diggCount": 17,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142624219,
    "title": "SpringBoot 服务性能优化11",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624219",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 900,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624219",
    "postTime": "2024-09-28 23:54:05",
    "diggCount": 15,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142624212,
    "title": "SpringBoot 服务性能优化10",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624212",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 736,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624212",
    "postTime": "2024-09-28 23:53:53",
    "diggCount": 27,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142624205,
    "title": "SpringBoot 服务性能优化8",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624205",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 951,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624205",
    "postTime": "2024-09-28 23:52:53",
    "diggCount": 27,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142624182,
    "title": "SpringBoot 服务性能优化7",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624182",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 815,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624182",
    "postTime": "2024-09-28 23:52:24",
    "diggCount": 15,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142624202,
    "title": "SpringBoot 服务性能优化6",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624202",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1051,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624202",
    "postTime": "2024-09-28 23:52:17",
    "diggCount": 19,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142624190,
    "title": "SpringBoot 服务性能优化5",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624190",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 959,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624190",
    "postTime": "2024-09-28 23:51:13",
    "diggCount": 12,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142624176,
    "title": "SpringBoot 服务性能优化4",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624176",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 953,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624176",
    "postTime": "2024-09-28 23:49:55",
    "diggCount": 26,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142624170,
    "title": "SpringBoot 服务性能优化3",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624170",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1018,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624170",
    "postTime": "2024-09-28 23:49:22",
    "diggCount": 11,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142624164,
    "title": "SpringBoot 服务性能优化2",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624164",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 900,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624164",
    "postTime": "2024-09-28 23:49:16",
    "diggCount": 21,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142624161,
    "title": "SpringBoot 服务性能优化1",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142624161",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 851,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142624161",
    "postTime": "2024-09-28 23:49:08",
    "diggCount": 24,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/49b58f8f87936bdeb6ef8e8caeccb6e2.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142029909,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029909",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 363,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029909",
    "postTime": "2024-09-08 17:22:02",
    "diggCount": 3,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142029898,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029898",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 660,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029898",
    "postTime": "2024-09-08 17:21:23",
    "diggCount": 20,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142029888,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029888",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 774,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029888",
    "postTime": "2024-09-08 17:20:45",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142029875,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 712,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029875",
    "postTime": "2024-09-08 17:20:12",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142029852,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029852",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 623,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029852",
    "postTime": "2024-09-08 17:20:07",
    "diggCount": 26,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142029866,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029866",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1248,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029866",
    "postTime": "2024-09-08 17:19:59",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142029807,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029807",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029807",
    "postTime": "2024-09-08 17:18:11",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142029837,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029837",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 885,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029837",
    "postTime": "2024-09-08 17:18:05",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142029820,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029820",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1087,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029820",
    "postTime": "2024-09-08 17:17:53",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142029775,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/142029775",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 620,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142029775",
    "postTime": "2024-09-08 17:17:50",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 141887292,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践19",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887292",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 800,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887292",
    "postTime": "2024-09-04 10:45:40",
    "diggCount": 23,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141887062,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践21",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887062",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 616,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887062",
    "postTime": "2024-09-04 10:44:15",
    "diggCount": 16,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141887102,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践22",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887102",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 855,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887102",
    "postTime": "2024-09-04 10:44:10",
    "diggCount": 12,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141887018,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践23",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887018",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 433,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887018",
    "postTime": "2024-09-04 10:44:05",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141887139,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践24",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887139",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 789,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887139",
    "postTime": "2024-09-04 10:44:00",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141887210,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践27",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887210",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 736,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887210",
    "postTime": "2024-09-04 10:43:42",
    "diggCount": 14,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141887189,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践20",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141887189",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 622,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141887189",
    "postTime": "2024-09-04 10:43:09",
    "diggCount": 13,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141886968,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践17",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141886968",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 912,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886968",
    "postTime": "2024-09-04 10:38:58",
    "diggCount": 25,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141886994,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践30",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141886994",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 761,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886994",
    "postTime": "2024-09-04 10:38:36",
    "diggCount": 15,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141886906,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践16",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141886906",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 474,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141886906",
    "postTime": "2024-09-04 10:36:20",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141866675,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践15",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866675",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 228,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866675",
    "postTime": "2024-09-03 17:06:10",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141866660,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践14",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866660",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866660",
    "postTime": "2024-09-03 17:05:35",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141866634,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践13",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866634",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 238,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866634",
    "postTime": "2024-09-03 17:05:04",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141866613,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践12",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866613",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 408,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866613",
    "postTime": "2024-09-03 17:04:30",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141866590,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践11",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866590",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 316,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866590",
    "postTime": "2024-09-03 17:04:00",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141866570,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践10",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866570",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 286,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866570",
    "postTime": "2024-09-03 17:03:27",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141866554,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践9",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866554",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 667,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866554",
    "postTime": "2024-09-03 17:02:46",
    "diggCount": 17,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141866537,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践9",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866537",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 721,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866537",
    "postTime": "2024-09-03 17:02:12",
    "diggCount": 18,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141866512,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践8",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866512",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 610,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866512",
    "postTime": "2024-09-03 17:01:36",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141866490,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践7",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866490",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866490",
    "postTime": "2024-09-03 17:00:54",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141866465,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践6",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866465",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866465",
    "postTime": "2024-09-03 17:00:19",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141866427,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践4",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866427",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 277,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866427",
    "postTime": "2024-09-03 16:59:10",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141866407,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践3",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866407",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 633,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866407",
    "postTime": "2024-09-03 16:58:37",
    "diggCount": 21,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141866333,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践2",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866333",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 445,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866333",
    "postTime": "2024-09-03 16:56:45",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141866312,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践1",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141866312",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 918,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141866312",
    "postTime": "2024-09-03 16:56:11",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141818752,
    "title": "打造 ContextManager：ThreadLocal 技术的深度应用",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818752",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 897,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818752",
    "postTime": "2024-09-02 14:19:25",
    "diggCount": 7,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141818733,
    "title": "ThreadLocal 与上下文管理的完美结合：ContextManager 解析",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818733",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 560,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818733",
    "postTime": "2024-09-02 14:18:43",
    "diggCount": 11,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141818721,
    "title": "实现 ContextManager 的 ThreadLocal 技术探秘",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818721",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 681,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818721",
    "postTime": "2024-09-02 14:18:12",
    "diggCount": 9,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141818700,
    "title": "灵活上下文管理：ThreadLocal 助力 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818700",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 895,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818700",
    "postTime": "2024-09-02 14:17:42",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141818679,
    "title": "利用 ThreadLocal 打造 ContextManager 的最佳实践",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818679",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 549,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818679",
    "postTime": "2024-09-02 14:17:04",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141818671,
    "title": "高效上下文管理：ThreadLocal 在 ContextManager 中的应用",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818671",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 696,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818671",
    "postTime": "2024-09-02 14:16:58",
    "diggCount": 14,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141818635,
    "title": "从零开始：基于 ThreadLocal 的 ContextManager 构建之道",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818635",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818635",
    "postTime": "2024-09-02 14:15:26",
    "diggCount": 17,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141818623,
    "title": "ThreadLocal 技术详解：打造高效的 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818623",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 814,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818623",
    "postTime": "2024-09-02 14:14:53",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141818593,
    "title": "轻松管理上下文：ThreadLocal 助力 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818593",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 587,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818593",
    "postTime": "2024-09-02 14:13:59",
    "diggCount": 30,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141818551,
    "title": "线程安全的上下文管理：ContextManager 的 ThreadLocal 实现",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818551",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1009,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818551",
    "postTime": "2024-09-02 14:13:53",
    "diggCount": 14,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141818573,
    "title": "上下文管理的艺术：ThreadLocal 如何赋能 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818573",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 880,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818573",
    "postTime": "2024-09-02 14:13:14",
    "diggCount": 11,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141818521,
    "title": "ContextManager 实战：ThreadLocal 的最佳实践",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818521",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1176,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818521",
    "postTime": "2024-09-02 14:12:02",
    "diggCount": 23,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141818499,
    "title": "如何用 ThreadLocal 构建强大的 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818499",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 838,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818499",
    "postTime": "2024-09-02 14:11:58",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141818538,
    "title": "深入剖析：基于 ThreadLocal 实现的 ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818538",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 840,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818538",
    "postTime": "2024-09-02 14:11:48",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141818456,
    "title": "揭秘 ContextManager：ThreadLocal 在上下文管理中的应用",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/141818456",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 589,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818456",
    "postTime": "2024-09-02 14:09:04",
    "diggCount": 18,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140891717,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891717",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 424,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891717",
    "postTime": "2024-08-03 15:48:40",
    "diggCount": 5,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c7198b1cd87d44f782f2f031f10dc48d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140891704,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891704",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 243,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891704",
    "postTime": "2024-08-03 15:47:50",
    "diggCount": 4,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bbc7e571f77c42288248778eaf6473ce.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140891690,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891690",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 919,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891690",
    "postTime": "2024-08-03 15:47:30",
    "diggCount": 13,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b43905959810494090a9c4ca5017e885.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140891494,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891494",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 641,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891494",
    "postTime": "2024-08-03 15:47:11",
    "diggCount": 22,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/22a31904b5494b8ca1dcec579fb0ed09.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140891605,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891605",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 763,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891605",
    "postTime": "2024-08-03 15:46:43",
    "diggCount": 8,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f7ed4a451e144b299b86f08642df1bf.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140891655,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891655",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 241,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891655",
    "postTime": "2024-08-03 15:45:48",
    "diggCount": 5,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/00267d299cd4409c8dc6d65414ca50b0.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140891644,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891644",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 861,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891644",
    "postTime": "2024-08-03 15:45:06",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/af3eef3342424f56b2c6046e10bb285c.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140891626,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891626",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 713,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891626",
    "postTime": "2024-08-03 15:44:09",
    "diggCount": 16,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e3f02390d71b406783f7de4248a04ebc.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140891595,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891595",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 884,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891595",
    "postTime": "2024-08-03 15:42:52",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6e07b5fa98e943e7ad62b2e47ee211ad.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140891572,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891572",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 867,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891572",
    "postTime": "2024-08-03 15:42:29",
    "diggCount": 26,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/dec3a8721a964a698b662c85cc2a2d83.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140891551,
    "title": "基于Threadlocal实现的上下文管理组件ContextManager",
    "description": "首先，定义一个 ContextManager 类用于管理上下文信息。/*** @description: 用于管理上下文信息**/// 静态变量，维护不同线程的上下文// 实例变量，维护每个上下文中所有的状态数据// 获取当前线程的上下文// 在当前上下文设置一个状态数据if (value!= null) {} else {// 在当前上下文读取一个状态数据// 开启一个新的上下文= null) {// 关闭当前上下文。",
    "url": "https://blog.csdn.net/weixin_48861542/article/details/140891551",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 832,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/140891551",
    "postTime": "2024-08-03 15:41:38",
    "diggCount": 17,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c6c9ff3fa05f4c7fb8eab179e766e7f7.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142934088,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934088",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 498,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934088",
    "postTime": "2024-10-15 09:03:37",
    "diggCount": 14,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142934068,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934068",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 683,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934068",
    "postTime": "2024-10-15 09:03:33",
    "diggCount": 19,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142934200,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934200",
    "postTime": "2024-10-15 09:03:30",
    "diggCount": 17,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142934152,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934152",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 648,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934152",
    "postTime": "2024-10-15 09:03:27",
    "diggCount": 10,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142934128,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934128",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 538,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934128",
    "postTime": "2024-10-15 09:03:23",
    "diggCount": 9,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142934230,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934230",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 647,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934230",
    "postTime": "2024-10-15 09:03:20",
    "diggCount": 28,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142934114,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934114",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 608,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934114",
    "postTime": "2024-10-15 09:03:17",
    "diggCount": 19,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142934178,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934178",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 713,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934178",
    "postTime": "2024-10-15 09:03:14",
    "diggCount": 19,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142934177,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934177",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 677,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934177",
    "postTime": "2024-10-15 09:03:11",
    "diggCount": 18,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142934046,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934046",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 621,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934046",
    "postTime": "2024-10-15 09:03:08",
    "diggCount": 24,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142934045,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934045",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 769,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934045",
    "postTime": "2024-10-15 09:03:04",
    "diggCount": 15,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142934026,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934026",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 592,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934026",
    "postTime": "2024-10-15 09:03:01",
    "diggCount": 8,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142933986,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142933986",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 505,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933986",
    "postTime": "2024-10-15 09:02:58",
    "diggCount": 16,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142934005,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142934005",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 879,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934005",
    "postTime": "2024-10-15 09:02:55",
    "diggCount": 21,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142933961,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142933961",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 964,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933961",
    "postTime": "2024-10-15 09:02:50",
    "diggCount": 14,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142896842,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896842",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 222,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896842",
    "postTime": "2024-10-13 13:04:45",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142896985,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896985",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 408,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896985",
    "postTime": "2024-10-13 13:04:42",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142896984,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896984",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896984",
    "postTime": "2024-10-13 13:04:38",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142896959,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896959",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 263,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896959",
    "postTime": "2024-10-13 13:04:35",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897039,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142897039",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 336,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897039",
    "postTime": "2024-10-13 13:04:31",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897006,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142897006",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 378,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897006",
    "postTime": "2024-10-13 13:04:24",
    "diggCount": 7,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142896958,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896958",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896958",
    "postTime": "2024-10-13 12:58:02",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142896973,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896973",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 357,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896973",
    "postTime": "2024-10-13 12:57:58",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142896947,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896947",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 371,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896947",
    "postTime": "2024-10-13 12:55:29",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142896936,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896936",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 270,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896936",
    "postTime": "2024-10-13 12:53:24",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142896916,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896916",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896916",
    "postTime": "2024-10-13 12:53:20",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142896917,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896917",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896917",
    "postTime": "2024-10-13 12:53:14",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142896902,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896902",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 376,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896902",
    "postTime": "2024-10-13 12:53:10",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142896881,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896881",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 259,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896881",
    "postTime": "2024-10-13 12:50:53",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142896865,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142896865",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 204,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896865",
    "postTime": "2024-10-13 12:50:50",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142866127,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866127",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 188,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866127",
    "postTime": "2024-10-12 00:20:53",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866116,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866116",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 248,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866116",
    "postTime": "2024-10-12 00:19:55",
    "diggCount": 7,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866108,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866108",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 154,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866108",
    "postTime": "2024-10-12 00:19:14",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866104,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866104",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 191,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866104",
    "postTime": "2024-10-12 00:18:42",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866101,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866101",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 142,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866101",
    "postTime": "2024-10-12 00:18:12",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866047,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866047",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 187,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866047",
    "postTime": "2024-10-12 00:17:45",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866067,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866067",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 119,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866067",
    "postTime": "2024-10-12 00:17:41",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866098,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866098",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 186,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866098",
    "postTime": "2024-10-12 00:17:33",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866085,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866085",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 175,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866085",
    "postTime": "2024-10-12 00:17:20",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866072,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866072",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 180,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866072",
    "postTime": "2024-10-12 00:17:16",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866095,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866095",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 186,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866095",
    "postTime": "2024-10-12 00:16:57",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866052,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866052",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 88,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866052",
    "postTime": "2024-10-12 00:13:56",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866062,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866062",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 106,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866062",
    "postTime": "2024-10-12 00:13:51",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866037,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866037",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 192,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866037",
    "postTime": "2024-10-12 00:11:52",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142866026,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142866026",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 94,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142866026",
    "postTime": "2024-10-12 00:11:48",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/79f87b8ca1784c34b187eb52d7ec3123.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142799888,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799888",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 819,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799888",
    "postTime": "2024-10-10 07:46:30",
    "diggCount": 15,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142799945,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799945",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 714,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799945",
    "postTime": "2024-10-10 07:46:25",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142799916,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799916",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 796,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799916",
    "postTime": "2024-10-10 07:46:19",
    "diggCount": 18,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142799950,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799950",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 786,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799950",
    "postTime": "2024-10-10 07:46:14",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142799935,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799935",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 903,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799935",
    "postTime": "2024-10-10 07:46:10",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142799944,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799944",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 802,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799944",
    "postTime": "2024-10-10 07:46:07",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142799928,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799928",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 674,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799928",
    "postTime": "2024-10-10 07:46:02",
    "diggCount": 21,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142799936,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799936",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 971,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799936",
    "postTime": "2024-10-10 07:45:59",
    "diggCount": 16,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142799956,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799956",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 707,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799956",
    "postTime": "2024-10-10 07:45:55",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142799924,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799924",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 439,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799924",
    "postTime": "2024-10-10 07:45:51",
    "diggCount": 13,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142799912,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799912",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 518,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799912",
    "postTime": "2024-10-10 00:47:37",
    "diggCount": 20,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142799905,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799905",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 736,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799905",
    "postTime": "2024-10-10 00:46:59",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142799892,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799892",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 569,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799892",
    "postTime": "2024-10-10 00:46:53",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142799896,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799896",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 522,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799896",
    "postTime": "2024-10-10 00:46:49",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142799883,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142799883",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 832,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799883",
    "postTime": "2024-10-10 00:46:40",
    "diggCount": 21,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/92e7a463dcbd4367899c0afc22fc7f84.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142700508,
    "title": "洋钱罐高频编程考题：二叉树的右视图（中等）",
    "description": "要从二叉树的右侧查看并返回节点值，我们可以使用层序遍历（广度优先遍历）来实现。具体来说，我们需要从右侧依次访问每一层的节点，并从每一层的最右侧节点开始返回结果。，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700508",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700508",
    "postTime": "2024-10-04 10:24:08",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b6e4941ea10b490a8db4b67f420a3305.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700502,
    "title": "洋钱罐高频编程考题：二叉搜索树中第 K 小的元素（中等）",
    "description": "小元素，我们可以利用 BST 的中序遍历特性。中序遍历 BST 会以升序方式访问所有节点，因此第。：中序遍历 BST 的结果是一个升序排列的节点值列表。可以使用递归或迭代的方式进行中序遍历。：在遍历过程中，维护一个计数器来记录已经遍历的节点数量，当计数器等于。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第。要查找二叉搜索树（BST）中的第。小的元素就是中序遍历结果中的第。小的元素（从 1 开始计数）。给定一个二叉搜索树的根节点。小的值，你将如何优化算法？时，返回当前节点的值。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700502",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700502",
    "postTime": "2024-10-04 10:23:34",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7be7b92a469348fe9165d76356a1a0fc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700492,
    "title": "洋钱罐高频编程考题：验证二叉搜索树（中等）",
    "description": "根节点的值是 5 ，但是右子节点的值是 4。，判断其是否是一个有效的二叉搜索树。给你一个二叉树的根节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700492",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 409,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700492",
    "postTime": "2024-10-04 10:22:59",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/33d363efcf4c482ab02d62a67441d97d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700485,
    "title": "洋钱罐高频编程考题：将有序数组转换为二叉搜索树（简单）",
    "description": "要将一个升序排列的整数数组转换为一棵平衡二叉搜索树（BST），我们可以利用递归方法构建树。这是因为一个平衡的BST的中序遍历应该是升序排列的，因此我们可以通过递归的方式选择中间的元素作为根节点，递归构建左右子树，从而保持平衡。：由于数组已经是升序排列的，选择中间元素作为根节点可以保证树的高度平衡。[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。排列，请你将其转换为一棵 平衡 二叉搜索树。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700485",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 424,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700485",
    "postTime": "2024-10-04 10:22:28",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f674c50e28b4432a9ebe786a773e0764.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700478,
    "title": "洋钱罐高频编程考题：二叉树的层序遍历（中等）",
    "description": "层序遍历（二叉树的宽度优先遍历）可以使用队列（FIFO）来实现。我们逐层遍历树中的节点，每次处理一层的所有节点，并将它们的子节点加入队列中。（即逐层地，从左到右访问所有节点）。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700478",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 241,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700478",
    "postTime": "2024-10-04 10:21:51",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a728c2c3636420b9248f8fe0400e427.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700472,
    "title": "洋钱罐高频编程考题：二叉树的直径（简单）",
    "description": "要找到二叉树的直径，我们需要找到树中任意两个节点之间的最长路径。：直径是树中两个节点之间最长的路径长度。这个路径可能会经过树的根节点，也可能不会。3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。因此，整体的空间复杂度主要由递归栈的深度决定，对于最坏情况下是。：通过递归计算每个节点的左右子树的深度，返回节点的最大深度。这条路径可能经过也可能不经过根节点。是指树中任意两个节点之间最长路径的。给你一棵二叉树的根节点，返回该树的。由它们之间边数表示。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700472",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700472",
    "postTime": "2024-10-04 10:21:19",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/82d34823cc444d24b5582f303808b59d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700464,
    "title": "洋钱罐高频编程考题：对称二叉树（简单）",
    "description": "要检查一个二叉树是否是轴对称的，我们可以使用递归或迭代的方法。这里提供了两种方法的解题思路和复杂度分析。：可以使用队列来模拟递归检查过程，通过层次遍历来比较每层的节点对称性。：我们需要检查左右子树是否对称。你可以运用递归和迭代两种方法解决这个问题吗？给你一个二叉树的根节点。， 检查它是否轴对称。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 488,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700464",
    "postTime": "2024-10-04 10:20:32",
    "diggCount": 12,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f1d3ad76cc91463f8ff63d44ab93ecfa.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142700458,
    "title": "洋钱罐高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700458",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 416,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700458",
    "postTime": "2024-10-04 10:20:01",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142700453,
    "title": "洋钱罐高频编程考题：二叉树的最大深度（简单）",
    "description": "是指从根节点到最远叶子节点的最长路径上的节点数。递归方法较为简洁直观。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700453",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 185,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700453",
    "postTime": "2024-10-04 10:19:31",
    "diggCount": 6,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caef40e28a5e46a09db40b2d1e1b1cab.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700426,
    "title": "洋钱罐高频编程考题：二叉树的中序遍历（简单）",
    "description": "要实现二叉树的中序遍历，最常见的方式是使用递归。递归算法很简单，你可以通过迭代算法完成吗？迭代方法使用栈来替代递归。给定一个二叉树的根节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700426",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700426",
    "postTime": "2024-10-04 10:17:12",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f3ef3b4a0148408e818b215f1792b710.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700421,
    "title": "洋钱罐高频编程考题：LRU 缓存（中等）",
    "description": "/ 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.put(4, 4);// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}// 缓存是 {1=1, 2=2}要实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，可以使用。// 返回 -1 (未找到)lRUCache.get(1);// 返回 -1 (未找到)lRUCache.put(1, 1);// 缓存是 {1=1}lRUCache.get(1);",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700421",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 527,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700421",
    "postTime": "2024-10-04 10:16:37",
    "diggCount": 23,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c37c6a5ba9734596a43ad012b2d6b2ef.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142700416,
    "title": "洋钱罐高频编程考题：合并 K 个升序链表 （困难）",
    "description": "对于每个节点的插入和删除操作，优先队列的时间复杂度为 O(log k)，其中 k 是链表的数量。总的时间复杂度为 O(N log k)，其中 N 是所有节点的总数。要将多个有序链表合并成一个有序链表，可以使用优先队列（最小堆）来实现，这样能够有效地将多个链表中的最小节点逐步合并，最终形成一个有序的链表。：空间复杂度主要取决于优先队列的存储空间，最坏情况下为 O(k)。请你将所有链表合并到一个升序链表中，返回合并后的链表。给你一个链表数组，每个链表都已经按升序排列。将它们合并到一个有序链表中得到。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700416",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 233,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700416",
    "postTime": "2024-10-04 10:16:06",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/751dafd55ff34389bdf5fe2439f17feb.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700410,
    "title": "洋钱罐高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700410",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 303,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700410",
    "postTime": "2024-10-04 10:15:33",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700399,
    "title": "洋钱罐高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700399",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 546,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700399",
    "postTime": "2024-10-04 10:15:01",
    "diggCount": 13,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700386,
    "title": "洋钱罐高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142700386",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700386",
    "postTime": "2024-10-04 10:14:29",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142697258,
    "title": "洋钱罐高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697258",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 349,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697258",
    "postTime": "2024-10-03 22:33:12",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142697250,
    "title": "高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697250",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 371,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697250",
    "postTime": "2024-10-03 22:32:33",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697243,
    "title": "洋钱罐高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697243",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697243",
    "postTime": "2024-10-03 22:31:57",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142697241,
    "title": "洋钱罐高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697241",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 350,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697241",
    "postTime": "2024-10-03 22:31:19",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697233,
    "title": "洋钱罐高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697233",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1030,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697233",
    "postTime": "2024-10-03 22:30:46",
    "diggCount": 13,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142685629,
    "title": "洋钱罐高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685629",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685629",
    "postTime": "2024-10-02 21:41:07",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685623,
    "title": "洋钱罐高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685623",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 219,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685623",
    "postTime": "2024-10-02 21:40:34",
    "diggCount": 8,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685616,
    "title": "洋钱罐高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685616",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 237,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685616",
    "postTime": "2024-10-02 21:40:03",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685610,
    "title": "洋钱罐高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685610",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 314,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685610",
    "postTime": "2024-10-02 21:39:27",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685595,
    "title": "洋钱罐高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685595",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 327,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685595",
    "postTime": "2024-10-02 21:38:39",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142697225,
    "title": "洋钱罐高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697225",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697225",
    "postTime": "2024-10-03 22:30:16",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142697220,
    "title": "洋钱罐高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697220",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1048,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697220",
    "postTime": "2024-10-03 22:29:40",
    "diggCount": 26,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142697212,
    "title": "洋钱罐高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697212",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697212",
    "postTime": "2024-10-03 22:29:07",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697203,
    "title": "洋钱罐高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697203",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 285,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697203",
    "postTime": "2024-10-03 22:28:37",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142697195,
    "title": "洋钱罐高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697195",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 251,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697195",
    "postTime": "2024-10-03 22:28:03",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142697193,
    "title": "洋钱罐高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697193",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 340,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697193",
    "postTime": "2024-10-03 22:27:31",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697184,
    "title": "洋钱罐高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697184",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 133,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697184",
    "postTime": "2024-10-03 22:26:58",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142697178,
    "title": "洋钱罐高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697178",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 416,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697178",
    "postTime": "2024-10-03 22:26:26",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697172,
    "title": "洋钱罐高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697172",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 213,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697172",
    "postTime": "2024-10-03 22:25:50",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142697167,
    "title": "洋钱罐高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142697167",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 153,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697167",
    "postTime": "2024-10-03 22:25:13",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142685725,
    "title": "洋钱罐高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685725",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 264,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685725",
    "postTime": "2024-10-02 21:47:16",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142685716,
    "title": "洋钱罐高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685716",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 235,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685716",
    "postTime": "2024-10-02 21:46:40",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685712,
    "title": "洋钱罐高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685712",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 260,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685712",
    "postTime": "2024-10-02 21:46:08",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685693,
    "title": "洋钱罐高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685693",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 391,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685693",
    "postTime": "2024-10-02 21:45:29",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142685684,
    "title": "洋钱罐高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685684",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 246,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685684",
    "postTime": "2024-10-02 21:44:52",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685673,
    "title": "洋钱罐高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685673",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685673",
    "postTime": "2024-10-02 21:44:18",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142685664,
    "title": "洋钱罐高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685664",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 363,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685664",
    "postTime": "2024-10-02 21:43:43",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685659,
    "title": "洋钱罐高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685659",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 237,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685659",
    "postTime": "2024-10-02 21:43:07",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142685649,
    "title": "洋钱罐高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685649",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 220,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685649",
    "postTime": "2024-10-02 21:42:37",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685639,
    "title": "洋钱罐高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/LJ11111111111111/article/details/142685639",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 248,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685639",
    "postTime": "2024-10-02 21:42:01",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142934693,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934693",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 537,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934693",
    "postTime": "2024-10-16 08:06:09",
    "diggCount": 20,
    "formatTime": "前天 08:06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142934820,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934820",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 508,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934820",
    "postTime": "2024-10-16 08:06:05",
    "diggCount": 14,
    "formatTime": "前天 08:06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142934844,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934844",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 663,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934844",
    "postTime": "2024-10-16 08:06:01",
    "diggCount": 6,
    "formatTime": "前天 08:06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142934754,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934754",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 730,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934754",
    "postTime": "2024-10-16 08:05:57",
    "diggCount": 10,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142934843,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934843",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 461,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934843",
    "postTime": "2024-10-16 08:05:54",
    "diggCount": 17,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142934788,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934788",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 444,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934788",
    "postTime": "2024-10-16 08:05:50",
    "diggCount": 14,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142934723,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934723",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 760,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934723",
    "postTime": "2024-10-16 08:05:46",
    "diggCount": 15,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142934789,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934789",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 798,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934789",
    "postTime": "2024-10-16 08:05:43",
    "diggCount": 11,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142934722,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934722",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 768,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934722",
    "postTime": "2024-10-16 08:05:39",
    "diggCount": 8,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142934662,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934662",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 565,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934662",
    "postTime": "2024-10-16 08:05:34",
    "diggCount": 11,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142934663,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934663",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 599,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934663",
    "postTime": "2024-10-16 08:05:30",
    "diggCount": 21,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142934638,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934638",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 623,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934638",
    "postTime": "2024-10-16 08:05:26",
    "diggCount": 18,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142934607,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934607",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 878,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934607",
    "postTime": "2024-10-16 08:05:21",
    "diggCount": 12,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142934582,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934582",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 610,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934582",
    "postTime": "2024-10-16 08:05:08",
    "diggCount": 20,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142934554,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142934554",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 515,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142934554",
    "postTime": "2024-10-16 08:05:03",
    "diggCount": 10,
    "formatTime": "前天 08:05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142897240,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897240",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 365,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897240",
    "postTime": "2024-10-13 13:26:52",
    "diggCount": 11,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897212,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897212",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897212",
    "postTime": "2024-10-13 13:26:49",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897189,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897189",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 263,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897189",
    "postTime": "2024-10-13 13:26:47",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897180,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897180",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 272,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897180",
    "postTime": "2024-10-13 13:26:44",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897220,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897220",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 353,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897220",
    "postTime": "2024-10-13 13:26:42",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142897200,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897200",
    "postTime": "2024-10-13 13:26:40",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142897199,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897199",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 241,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897199",
    "postTime": "2024-10-13 13:26:37",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897162,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897162",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897162",
    "postTime": "2024-10-13 13:26:35",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897163,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897163",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 206,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897163",
    "postTime": "2024-10-13 13:26:32",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897149,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897149",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 389,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897149",
    "postTime": "2024-10-13 13:26:30",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142897135,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897135",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 261,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897135",
    "postTime": "2024-10-13 13:26:27",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142897124,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897124",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 274,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897124",
    "postTime": "2024-10-13 13:26:25",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897125,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897125",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 332,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897125",
    "postTime": "2024-10-13 13:26:22",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142897113,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897113",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 229,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897113",
    "postTime": "2024-10-13 13:26:18",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897255,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142897255",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897255",
    "postTime": "2024-10-13 13:26:15",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142877650,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877650",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 153,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877650",
    "postTime": "2024-10-12 14:59:20",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877607,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877607",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 195,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877607",
    "postTime": "2024-10-12 14:59:15",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877578,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877578",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 174,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877578",
    "postTime": "2024-10-12 14:59:11",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877874,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877874",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 227,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877874",
    "postTime": "2024-10-12 14:59:08",
    "diggCount": 8,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877813,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877813",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 180,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877813",
    "postTime": "2024-10-12 14:59:05",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877840,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877840",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 103,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877840",
    "postTime": "2024-10-12 14:59:02",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877839,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877839",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 108,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877839",
    "postTime": "2024-10-12 14:59:00",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877841,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877841",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 131,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877841",
    "postTime": "2024-10-12 14:58:57",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877661,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877661",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 173,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877661",
    "postTime": "2024-10-12 14:58:54",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877630,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877630",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877630",
    "postTime": "2024-10-12 14:58:51",
    "diggCount": 7,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877595,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877595",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 191,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877595",
    "postTime": "2024-10-12 14:58:49",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877734,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877734",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 144,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877734",
    "postTime": "2024-10-12 14:58:44",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877695,
    "title": "FairSync extends Sync 线程抢锁分析3​直接代码中分析",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3​直接代码中分析。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877695",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 124,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877695",
    "postTime": "2024-10-12 14:58:40",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878324,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142878324",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 129,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878324",
    "postTime": "2024-10-12 14:58:37",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142877556,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142877556",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 178,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142877556",
    "postTime": "2024-10-12 14:36:53",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a64cc63065d404381f85363fe1df594.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142806553,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806553",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 505,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806553",
    "postTime": "2024-10-10 08:07:51",
    "diggCount": 12,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142806168,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806168",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 441,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806168",
    "postTime": "2024-10-10 08:07:47",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142806394,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806394",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 515,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806394",
    "postTime": "2024-10-10 08:07:43",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142806304,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 592,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806304",
    "postTime": "2024-10-10 08:07:40",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142806660,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806660",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 825,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806660",
    "postTime": "2024-10-10 08:07:36",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142806606,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806606",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 826,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806606",
    "postTime": "2024-10-10 08:07:32",
    "diggCount": 6,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142806485,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806485",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 666,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806485",
    "postTime": "2024-10-10 08:02:02",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142806396,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806396",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806396",
    "postTime": "2024-10-10 08:01:59",
    "diggCount": 15,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142806395,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806395",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 436,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806395",
    "postTime": "2024-10-10 08:01:52",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142806049,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142806049",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 662,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142806049",
    "postTime": "2024-10-10 08:01:48",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142805960,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142805960",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 664,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142805960",
    "postTime": "2024-10-10 07:56:45",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142805869,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142805869",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 635,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142805869",
    "postTime": "2024-10-10 07:55:38",
    "diggCount": 13,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142805775,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142805775",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 474,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142805775",
    "postTime": "2024-10-10 07:55:35",
    "diggCount": 6,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142805677,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析23",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142805677",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 609,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142805677",
    "postTime": "2024-10-10 07:55:31",
    "diggCount": 21,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142805476,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142805476",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 950,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142805476",
    "postTime": "2024-10-10 07:55:28",
    "diggCount": 12,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4578e0a1218a47d985b185c4c7ea2890.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142697120,
    "title": "58同城高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697120",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697120",
    "postTime": "2024-10-03 22:20:46",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142697109,
    "title": "58同城高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697109",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 235,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697109",
    "postTime": "2024-10-03 22:20:09",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142697105,
    "title": "58同城高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697105",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697105",
    "postTime": "2024-10-03 22:19:35",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697098,
    "title": "58同城高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697098",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 725,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697098",
    "postTime": "2024-10-03 22:19:01",
    "diggCount": 19,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142697094,
    "title": "58同城高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697094",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 321,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697094",
    "postTime": "2024-10-03 22:18:30",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697084,
    "title": "58同城高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697084",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 660,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697084",
    "postTime": "2024-10-03 22:17:54",
    "diggCount": 15,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142697075,
    "title": "58同城高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697075",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697075",
    "postTime": "2024-10-03 22:17:22",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697068,
    "title": "58同城高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697068",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 286,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697068",
    "postTime": "2024-10-03 22:16:33",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142697059,
    "title": "58同城高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697059",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 312,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697059",
    "postTime": "2024-10-03 22:15:56",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697051,
    "title": "58同城高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697051",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697051",
    "postTime": "2024-10-03 22:15:07",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685539,
    "title": "58同城高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685539",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685539",
    "postTime": "2024-10-02 21:33:24",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685533,
    "title": "58同城高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685533",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 337,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685533",
    "postTime": "2024-10-02 21:32:49",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685525,
    "title": "58同城高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685525",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 143,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685525",
    "postTime": "2024-10-02 21:32:17",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142685516,
    "title": "59同城高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685516",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 165,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685516",
    "postTime": "2024-10-02 21:31:37",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142685505,
    "title": "58同城高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685505",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685505",
    "postTime": "2024-10-02 21:30:46",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142685498,
    "title": "58同城高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685498",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 268,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685498",
    "postTime": "2024-10-02 21:30:02",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142685492,
    "title": "58同城高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685492",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685492",
    "postTime": "2024-10-02 21:29:30",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685486,
    "title": "58同城高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685486",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685486",
    "postTime": "2024-10-02 21:28:59",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685479,
    "title": "58同城高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685479",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 373,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685479",
    "postTime": "2024-10-02 21:28:17",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685470,
    "title": "58同城高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685470",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685470",
    "postTime": "2024-10-02 21:27:12",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685465,
    "title": "58同城高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685465",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 395,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685465",
    "postTime": "2024-10-02 21:26:37",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685459,
    "title": "高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685459",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685459",
    "postTime": "2024-10-02 21:25:59",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685450,
    "title": "58同城高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685450",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685450",
    "postTime": "2024-10-02 21:25:19",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685443,
    "title": "58同城高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685443",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 246,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685443",
    "postTime": "2024-10-02 21:24:41",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685433,
    "title": "58同城高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142685433",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 405,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685433",
    "postTime": "2024-10-02 21:23:58",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700667,
    "title": "58同城高频编程考题：二叉树的右视图（中等）",
    "description": "要从二叉树的右侧查看并返回节点值，我们可以使用层序遍历（广度优先遍历）来实现。具体来说，我们需要从右侧依次访问每一层的节点，并从每一层的最右侧节点开始返回结果。，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700667",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 258,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700667",
    "postTime": "2024-10-04 10:35:44",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b6e4941ea10b490a8db4b67f420a3305.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700660,
    "title": "59同城高频编程考题：二叉搜索树中第 K 小的元素（中等）",
    "description": "小元素，我们可以利用 BST 的中序遍历特性。中序遍历 BST 会以升序方式访问所有节点，因此第。：中序遍历 BST 的结果是一个升序排列的节点值列表。可以使用递归或迭代的方式进行中序遍历。：在遍历过程中，维护一个计数器来记录已经遍历的节点数量，当计数器等于。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第。要查找二叉搜索树（BST）中的第。小的元素就是中序遍历结果中的第。小的元素（从 1 开始计数）。给定一个二叉搜索树的根节点。小的值，你将如何优化算法？时，返回当前节点的值。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700660",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 234,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700660",
    "postTime": "2024-10-04 10:35:06",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7be7b92a469348fe9165d76356a1a0fc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142700650,
    "title": "58同城高频编程考题：验证二叉搜索树（中等）",
    "description": "根节点的值是 5 ，但是右子节点的值是 4。，判断其是否是一个有效的二叉搜索树。给你一个二叉树的根节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700650",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700650",
    "postTime": "2024-10-04 10:34:08",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/33d363efcf4c482ab02d62a67441d97d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700643,
    "title": "58同城高频编程考题：将有序数组转换为二叉搜索树（简单）",
    "description": "要将一个升序排列的整数数组转换为一棵平衡二叉搜索树（BST），我们可以利用递归方法构建树。这是因为一个平衡的BST的中序遍历应该是升序排列的，因此我们可以通过递归的方式选择中间的元素作为根节点，递归构建左右子树，从而保持平衡。：由于数组已经是升序排列的，选择中间元素作为根节点可以保证树的高度平衡。[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。排列，请你将其转换为一棵 平衡 二叉搜索树。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700643",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 320,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700643",
    "postTime": "2024-10-04 10:33:35",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f674c50e28b4432a9ebe786a773e0764.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142700633,
    "title": "58同城高频编程考题：二叉树的层序遍历（中等）",
    "description": "层序遍历（二叉树的宽度优先遍历）可以使用队列（FIFO）来实现。我们逐层遍历树中的节点，每次处理一层的所有节点，并将它们的子节点加入队列中。（即逐层地，从左到右访问所有节点）。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700633",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700633",
    "postTime": "2024-10-04 10:32:57",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a728c2c3636420b9248f8fe0400e427.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700628,
    "title": "58同城高频编程考题：二叉树的直径（简单）",
    "description": "要找到二叉树的直径，我们需要找到树中任意两个节点之间的最长路径。：直径是树中两个节点之间最长的路径长度。这个路径可能会经过树的根节点，也可能不会。3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。因此，整体的空间复杂度主要由递归栈的深度决定，对于最坏情况下是。：通过递归计算每个节点的左右子树的深度，返回节点的最大深度。这条路径可能经过也可能不经过根节点。是指树中任意两个节点之间最长路径的。给你一棵二叉树的根节点，返回该树的。由它们之间边数表示。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700628",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 416,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700628",
    "postTime": "2024-10-04 10:32:24",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/82d34823cc444d24b5582f303808b59d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142700604,
    "title": "58同城高频编程考题：对称二叉树（简单）",
    "description": "要检查一个二叉树是否是轴对称的，我们可以使用递归或迭代的方法。这里提供了两种方法的解题思路和复杂度分析。：可以使用队列来模拟递归检查过程，通过层次遍历来比较每层的节点对称性。：我们需要检查左右子树是否对称。你可以运用递归和迭代两种方法解决这个问题吗？给你一个二叉树的根节点。， 检查它是否轴对称。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700604",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 502,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700604",
    "postTime": "2024-10-04 10:30:49",
    "diggCount": 12,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f1d3ad76cc91463f8ff63d44ab93ecfa.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142700595,
    "title": "洋钱罐高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700595",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700595",
    "postTime": "2024-10-04 10:30:14",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142700584,
    "title": "58同城高频编程考题：二叉树的最大深度（简单）",
    "description": "是指从根节点到最远叶子节点的最长路径上的节点数。递归方法较为简洁直观。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700584",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700584",
    "postTime": "2024-10-04 10:29:44",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caef40e28a5e46a09db40b2d1e1b1cab.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142700576,
    "title": "58同城高频编程考题：二叉树的中序遍历（简单）",
    "description": "要实现二叉树的中序遍历，最常见的方式是使用递归。递归算法很简单，你可以通过迭代算法完成吗？迭代方法使用栈来替代递归。给定一个二叉树的根节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700576",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 336,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700576",
    "postTime": "2024-10-04 10:29:09",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f3ef3b4a0148408e818b215f1792b710.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700565,
    "title": "58同城高频编程考题：LRU 缓存（中等）",
    "description": "/ 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.put(4, 4);// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}// 缓存是 {1=1, 2=2}要实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，可以使用。// 返回 -1 (未找到)lRUCache.get(1);// 返回 -1 (未找到)lRUCache.put(1, 1);// 缓存是 {1=1}lRUCache.get(1);",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700565",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 628,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700565",
    "postTime": "2024-10-04 10:28:34",
    "diggCount": 23,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c37c6a5ba9734596a43ad012b2d6b2ef.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700560,
    "title": "58同城高频编程考题：合并 K 个升序链表 （困难）",
    "description": "对于每个节点的插入和删除操作，优先队列的时间复杂度为 O(log k)，其中 k 是链表的数量。总的时间复杂度为 O(N log k)，其中 N 是所有节点的总数。要将多个有序链表合并成一个有序链表，可以使用优先队列（最小堆）来实现，这样能够有效地将多个链表中的最小节点逐步合并，最终形成一个有序的链表。：空间复杂度主要取决于优先队列的存储空间，最坏情况下为 O(k)。请你将所有链表合并到一个升序链表中，返回合并后的链表。给你一个链表数组，每个链表都已经按升序排列。将它们合并到一个有序链表中得到。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700560",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 408,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700560",
    "postTime": "2024-10-04 10:28:03",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/751dafd55ff34389bdf5fe2439f17feb.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700555,
    "title": "58同城高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700555",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 313,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700555",
    "postTime": "2024-10-04 10:27:32",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700549,
    "title": "58同城高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700549",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 462,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700549",
    "postTime": "2024-10-04 10:27:01",
    "diggCount": 19,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142700540,
    "title": "58同城高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142700540",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700540",
    "postTime": "2024-10-04 10:26:27",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697155,
    "title": "58同城高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697155",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 258,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697155",
    "postTime": "2024-10-03 22:23:30",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142697147,
    "title": "58同城高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697147",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 164,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697147",
    "postTime": "2024-10-03 22:22:56",
    "diggCount": 10,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142697142,
    "title": "58同城高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697142",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 234,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697142",
    "postTime": "2024-10-03 22:22:25",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142697134,
    "title": "58同城高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697134",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 177,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697134",
    "postTime": "2024-10-03 22:21:50",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697125,
    "title": "58同城高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/DJV2980765/article/details/142697125",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697125",
    "postTime": "2024-10-03 22:21:16",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142993388,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993388",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 784,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993388",
    "postTime": "2024-10-16 22:35:13",
    "diggCount": 9,
    "formatTime": "前天 22:35",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142993258,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993258",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 535,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993258",
    "postTime": "2024-10-16 22:34:31",
    "diggCount": 15,
    "formatTime": "前天 22:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142993369,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993369",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 611,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993369",
    "postTime": "2024-10-16 22:34:27",
    "diggCount": 16,
    "formatTime": "前天 22:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142993358,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993358",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 481,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993358",
    "postTime": "2024-10-16 22:33:51",
    "diggCount": 11,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142993328,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993328",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 353,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993328",
    "postTime": "2024-10-16 22:33:46",
    "diggCount": 18,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142993273,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993273",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 549,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993273",
    "postTime": "2024-10-16 22:33:43",
    "diggCount": 6,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142993291,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993291",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 370,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993291",
    "postTime": "2024-10-16 22:33:40",
    "diggCount": 19,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142993309,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993309",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 564,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993309",
    "postTime": "2024-10-16 22:33:36",
    "diggCount": 9,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142993233,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993233",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 688,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993233",
    "postTime": "2024-10-16 22:33:19",
    "diggCount": 10,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142993343,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993343",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 625,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993343",
    "postTime": "2024-10-16 22:33:15",
    "diggCount": 19,
    "formatTime": "前天 22:33",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142993214,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993214",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 704,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993214",
    "postTime": "2024-10-16 22:29:21",
    "diggCount": 15,
    "formatTime": "前天 22:29",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142993167,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993167",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 589,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993167",
    "postTime": "2024-10-16 22:28:17",
    "diggCount": 14,
    "formatTime": "前天 22:28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142993192,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993192",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 566,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993192",
    "postTime": "2024-10-16 22:28:13",
    "diggCount": 7,
    "formatTime": "前天 22:28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142993144,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993144",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 422,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993144",
    "postTime": "2024-10-16 22:28:09",
    "diggCount": 17,
    "formatTime": "前天 22:28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142993129,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142993129",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 439,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993129",
    "postTime": "2024-10-16 22:28:04",
    "diggCount": 9,
    "formatTime": "前天 22:28",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142897437,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897437",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897437",
    "postTime": "2024-10-13 13:52:20",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142897490,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897490",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 277,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897490",
    "postTime": "2024-10-13 13:52:17",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897478,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897478",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 261,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897478",
    "postTime": "2024-10-13 13:52:13",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897465,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897465",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 231,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897465",
    "postTime": "2024-10-13 13:52:10",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897454,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897454",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 302,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897454",
    "postTime": "2024-10-13 13:52:04",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897505,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897505",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 306,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897505",
    "postTime": "2024-10-13 13:52:01",
    "diggCount": 10,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897491,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897491",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897491",
    "postTime": "2024-10-13 13:51:58",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897447,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897447",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897447",
    "postTime": "2024-10-13 13:51:55",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897495,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897495",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897495",
    "postTime": "2024-10-13 13:51:53",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897466,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897466",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 365,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897466",
    "postTime": "2024-10-13 13:51:50",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142897419,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897419",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897419",
    "postTime": "2024-10-13 13:51:47",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897426,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897426",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897426",
    "postTime": "2024-10-13 13:51:44",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142897411,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897411",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 352,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897411",
    "postTime": "2024-10-13 13:51:41",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897398,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897398",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 384,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897398",
    "postTime": "2024-10-13 13:51:37",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142897374,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142897374",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 204,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897374",
    "postTime": "2024-10-13 13:51:33",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142878529,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878529",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 156,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878529",
    "postTime": "2024-10-12 15:23:55",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878495,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878495",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 202,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878495",
    "postTime": "2024-10-12 15:23:52",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878657,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878657",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 171,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878657",
    "postTime": "2024-10-12 15:23:50",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878685,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878685",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 143,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878685",
    "postTime": "2024-10-12 15:23:47",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878716,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878716",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 86,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878716",
    "postTime": "2024-10-12 15:23:45",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878659,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878659",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 113,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878659",
    "postTime": "2024-10-12 15:23:42",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878624,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878624",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 112,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878624",
    "postTime": "2024-10-12 15:23:40",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878658,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 192,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878658",
    "postTime": "2024-10-12 15:23:38",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878583,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878583",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 327,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878583",
    "postTime": "2024-10-12 15:23:31",
    "diggCount": 9,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878545,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878545",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 103,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878545",
    "postTime": "2024-10-12 15:23:28",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878511,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878511",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 205,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878511",
    "postTime": "2024-10-12 15:23:25",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878478,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878478",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 51,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878478",
    "postTime": "2024-10-12 15:23:23",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142879153,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142879153",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 182,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142879153",
    "postTime": "2024-10-12 15:23:20",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878451,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878451",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 169,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878451",
    "postTime": "2024-10-12 15:03:21",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142878468,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142878468",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 93,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142878468",
    "postTime": "2024-10-12 15:03:12",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6396ada809bd44dda60f5259c6cfcb69.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142808655,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808655",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 650,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808655",
    "postTime": "2024-10-10 08:30:36",
    "diggCount": 12,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142808461,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808461",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 651,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808461",
    "postTime": "2024-10-10 08:30:33",
    "diggCount": 6,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142808073,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808073",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 823,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808073",
    "postTime": "2024-10-10 08:30:30",
    "diggCount": 13,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142807980,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807980",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 842,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807980",
    "postTime": "2024-10-10 08:30:27",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142808560,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808560",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 920,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808560",
    "postTime": "2024-10-10 08:30:25",
    "diggCount": 22,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142808756,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808756",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 734,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808756",
    "postTime": "2024-10-10 08:30:22",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142808168,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808168",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 663,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808168",
    "postTime": "2024-10-10 08:30:19",
    "diggCount": 20,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142808268,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808268",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 702,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808268",
    "postTime": "2024-10-10 08:30:03",
    "diggCount": 5,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142808559,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808559",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 881,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808559",
    "postTime": "2024-10-10 08:30:00",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142808334,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142808334",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 914,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142808334",
    "postTime": "2024-10-10 08:29:57",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142807829,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807829",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 825,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807829",
    "postTime": "2024-10-10 08:20:48",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142807733,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807733",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 429,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807733",
    "postTime": "2024-10-10 08:20:45",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142807632,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807632",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 788,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807632",
    "postTime": "2024-10-10 08:20:42",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142807535,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807535",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 952,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807535",
    "postTime": "2024-10-10 08:20:38",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142807428,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142807428",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 828,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142807428",
    "postTime": "2024-10-10 08:20:33",
    "diggCount": 29,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7a71caba0bce496c9d42f5ab6dcde12c.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700817,
    "title": "抖音高频编程考题：二叉树的右视图（中等）",
    "description": "要从二叉树的右侧查看并返回节点值，我们可以使用层序遍历（广度优先遍历）来实现。具体来说，我们需要从右侧依次访问每一层的节点，并从每一层的最右侧节点开始返回结果。，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700817",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 409,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700817",
    "postTime": "2024-10-04 10:47:45",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b6e4941ea10b490a8db4b67f420a3305.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142700810,
    "title": "抖音高频编程考题：二叉搜索树中第 K 小的元素（中等）",
    "description": "小元素，我们可以利用 BST 的中序遍历特性。中序遍历 BST 会以升序方式访问所有节点，因此第。：中序遍历 BST 的结果是一个升序排列的节点值列表。可以使用递归或迭代的方式进行中序遍历。：在遍历过程中，维护一个计数器来记录已经遍历的节点数量，当计数器等于。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第。要查找二叉搜索树（BST）中的第。小的元素就是中序遍历结果中的第。小的元素（从 1 开始计数）。给定一个二叉搜索树的根节点。小的值，你将如何优化算法？时，返回当前节点的值。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700810",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700810",
    "postTime": "2024-10-04 10:47:11",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7be7b92a469348fe9165d76356a1a0fc.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700791,
    "title": "抖音高频编程考题：验证二叉搜索树（中等）",
    "description": "根节点的值是 5 ，但是右子节点的值是 4。，判断其是否是一个有效的二叉搜索树。给你一个二叉树的根节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700791",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 274,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700791",
    "postTime": "2024-10-04 10:45:49",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/33d363efcf4c482ab02d62a67441d97d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700773,
    "title": "抖音高频编程考题：将有序数组转换为二叉搜索树（简单）",
    "description": "要将一个升序排列的整数数组转换为一棵平衡二叉搜索树（BST），我们可以利用递归方法构建树。这是因为一个平衡的BST的中序遍历应该是升序排列的，因此我们可以通过递归的方式选择中间的元素作为根节点，递归构建左右子树，从而保持平衡。：由于数组已经是升序排列的，选择中间元素作为根节点可以保证树的高度平衡。[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。排列，请你将其转换为一棵 平衡 二叉搜索树。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700773",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 431,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700773",
    "postTime": "2024-10-04 10:44:01",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f674c50e28b4432a9ebe786a773e0764.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700763,
    "title": "抖音高频编程考题：二叉树的层序遍历（中等）",
    "description": "层序遍历（二叉树的宽度优先遍历）可以使用队列（FIFO）来实现。我们逐层遍历树中的节点，每次处理一层的所有节点，并将它们的子节点加入队列中。（即逐层地，从左到右访问所有节点）。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700763",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700763",
    "postTime": "2024-10-04 10:43:26",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a728c2c3636420b9248f8fe0400e427.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700756,
    "title": "抖音高频编程考题：对称二叉树（简单）",
    "description": "要检查一个二叉树是否是轴对称的，我们可以使用递归或迭代的方法。这里提供了两种方法的解题思路和复杂度分析。：可以使用队列来模拟递归检查过程，通过层次遍历来比较每层的节点对称性。：我们需要检查左右子树是否对称。你可以运用递归和迭代两种方法解决这个问题吗？给你一个二叉树的根节点。， 检查它是否轴对称。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700756",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 825,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700756",
    "postTime": "2024-10-04 10:42:55",
    "diggCount": 13,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f1d3ad76cc91463f8ff63d44ab93ecfa.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700748,
    "title": "抖音高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700748",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 406,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700748",
    "postTime": "2024-10-04 10:42:21",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142700742,
    "title": "抖音高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700742",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 394,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700742",
    "postTime": "2024-10-04 10:41:50",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700738,
    "title": "抖音高频编程考题：二叉树的最大深度（简单）",
    "description": "是指从根节点到最远叶子节点的最长路径上的节点数。递归方法较为简洁直观。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700738",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 273,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700738",
    "postTime": "2024-10-04 10:41:18",
    "diggCount": 9,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caef40e28a5e46a09db40b2d1e1b1cab.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142700732,
    "title": "抖音高频编程考题：二叉树的中序遍历（简单）",
    "description": "要实现二叉树的中序遍历，最常见的方式是使用递归。递归算法很简单，你可以通过迭代算法完成吗？迭代方法使用栈来替代递归。给定一个二叉树的根节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700732",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 414,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700732",
    "postTime": "2024-10-04 10:40:41",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f3ef3b4a0148408e818b215f1792b710.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700721,
    "title": "抖音​高频编程考题：LRU 缓存（中等）",
    "description": "/ 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.put(4, 4);// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}// 缓存是 {1=1, 2=2}要实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，可以使用。// 返回 -1 (未找到)lRUCache.get(1);// 返回 -1 (未找到)lRUCache.put(1, 1);// 缓存是 {1=1}lRUCache.get(1);",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700721",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 869,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700721",
    "postTime": "2024-10-04 10:39:56",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c37c6a5ba9734596a43ad012b2d6b2ef.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142700711,
    "title": "抖音高频编程考题：合并 K 个升序链表 （困难）",
    "description": "对于每个节点的插入和删除操作，优先队列的时间复杂度为 O(log k)，其中 k 是链表的数量。总的时间复杂度为 O(N log k)，其中 N 是所有节点的总数。要将多个有序链表合并成一个有序链表，可以使用优先队列（最小堆）来实现，这样能够有效地将多个链表中的最小节点逐步合并，最终形成一个有序的链表。：空间复杂度主要取决于优先队列的存储空间，最坏情况下为 O(k)。请你将所有链表合并到一个升序链表中，返回合并后的链表。给你一个链表数组，每个链表都已经按升序排列。将它们合并到一个有序链表中得到。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700711",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 357,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700711",
    "postTime": "2024-10-04 10:39:12",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/751dafd55ff34389bdf5fe2439f17feb.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700702,
    "title": "抖音高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700702",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 437,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700702",
    "postTime": "2024-10-04 10:38:37",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700694,
    "title": "抖音高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700694",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 838,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700694",
    "postTime": "2024-10-04 10:38:03",
    "diggCount": 11,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700687,
    "title": "抖音高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142700687",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700687",
    "postTime": "2024-10-04 10:37:26",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142697001,
    "title": "抖音高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142697001",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697001",
    "postTime": "2024-10-03 22:10:24",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142696994,
    "title": "抖音高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696994",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696994",
    "postTime": "2024-10-03 22:09:47",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696989,
    "title": "抖音高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696989",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696989",
    "postTime": "2024-10-03 22:09:15",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696930,
    "title": "抖音高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696930",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 436,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696930",
    "postTime": "2024-10-03 22:03:21",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696923,
    "title": "抖音高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696923",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 590,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696923",
    "postTime": "2024-10-03 22:02:47",
    "diggCount": 23,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142696916,
    "title": "抖音高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696916",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696916",
    "postTime": "2024-10-03 22:02:14",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696911,
    "title": "抖音高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696911",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 773,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696911",
    "postTime": "2024-10-03 22:01:43",
    "diggCount": 28,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142696905,
    "title": "抖音高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696905",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 351,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696905",
    "postTime": "2024-10-03 22:01:11",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696899,
    "title": "抖音高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696899",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 166,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696899",
    "postTime": "2024-10-03 22:00:41",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142696889,
    "title": "抖音高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696889",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 409,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696889",
    "postTime": "2024-10-03 22:00:05",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142696884,
    "title": "抖音高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696884",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 384,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696884",
    "postTime": "2024-10-03 21:59:32",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696878,
    "title": "抖音高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696878",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 125,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696878",
    "postTime": "2024-10-03 21:58:58",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142696871,
    "title": "抖音高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696871",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 334,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696871",
    "postTime": "2024-10-03 21:58:22",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142696862,
    "title": "抖音高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696862",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696862",
    "postTime": "2024-10-03 21:57:46",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696852,
    "title": "抖音高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142696852",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 166,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696852",
    "postTime": "2024-10-03 21:57:12",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142685370,
    "title": "抖音高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685370",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 332,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685370",
    "postTime": "2024-10-02 21:18:11",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685361,
    "title": "抖音高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685361",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685361",
    "postTime": "2024-10-02 21:17:35",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685352,
    "title": "抖音高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685352",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 230,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685352",
    "postTime": "2024-10-02 21:16:56",
    "diggCount": 8,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142685340,
    "title": "抖音高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685340",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 154,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685340",
    "postTime": "2024-10-02 21:16:25",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142685331,
    "title": "高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685331",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 251,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685331",
    "postTime": "2024-10-02 21:15:49",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685323,
    "title": "抖音高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685323",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 352,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685323",
    "postTime": "2024-10-02 21:15:17",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685318,
    "title": "抖音高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685318",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685318",
    "postTime": "2024-10-02 21:14:45",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685304,
    "title": "抖音高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 351,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685304",
    "postTime": "2024-10-02 21:14:13",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685299,
    "title": "抖音高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685299",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 269,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685299",
    "postTime": "2024-10-02 21:13:39",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685288,
    "title": "抖音高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685288",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 384,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685288",
    "postTime": "2024-10-02 21:13:06",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142685279,
    "title": "抖音高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685279",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685279",
    "postTime": "2024-10-02 21:12:27",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142685270,
    "title": "抖音高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685270",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 279,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685270",
    "postTime": "2024-10-02 21:11:49",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685261,
    "title": "抖音高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685261",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 436,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685261",
    "postTime": "2024-10-02 21:11:15",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685253,
    "title": "抖音高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685253",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685253",
    "postTime": "2024-10-02 21:10:38",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142685243,
    "title": "抖音高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/pengyou23452/article/details/142685243",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 321,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685243",
    "postTime": "2024-10-02 21:10:01",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142993667,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993667",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 696,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993667",
    "postTime": "2024-10-16 22:51:03",
    "diggCount": 8,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142993655,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993655",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993655",
    "postTime": "2024-10-16 22:50:27",
    "diggCount": 16,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142993634,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993634",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993634",
    "postTime": "2024-10-16 22:50:03",
    "diggCount": 19,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142993644,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993644",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 723,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993644",
    "postTime": "2024-10-16 22:49:53",
    "diggCount": 12,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142993608,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993608",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 723,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993608",
    "postTime": "2024-10-16 22:49:00",
    "diggCount": 15,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142993575,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993575",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 601,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993575",
    "postTime": "2024-10-16 22:48:55",
    "diggCount": 11,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142993590,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993590",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 478,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993590",
    "postTime": "2024-10-16 22:48:52",
    "diggCount": 17,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142993548,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993548",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 709,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993548",
    "postTime": "2024-10-16 22:48:47",
    "diggCount": 16,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142993616,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993616",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 591,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993616",
    "postTime": "2024-10-16 22:48:43",
    "diggCount": 21,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142993556,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993556",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 766,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993556",
    "postTime": "2024-10-16 22:44:35",
    "diggCount": 21,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142993525,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993525",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 543,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993525",
    "postTime": "2024-10-16 22:42:57",
    "diggCount": 24,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142993487,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993487",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 763,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993487",
    "postTime": "2024-10-16 22:42:52",
    "diggCount": 24,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142993510,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993510",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 671,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993510",
    "postTime": "2024-10-16 22:42:47",
    "diggCount": 12,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142993474,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993474",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 463,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993474",
    "postTime": "2024-10-16 22:42:43",
    "diggCount": 23,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142993456,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142993456",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 849,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993456",
    "postTime": "2024-10-16 22:40:08",
    "diggCount": 9,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142897821,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897821",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897821",
    "postTime": "2024-10-13 14:24:27",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142897820,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897820",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 303,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897820",
    "postTime": "2024-10-13 14:24:24",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897819,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897819",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897819",
    "postTime": "2024-10-13 14:24:21",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897848,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897848",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 275,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897848",
    "postTime": "2024-10-13 14:24:18",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897818,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897818",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 250,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897818",
    "postTime": "2024-10-13 14:24:16",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142897928,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897928",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 346,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897928",
    "postTime": "2024-10-13 14:24:13",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897909,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897909",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 387,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897909",
    "postTime": "2024-10-13 14:24:10",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142897863,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897863",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897863",
    "postTime": "2024-10-13 14:24:07",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142897877,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897877",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897877",
    "postTime": "2024-10-13 14:24:05",
    "diggCount": 11,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142897822,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897822",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897822",
    "postTime": "2024-10-13 14:24:03",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142897782,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897782",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 313,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897782",
    "postTime": "2024-10-13 14:24:00",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142897732,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897732",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897732",
    "postTime": "2024-10-13 14:23:57",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142897766,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897766",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 212,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897766",
    "postTime": "2024-10-13 14:23:54",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142897719,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897719",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 367,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897719",
    "postTime": "2024-10-13 14:23:51",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142897708,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142897708",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 278,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142897708",
    "postTime": "2024-10-13 14:23:48",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142884250,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884250",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 136,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884250",
    "postTime": "2024-10-12 19:13:12",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884230,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884230",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 154,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884230",
    "postTime": "2024-10-12 19:13:09",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884205,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884205",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 101,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884205",
    "postTime": "2024-10-12 19:13:06",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884286,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884286",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 186,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884286",
    "postTime": "2024-10-12 19:13:04",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884190,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884190",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 185,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884190",
    "postTime": "2024-10-12 19:13:01",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884154,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884154",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 114,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884154",
    "postTime": "2024-10-12 19:12:59",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884316,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884316",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 92,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884316",
    "postTime": "2024-10-12 19:12:56",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884268,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884268",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 141,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884268",
    "postTime": "2024-10-12 19:12:54",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884243,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884243",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 88,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884243",
    "postTime": "2024-10-12 19:12:51",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884209,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884209",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 84,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884209",
    "postTime": "2024-10-12 19:12:48",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884199,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884199",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 196,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884199",
    "postTime": "2024-10-12 19:12:46",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884340,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884340",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884340",
    "postTime": "2024-10-12 19:12:44",
    "diggCount": 7,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884181,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884181",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 103,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884181",
    "postTime": "2024-10-12 19:12:42",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884473,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884473",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 157,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884473",
    "postTime": "2024-10-12 19:12:39",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884141,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142884141",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884141",
    "postTime": "2024-10-12 18:55:19",
    "diggCount": 4,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7384129061b34e3288409ff55c020c74.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142810870,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810870",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 772,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810870",
    "postTime": "2024-10-10 08:53:46",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142810660,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810660",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 513,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810660",
    "postTime": "2024-10-10 08:53:42",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142810456,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810456",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 570,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810456",
    "postTime": "2024-10-10 08:53:39",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142810555,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810555",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 507,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810555",
    "postTime": "2024-10-10 08:53:36",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142810662,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810662",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 608,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810662",
    "postTime": "2024-10-10 08:53:33",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142810360,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810360",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 358,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810360",
    "postTime": "2024-10-10 08:53:30",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142810768,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810768",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 478,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810768",
    "postTime": "2024-10-10 08:53:26",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142810661,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810661",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 688,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810661",
    "postTime": "2024-10-10 08:53:23",
    "diggCount": 12,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142810556,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810556",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 652,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810556",
    "postTime": "2024-10-10 08:53:20",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142810554,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810554",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 578,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810554",
    "postTime": "2024-10-10 08:53:17",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142810231,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810231",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 858,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810231",
    "postTime": "2024-10-10 08:53:14",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142810124,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810124",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 821,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810124",
    "postTime": "2024-10-10 08:53:11",
    "diggCount": 6,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142810020,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142810020",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 658,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142810020",
    "postTime": "2024-10-10 08:53:09",
    "diggCount": 24,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142809922,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142809922",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 668,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142809922",
    "postTime": "2024-10-10 08:53:00",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142809814,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142809814",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 559,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142809814",
    "postTime": "2024-10-10 08:52:57",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56cce3bc851343bd9c75a9678f5763b6.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142701633,
    "title": "虾皮高频编程考题：二叉树的右视图（中等）",
    "description": "要从二叉树的右侧查看并返回节点值，我们可以使用层序遍历（广度优先遍历）来实现。具体来说，我们需要从右侧依次访问每一层的节点，并从每一层的最右侧节点开始返回结果。，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701633",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 298,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701633",
    "postTime": "2024-10-04 11:54:13",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b6e4941ea10b490a8db4b67f420a3305.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701621,
    "title": "虾皮高频编程考题：二叉搜索树中第 K 小的元素（中等）",
    "description": "小元素，我们可以利用 BST 的中序遍历特性。中序遍历 BST 会以升序方式访问所有节点，因此第。：中序遍历 BST 的结果是一个升序排列的节点值列表。可以使用递归或迭代的方式进行中序遍历。：在遍历过程中，维护一个计数器来记录已经遍历的节点数量，当计数器等于。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第。要查找二叉搜索树（BST）中的第。小的元素就是中序遍历结果中的第。小的元素（从 1 开始计数）。给定一个二叉搜索树的根节点。小的值，你将如何优化算法？时，返回当前节点的值。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701621",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701621",
    "postTime": "2024-10-04 11:53:41",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7be7b92a469348fe9165d76356a1a0fc.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142701615,
    "title": "虾皮高频编程考题：验证二叉搜索树（中等）",
    "description": "根节点的值是 5 ，但是右子节点的值是 4。，判断其是否是一个有效的二叉搜索树。给你一个二叉树的根节点。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701615",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 319,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701615",
    "postTime": "2024-10-04 11:53:05",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/33d363efcf4c482ab02d62a67441d97d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142701610,
    "title": "虾皮高频编程考题：将有序数组转换为二叉搜索树（简单）",
    "description": "要将一个升序排列的整数数组转换为一棵平衡二叉搜索树（BST），我们可以利用递归方法构建树。这是因为一个平衡的BST的中序遍历应该是升序排列的，因此我们可以通过递归的方式选择中间的元素作为根节点，递归构建左右子树，从而保持平衡。：由于数组已经是升序排列的，选择中间元素作为根节点可以保证树的高度平衡。[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。排列，请你将其转换为一棵 平衡 二叉搜索树。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701610",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 248,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701610",
    "postTime": "2024-10-04 11:52:34",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f674c50e28b4432a9ebe786a773e0764.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142701605,
    "title": "虾皮高频编程考题：二叉树的层序遍历（中等）",
    "description": "层序遍历（二叉树的宽度优先遍历）可以使用队列（FIFO）来实现。我们逐层遍历树中的节点，每次处理一层的所有节点，并将它们的子节点加入队列中。（即逐层地，从左到右访问所有节点）。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701605",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701605",
    "postTime": "2024-10-04 11:52:01",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a728c2c3636420b9248f8fe0400e427.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142701595,
    "title": "虾皮高频编程考题：二叉树的直径（简单）",
    "description": "要找到二叉树的直径，我们需要找到树中任意两个节点之间的最长路径。：直径是树中两个节点之间最长的路径长度。这个路径可能会经过树的根节点，也可能不会。3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。因此，整体的空间复杂度主要由递归栈的深度决定，对于最坏情况下是。：通过递归计算每个节点的左右子树的深度，返回节点的最大深度。这条路径可能经过也可能不经过根节点。是指树中任意两个节点之间最长路径的。给你一棵二叉树的根节点，返回该树的。由它们之间边数表示。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701595",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701595",
    "postTime": "2024-10-04 11:51:28",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/82d34823cc444d24b5582f303808b59d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142701584,
    "title": "虾皮高频编程考题：对称二叉树（简单）",
    "description": "要检查一个二叉树是否是轴对称的，我们可以使用递归或迭代的方法。这里提供了两种方法的解题思路和复杂度分析。：可以使用队列来模拟递归检查过程，通过层次遍历来比较每层的节点对称性。：我们需要检查左右子树是否对称。你可以运用递归和迭代两种方法解决这个问题吗？给你一个二叉树的根节点。， 检查它是否轴对称。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701584",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 800,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701584",
    "postTime": "2024-10-04 11:50:39",
    "diggCount": 21,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f1d3ad76cc91463f8ff63d44ab93ecfa.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142701361,
    "title": "虾皮高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701361",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 424,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701361",
    "postTime": "2024-10-04 11:31:36",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142701352,
    "title": "虾皮高频编程考题：二叉树的最大深度（简单）",
    "description": "是指从根节点到最远叶子节点的最长路径上的节点数。递归方法较为简洁直观。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701352",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 244,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701352",
    "postTime": "2024-10-04 11:30:57",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caef40e28a5e46a09db40b2d1e1b1cab.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142701344,
    "title": "虾皮高频编程考题：二叉树的中序遍历（简单）",
    "description": "要实现二叉树的中序遍历，最常见的方式是使用递归。递归算法很简单，你可以通过迭代算法完成吗？迭代方法使用栈来替代递归。给定一个二叉树的根节点。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701344",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 356,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701344",
    "postTime": "2024-10-04 11:30:24",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f3ef3b4a0148408e818b215f1792b710.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142701334,
    "title": "虾皮高频编程考题：LRU 缓存（中等）",
    "description": "/ 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.put(4, 4);// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}// 缓存是 {1=1, 2=2}要实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，可以使用。// 返回 -1 (未找到)lRUCache.get(1);// 返回 -1 (未找到)lRUCache.put(1, 1);// 缓存是 {1=1}lRUCache.get(1);",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701334",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 567,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701334",
    "postTime": "2024-10-04 11:29:52",
    "diggCount": 24,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c37c6a5ba9734596a43ad012b2d6b2ef.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142701327,
    "title": "虾皮高频编程考题：合并 K 个升序链表 （困难）",
    "description": "对于每个节点的插入和删除操作，优先队列的时间复杂度为 O(log k)，其中 k 是链表的数量。总的时间复杂度为 O(N log k)，其中 N 是所有节点的总数。要将多个有序链表合并成一个有序链表，可以使用优先队列（最小堆）来实现，这样能够有效地将多个链表中的最小节点逐步合并，最终形成一个有序的链表。：空间复杂度主要取决于优先队列的存储空间，最坏情况下为 O(k)。请你将所有链表合并到一个升序链表中，返回合并后的链表。给你一个链表数组，每个链表都已经按升序排列。将它们合并到一个有序链表中得到。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701327",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701327",
    "postTime": "2024-10-04 11:29:19",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/751dafd55ff34389bdf5fe2439f17feb.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142701317,
    "title": "虾皮高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701317",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 457,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701317",
    "postTime": "2024-10-04 11:28:41",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701308,
    "title": "虾皮高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701308",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 585,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701308",
    "postTime": "2024-10-04 11:28:02",
    "diggCount": 24,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142701290,
    "title": "虾皮高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142701290",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 377,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701290",
    "postTime": "2024-10-04 11:27:07",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696827,
    "title": "虾皮高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696827",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 294,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696827",
    "postTime": "2024-10-03 21:54:57",
    "diggCount": 9,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696795,
    "title": "虾皮高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696795",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 274,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696795",
    "postTime": "2024-10-03 21:51:54",
    "diggCount": 9,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696789,
    "title": "虾皮高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696789",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 295,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696789",
    "postTime": "2024-10-03 21:51:23",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696782,
    "title": "虾皮高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696782",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 182,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696782",
    "postTime": "2024-10-03 21:50:51",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696776,
    "title": "虾皮高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696776",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 363,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696776",
    "postTime": "2024-10-03 21:50:19",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696768,
    "title": "虾皮高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696768",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 251,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696768",
    "postTime": "2024-10-03 21:49:48",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142696757,
    "title": "虾皮高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 199,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696757",
    "postTime": "2024-10-03 21:49:17",
    "diggCount": 6,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696751,
    "title": "虾皮高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696751",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 294,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696751",
    "postTime": "2024-10-03 21:48:44",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696740,
    "title": "虾皮高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696740",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1055,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696740",
    "postTime": "2024-10-03 21:48:13",
    "diggCount": 25,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142696734,
    "title": "虾皮高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696734",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 395,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696734",
    "postTime": "2024-10-03 21:47:40",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696696,
    "title": "虾皮高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696696",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 723,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696696",
    "postTime": "2024-10-03 21:44:36",
    "diggCount": 16,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142696692,
    "title": "虾皮高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696692",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696692",
    "postTime": "2024-10-03 21:43:59",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696689,
    "title": "虾皮高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696689",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 360,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696689",
    "postTime": "2024-10-03 21:43:25",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696682,
    "title": "虾皮高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696682",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 312,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696682",
    "postTime": "2024-10-03 21:42:53",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696678,
    "title": "虾皮高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696678",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 335,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696678",
    "postTime": "2024-10-03 21:42:17",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142685186,
    "title": "虾皮高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685186",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 283,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685186",
    "postTime": "2024-10-02 21:04:20",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685180,
    "title": "虾皮高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685180",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685180",
    "postTime": "2024-10-02 21:03:45",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685174,
    "title": "虾皮高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685174",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685174",
    "postTime": "2024-10-02 21:03:12",
    "diggCount": 9,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142685163,
    "title": "虾皮高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685163",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 231,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685163",
    "postTime": "2024-10-02 21:02:37",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685155,
    "title": "虾皮高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685155",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 346,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685155",
    "postTime": "2024-10-02 21:01:56",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685147,
    "title": "虾皮高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685147",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685147",
    "postTime": "2024-10-02 21:01:21",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685145,
    "title": "虾皮高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685145",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 229,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685145",
    "postTime": "2024-10-02 21:00:48",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685137,
    "title": "虾皮高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685137",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 236,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685137",
    "postTime": "2024-10-02 21:00:18",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685132,
    "title": "虾皮高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685132",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 295,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685132",
    "postTime": "2024-10-02 20:59:46",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685121,
    "title": "虾皮高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685121",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 385,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685121",
    "postTime": "2024-10-02 20:59:14",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696768,
    "title": "虾皮高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696768",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 251,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696768",
    "postTime": "2024-10-03 21:49:48",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142696757,
    "title": "虾皮高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 199,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696757",
    "postTime": "2024-10-03 21:49:17",
    "diggCount": 6,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696751,
    "title": "虾皮高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696751",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 294,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696751",
    "postTime": "2024-10-03 21:48:44",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696740,
    "title": "虾皮高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696740",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1055,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696740",
    "postTime": "2024-10-03 21:48:13",
    "diggCount": 25,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142696734,
    "title": "虾皮高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696734",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 395,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696734",
    "postTime": "2024-10-03 21:47:40",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696696,
    "title": "虾皮高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696696",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 723,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696696",
    "postTime": "2024-10-03 21:44:36",
    "diggCount": 16,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142696692,
    "title": "虾皮高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696692",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696692",
    "postTime": "2024-10-03 21:43:59",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696689,
    "title": "虾皮高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696689",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 360,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696689",
    "postTime": "2024-10-03 21:43:25",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696682,
    "title": "虾皮高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696682",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 312,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696682",
    "postTime": "2024-10-03 21:42:53",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696678,
    "title": "虾皮高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142696678",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 335,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696678",
    "postTime": "2024-10-03 21:42:17",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142685186,
    "title": "虾皮高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685186",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 283,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685186",
    "postTime": "2024-10-02 21:04:20",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685180,
    "title": "虾皮高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685180",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685180",
    "postTime": "2024-10-02 21:03:45",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685174,
    "title": "虾皮高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685174",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685174",
    "postTime": "2024-10-02 21:03:12",
    "diggCount": 9,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142685163,
    "title": "虾皮高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685163",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 231,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685163",
    "postTime": "2024-10-02 21:02:37",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685155,
    "title": "虾皮高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685155",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 346,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685155",
    "postTime": "2024-10-02 21:01:56",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142685147,
    "title": "虾皮高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685147",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685147",
    "postTime": "2024-10-02 21:01:21",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685145,
    "title": "虾皮高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685145",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 229,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685145",
    "postTime": "2024-10-02 21:00:48",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142685137,
    "title": "虾皮高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685137",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 236,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685137",
    "postTime": "2024-10-02 21:00:18",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142685132,
    "title": "虾皮高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685132",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 295,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685132",
    "postTime": "2024-10-02 20:59:46",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142685121,
    "title": "虾皮高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/JX275431234568/article/details/142685121",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 385,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142685121",
    "postTime": "2024-10-02 20:59:14",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142993897,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993897",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 529,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993897",
    "postTime": "2024-10-16 23:05:45",
    "diggCount": 12,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142993786,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993786",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 898,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993786",
    "postTime": "2024-10-16 23:04:28",
    "diggCount": 17,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142993809,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993809",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 587,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993809",
    "postTime": "2024-10-16 23:04:24",
    "diggCount": 27,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142993749,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993749",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 894,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993749",
    "postTime": "2024-10-16 23:04:20",
    "diggCount": 20,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142993795,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993795",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 628,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993795",
    "postTime": "2024-10-16 23:04:16",
    "diggCount": 22,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142993872,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993872",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 542,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993872",
    "postTime": "2024-10-16 23:04:11",
    "diggCount": 5,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142993859,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993859",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 838,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993859",
    "postTime": "2024-10-16 23:03:24",
    "diggCount": 25,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142993844,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993844",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 514,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993844",
    "postTime": "2024-10-16 23:03:03",
    "diggCount": 13,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142993823,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993823",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 737,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993823",
    "postTime": "2024-10-16 23:02:59",
    "diggCount": 19,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142993850,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993850",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 914,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993850",
    "postTime": "2024-10-16 23:02:53",
    "diggCount": 20,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142993765,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993765",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993765",
    "postTime": "2024-10-16 22:57:42",
    "diggCount": 14,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142993741,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993741",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 737,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993741",
    "postTime": "2024-10-16 22:56:04",
    "diggCount": 6,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142993713,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993713",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 864,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993713",
    "postTime": "2024-10-16 22:56:00",
    "diggCount": 10,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142993729,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993729",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 767,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993729",
    "postTime": "2024-10-16 22:55:56",
    "diggCount": 23,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142993704,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142993704",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 517,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993704",
    "postTime": "2024-10-16 22:55:51",
    "diggCount": 18,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142898334,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898334",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 227,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898334",
    "postTime": "2024-10-13 14:45:36",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142898327,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898327",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 294,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898327",
    "postTime": "2024-10-13 14:45:20",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142898336,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898336",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 376,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898336",
    "postTime": "2024-10-13 14:45:11",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142898390,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898390",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898390",
    "postTime": "2024-10-13 14:45:04",
    "diggCount": 7,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142898349,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898349",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 406,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898349",
    "postTime": "2024-10-13 14:44:53",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142898350,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898350",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898350",
    "postTime": "2024-10-13 14:44:40",
    "diggCount": 7,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142898337,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898337",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 401,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898337",
    "postTime": "2024-10-13 14:44:30",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142898335,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898335",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 358,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898335",
    "postTime": "2024-10-13 14:43:00",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142898370,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898370",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 308,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898370",
    "postTime": "2024-10-13 14:42:31",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142898408,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898408",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898408",
    "postTime": "2024-10-13 14:42:20",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142898310,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898310",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898310",
    "postTime": "2024-10-13 14:42:16",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142898291,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898291",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 367,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898291",
    "postTime": "2024-10-13 14:31:45",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142898274,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898274",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 278,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898274",
    "postTime": "2024-10-13 14:31:38",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142898246,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898246",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 273,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898246",
    "postTime": "2024-10-13 14:31:29",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142898233,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142898233",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 359,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898233",
    "postTime": "2024-10-13 14:31:23",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142884704,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884704",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 184,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884704",
    "postTime": "2024-10-12 19:32:14",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884687,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884687",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 285,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884687",
    "postTime": "2024-10-12 19:32:11",
    "diggCount": 6,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884773,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884773",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 69,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884773",
    "postTime": "2024-10-12 19:32:08",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884653,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884653",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 91,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884653",
    "postTime": "2024-10-12 19:32:05",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884636,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884636",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 187,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884636",
    "postTime": "2024-10-12 19:32:02",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884603,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884603",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 169,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884603",
    "postTime": "2024-10-12 19:31:59",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884727,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884727",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 152,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884727",
    "postTime": "2024-10-12 19:31:55",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884716,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884716",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 108,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884716",
    "postTime": "2024-10-12 19:31:52",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884698,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884698",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 196,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884698",
    "postTime": "2024-10-12 19:31:48",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884668,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884668",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 130,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884668",
    "postTime": "2024-10-12 19:31:45",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884643,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884643",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 137,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884643",
    "postTime": "2024-10-12 19:31:42",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884622,
    "title": "FairSync extends Sync 线程抢锁分析4​",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4​。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884622",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 125,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884622",
    "postTime": "2024-10-12 19:31:39",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884837,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884837",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 61,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884837",
    "postTime": "2024-10-12 19:31:36",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884588,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884588",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 140,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884588",
    "postTime": "2024-10-12 19:19:32",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884564,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142884564",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 299,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884564",
    "postTime": "2024-10-12 19:19:27",
    "diggCount": 7,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/257dab7f1be9492cba930c3006d47c2e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142812077,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142812077",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 746,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142812077",
    "postTime": "2024-10-10 23:04:43",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142812061,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142812061",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 479,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142812061",
    "postTime": "2024-10-10 23:04:40",
    "diggCount": 5,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142812029,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142812029",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 444,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142812029",
    "postTime": "2024-10-10 23:04:37",
    "diggCount": 9,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142812136,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142812136",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 914,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142812136",
    "postTime": "2024-10-10 23:04:34",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142812137,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142812137",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 707,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142812137",
    "postTime": "2024-10-10 23:04:31",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142812011,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142812011",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 515,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142812011",
    "postTime": "2024-10-10 23:04:28",
    "diggCount": 12,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142812012,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142812012",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 699,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142812012",
    "postTime": "2024-10-10 23:04:25",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142812108,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142812108",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 416,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142812108",
    "postTime": "2024-10-10 23:04:23",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142812010,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142812010",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 601,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142812010",
    "postTime": "2024-10-10 23:04:20",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142811976,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142811976",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 652,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142811976",
    "postTime": "2024-10-10 23:04:16",
    "diggCount": 24,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142811956,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142811956",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 726,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142811956",
    "postTime": "2024-10-10 23:04:14",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142811934,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142811934",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 845,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142811934",
    "postTime": "2024-10-10 23:04:10",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142811908,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142811908",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 638,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142811908",
    "postTime": "2024-10-10 23:04:07",
    "diggCount": 22,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142811887,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142811887",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 448,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142811887",
    "postTime": "2024-10-10 23:04:03",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142811840,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142811840",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 809,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142811840",
    "postTime": "2024-10-10 08:58:03",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b5915bcf2a5d403badb62c96305805ea.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142701773,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701773",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 391,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701773",
    "postTime": "2024-10-04 12:09:49",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142701751,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701751",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701751",
    "postTime": "2024-10-04 12:09:07",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142701745,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701745",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 372,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701745",
    "postTime": "2024-10-04 12:09:03",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142701736,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701736",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 300,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701736",
    "postTime": "2024-10-04 12:08:52",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142701766,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701766",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 406,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701766",
    "postTime": "2024-10-04 12:08:41",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701727,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701727",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 217,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701727",
    "postTime": "2024-10-04 12:05:02",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142701741,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701741",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 241,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701741",
    "postTime": "2024-10-04 12:04:57",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142701691,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701691",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 381,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701691",
    "postTime": "2024-10-04 12:02:18",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701706,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701706",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701706",
    "postTime": "2024-10-04 12:02:13",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701715,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701715",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 381,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701715",
    "postTime": "2024-10-04 12:02:09",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701681,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 362,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701681",
    "postTime": "2024-10-04 11:59:55",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142701672,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701672",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 295,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701672",
    "postTime": "2024-10-04 11:59:48",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142701686,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701686",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 405,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701686",
    "postTime": "2024-10-04 11:59:43",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142701664,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701664",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 358,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701664",
    "postTime": "2024-10-04 11:57:15",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142701659,
    "title": "陌陌高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142701659",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 408,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701659",
    "postTime": "2024-10-04 11:57:08",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696580,
    "title": "陌陌高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696580",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696580",
    "postTime": "2024-10-03 21:33:02",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142696575,
    "title": "陌陌高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696575",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696575",
    "postTime": "2024-10-03 21:32:12",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142696567,
    "title": "陌陌高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696567",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696567",
    "postTime": "2024-10-03 21:31:32",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142696556,
    "title": "陌陌高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696556",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 432,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696556",
    "postTime": "2024-10-03 21:30:44",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142696526,
    "title": "陌陌高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696526",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1017,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696526",
    "postTime": "2024-10-03 21:29:18",
    "diggCount": 22,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142696518,
    "title": "陌陌高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696518",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 319,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696518",
    "postTime": "2024-10-03 21:28:43",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696514,
    "title": "陌陌高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696514",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1017,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696514",
    "postTime": "2024-10-03 21:28:04",
    "diggCount": 26,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142696507,
    "title": "陌陌高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696507",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 237,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696507",
    "postTime": "2024-10-03 21:27:31",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696499,
    "title": "陌陌高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696499",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 194,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696499",
    "postTime": "2024-10-03 21:26:56",
    "diggCount": 6,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142696493,
    "title": "陌陌高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696493",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 366,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696493",
    "postTime": "2024-10-03 21:26:19",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696487,
    "title": "陌陌高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696487",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696487",
    "postTime": "2024-10-03 21:25:46",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142696484,
    "title": "陌陌高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696484",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 256,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696484",
    "postTime": "2024-10-03 21:25:14",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696478,
    "title": "陌陌高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696478",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696478",
    "postTime": "2024-10-03 21:24:42",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696469,
    "title": "陌陌高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696469",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 206,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696469",
    "postTime": "2024-10-03 21:24:14",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696457,
    "title": "陌陌高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142696457",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 172,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696457",
    "postTime": "2024-10-03 21:22:38",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142684995,
    "title": "陌陌高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684995",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 285,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684995",
    "postTime": "2024-10-02 20:47:16",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684992,
    "title": "陌陌高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684992",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 380,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684992",
    "postTime": "2024-10-02 20:46:46",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684987,
    "title": "陌陌高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684987",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684987",
    "postTime": "2024-10-02 20:46:13",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142684980,
    "title": "陌陌高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684980",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684980",
    "postTime": "2024-10-02 20:45:36",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684971,
    "title": "陌陌高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684971",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684971",
    "postTime": "2024-10-02 20:45:05",
    "diggCount": 10,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142684965,
    "title": "陌陌高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684965",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 234,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684965",
    "postTime": "2024-10-02 20:44:30",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684957,
    "title": "陌陌高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684957",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 417,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684957",
    "postTime": "2024-10-02 20:43:56",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142684951,
    "title": "陌陌高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684951",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 370,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684951",
    "postTime": "2024-10-02 20:43:21",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142684939,
    "title": "陌陌高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684939",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 382,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684939",
    "postTime": "2024-10-02 20:42:50",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142684931,
    "title": "陌陌高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684931",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684931",
    "postTime": "2024-10-02 20:42:13",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142684920,
    "title": "陌陌高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684920",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684920",
    "postTime": "2024-10-02 20:41:38",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142684914,
    "title": "陌陌高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684914",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684914",
    "postTime": "2024-10-02 20:41:00",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142684908,
    "title": "陌陌高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684908",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 254,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684908",
    "postTime": "2024-10-02 20:40:27",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684899,
    "title": "陌陌高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684899",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684899",
    "postTime": "2024-10-02 20:39:52",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142684892,
    "title": "陌陌高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/SR9872345686689/article/details/142684892",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 388,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684892",
    "postTime": "2024-10-02 20:39:14",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142994135,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142994135",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 654,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994135",
    "postTime": "2024-10-16 23:22:41",
    "diggCount": 5,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142994110,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142994110",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 723,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994110",
    "postTime": "2024-10-16 23:20:09",
    "diggCount": 17,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142994034,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142994034",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 537,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994034",
    "postTime": "2024-10-16 23:19:42",
    "diggCount": 22,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142994104,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142994104",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 582,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994104",
    "postTime": "2024-10-16 23:19:38",
    "diggCount": 17,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142994077,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142994077",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 536,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994077",
    "postTime": "2024-10-16 23:18:13",
    "diggCount": 10,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142994069,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142994069",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 785,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994069",
    "postTime": "2024-10-16 23:17:33",
    "diggCount": 14,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142994052,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142994052",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 352,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994052",
    "postTime": "2024-10-16 23:16:29",
    "diggCount": 14,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142994028,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142994028",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 667,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994028",
    "postTime": "2024-10-16 23:14:55",
    "diggCount": 26,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142994016,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142994016",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 463,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994016",
    "postTime": "2024-10-16 23:14:37",
    "diggCount": 12,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142994009,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142994009",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 604,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994009",
    "postTime": "2024-10-16 23:14:33",
    "diggCount": 13,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142993982,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142993982",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 574,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993982",
    "postTime": "2024-10-16 23:12:09",
    "diggCount": 21,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142993971,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142993971",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 668,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993971",
    "postTime": "2024-10-16 23:12:05",
    "diggCount": 21,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142993990,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142993990",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 788,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993990",
    "postTime": "2024-10-16 23:12:01",
    "diggCount": 22,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142993952,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142993952",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 740,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993952",
    "postTime": "2024-10-16 23:09:37",
    "diggCount": 7,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142993933,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142993933",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 493,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142993933",
    "postTime": "2024-10-16 23:09:28",
    "diggCount": 10,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142898789,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898789",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898789",
    "postTime": "2024-10-13 17:07:46",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142898762,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898762",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 276,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898762",
    "postTime": "2024-10-13 17:07:43",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142898804,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898804",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898804",
    "postTime": "2024-10-13 17:07:41",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142898773,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898773",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 227,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898773",
    "postTime": "2024-10-13 17:07:38",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142898787,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898787",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898787",
    "postTime": "2024-10-13 17:07:35",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142898788,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898788",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 439,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898788",
    "postTime": "2024-10-13 17:07:32",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142898820,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898820",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898820",
    "postTime": "2024-10-13 17:07:29",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142898833,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898833",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 256,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898833",
    "postTime": "2024-10-13 17:07:26",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142898832,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898832",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 493,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898832",
    "postTime": "2024-10-13 17:07:24",
    "diggCount": 7,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142898724,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898724",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 390,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898724",
    "postTime": "2024-10-13 17:07:21",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142898685,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898685",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 225,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898685",
    "postTime": "2024-10-13 17:07:19",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142898672,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898672",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 236,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898672",
    "postTime": "2024-10-13 17:07:16",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142898658,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 283,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898658",
    "postTime": "2024-10-13 17:07:13",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142898657,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898657",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 325,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898657",
    "postTime": "2024-10-13 17:07:10",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142898625,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142898625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142898625",
    "postTime": "2024-10-13 17:07:07",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142885281,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142885281",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 208,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885281",
    "postTime": "2024-10-12 19:55:28",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885082,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142885082",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 135,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885082",
    "postTime": "2024-10-12 19:55:26",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885133,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142885133",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885133",
    "postTime": "2024-10-12 19:55:23",
    "diggCount": 9,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885041,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142885041",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 190,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885041",
    "postTime": "2024-10-12 19:55:20",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885096,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142885096",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 113,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885096",
    "postTime": "2024-10-12 19:44:00",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884929,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142884929",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 182,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884929",
    "postTime": "2024-10-12 19:43:25",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884993,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142884993",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 204,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884993",
    "postTime": "2024-10-12 19:43:21",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885050,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142885050",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 120,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885050",
    "postTime": "2024-10-12 19:42:04",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885023,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142885023",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 140,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885023",
    "postTime": "2024-10-12 19:41:59",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884974,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142884974",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 176,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884974",
    "postTime": "2024-10-12 19:41:56",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884944,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142884944",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 91,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884944",
    "postTime": "2024-10-12 19:41:52",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884984,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142884984",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 140,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884984",
    "postTime": "2024-10-12 19:41:49",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884917,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142884917",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 149,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884917",
    "postTime": "2024-10-12 19:41:45",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884904,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142884904",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 88,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884904",
    "postTime": "2024-10-12 19:41:41",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142884964,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142884964",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 156,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142884964",
    "postTime": "2024-10-12 19:41:26",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2197aa73267c4800a89bf64e7b6046d5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142834538,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834538",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 611,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834538",
    "postTime": "2024-10-10 23:20:05",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142834498,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834498",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 677,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834498",
    "postTime": "2024-10-10 23:20:00",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142834496,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834496",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 534,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834496",
    "postTime": "2024-10-10 23:19:56",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142834483,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834483",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 612,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834483",
    "postTime": "2024-10-10 23:19:54",
    "diggCount": 5,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142834499,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834499",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 608,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834499",
    "postTime": "2024-10-10 23:19:50",
    "diggCount": 15,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142834484,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834484",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 888,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834484",
    "postTime": "2024-10-10 23:19:47",
    "diggCount": 6,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142834497,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834497",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 591,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834497",
    "postTime": "2024-10-10 23:19:44",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142834453,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834453",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 558,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834453",
    "postTime": "2024-10-10 23:19:40",
    "diggCount": 24,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142834467,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834467",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 649,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834467",
    "postTime": "2024-10-10 23:14:15",
    "diggCount": 20,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142834452,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834452",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 666,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834452",
    "postTime": "2024-10-10 23:14:11",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142834431,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834431",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 534,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834431",
    "postTime": "2024-10-10 23:14:06",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142834414,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834414",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 429,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834414",
    "postTime": "2024-10-10 23:14:03",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142834400,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834400",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 627,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834400",
    "postTime": "2024-10-10 23:13:59",
    "diggCount": 29,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142834380,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834380",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 849,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834380",
    "postTime": "2024-10-10 23:11:47",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142834364,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142834364",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 881,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834364",
    "postTime": "2024-10-10 23:11:43",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/954df42a805241f7bc6c44b07eb04380.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142701893,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701893",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 680,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701893",
    "postTime": "2024-10-04 12:25:33",
    "diggCount": 9,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142701878,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701878",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 664,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701878",
    "postTime": "2024-10-04 12:23:31",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142701872,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701872",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 583,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701872",
    "postTime": "2024-10-04 12:22:54",
    "diggCount": 16,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142701868,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701868",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 537,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701868",
    "postTime": "2024-10-04 12:22:21",
    "diggCount": 24,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142701851,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701851",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 758,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701851",
    "postTime": "2024-10-04 12:22:09",
    "diggCount": 20,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142701860,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701860",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 725,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701860",
    "postTime": "2024-10-04 12:22:05",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142701846,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701846",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 827,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701846",
    "postTime": "2024-10-04 12:20:34",
    "diggCount": 11,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701841,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701841",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 763,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701841",
    "postTime": "2024-10-04 12:18:47",
    "diggCount": 19,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142701830,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701830",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 860,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701830",
    "postTime": "2024-10-04 12:18:18",
    "diggCount": 9,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701832,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701832",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 870,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701832",
    "postTime": "2024-10-04 12:18:10",
    "diggCount": 6,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142701819,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701819",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 438,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701819",
    "postTime": "2024-10-04 12:17:11",
    "diggCount": 22,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142701814,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701814",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 904,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701814",
    "postTime": "2024-10-04 12:17:06",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701809,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701809",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 503,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701809",
    "postTime": "2024-10-04 12:17:01",
    "diggCount": 16,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142701803,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701803",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 803,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701803",
    "postTime": "2024-10-04 12:16:57",
    "diggCount": 23,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142701793,
    "title": "百度高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142701793",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 797,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701793",
    "postTime": "2024-10-04 12:12:24",
    "diggCount": 12,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142696438,
    "title": "百度高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696438",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 205,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696438",
    "postTime": "2024-10-03 21:21:17",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142696432,
    "title": "百度高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696432",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 204,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696432",
    "postTime": "2024-10-03 21:20:38",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142696424,
    "title": "百度高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696424",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 446,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696424",
    "postTime": "2024-10-03 21:20:06",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696412,
    "title": "百度高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696412",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 279,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696412",
    "postTime": "2024-10-03 21:19:28",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142696405,
    "title": "百度高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696405",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 499,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696405",
    "postTime": "2024-10-03 21:18:54",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142696395,
    "title": "百度高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696395",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 473,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696395",
    "postTime": "2024-10-03 21:18:20",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142696390,
    "title": "百度高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696390",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696390",
    "postTime": "2024-10-03 21:17:30",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142696384,
    "title": "百度高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696384",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 531,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696384",
    "postTime": "2024-10-03 21:16:58",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142696378,
    "title": "百度高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696378",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1078,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696378",
    "postTime": "2024-10-03 21:16:25",
    "diggCount": 30,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696373,
    "title": "百度高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696373",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 437,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696373",
    "postTime": "2024-10-03 21:15:51",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696366,
    "title": "百度高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696366",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 866,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696366",
    "postTime": "2024-10-03 21:15:14",
    "diggCount": 29,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142696356,
    "title": "百度高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696356",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 512,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696356",
    "postTime": "2024-10-03 21:14:44",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142696350,
    "title": "百度高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696350",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 364,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696350",
    "postTime": "2024-10-03 21:14:09",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696343,
    "title": "百度高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696343",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 359,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696343",
    "postTime": "2024-10-03 21:13:37",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142696337,
    "title": "百度高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142696337",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 373,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696337",
    "postTime": "2024-10-03 21:13:01",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142684663,
    "title": "百度高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684663",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 420,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684663",
    "postTime": "2024-10-02 20:18:56",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684659,
    "title": "百度高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684659",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 376,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684659",
    "postTime": "2024-10-02 20:18:08",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142684652,
    "title": "百度高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684652",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 306,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684652",
    "postTime": "2024-10-02 20:17:30",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142684643,
    "title": "百度高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684643",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 346,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684643",
    "postTime": "2024-10-02 20:16:51",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142684639,
    "title": "百度高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684639",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 524,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684639",
    "postTime": "2024-10-02 20:16:11",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142684630,
    "title": "百度高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684630",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684630",
    "postTime": "2024-10-02 20:15:37",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684626,
    "title": "百度高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684626",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 324,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684626",
    "postTime": "2024-10-02 20:15:03",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684618,
    "title": "百度高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684618",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 422,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684618",
    "postTime": "2024-10-02 20:14:25",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142684617,
    "title": "百度高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684617",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 302,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684617",
    "postTime": "2024-10-02 20:13:48",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142684610,
    "title": "百度高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684610",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 467,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684610",
    "postTime": "2024-10-02 20:13:17",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142684601,
    "title": "百度高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684601",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 570,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684601",
    "postTime": "2024-10-02 20:12:45",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684593,
    "title": "百度高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684593",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 461,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684593",
    "postTime": "2024-10-02 20:12:03",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142684586,
    "title": "百度高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684586",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 503,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684586",
    "postTime": "2024-10-02 20:11:32",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684582,
    "title": "百度高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684582",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 429,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684582",
    "postTime": "2024-10-02 20:11:02",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142684579,
    "title": "百度高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/PZX9845/article/details/142684579",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 498,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684579",
    "postTime": "2024-10-02 20:10:29",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142994466,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994466",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 601,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994466",
    "postTime": "2024-10-16 23:56:02",
    "diggCount": 8,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142994457,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994457",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 610,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994457",
    "postTime": "2024-10-16 23:55:01",
    "diggCount": 22,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142994215,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994215",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 571,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994215",
    "postTime": "2024-10-16 23:52:53",
    "diggCount": 26,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142994229,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994229",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 561,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994229",
    "postTime": "2024-10-16 23:52:49",
    "diggCount": 16,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142994238,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994238",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 851,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994238",
    "postTime": "2024-10-16 23:52:43",
    "diggCount": 18,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142994252,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994252",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 822,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994252",
    "postTime": "2024-10-16 23:52:40",
    "diggCount": 13,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142994435,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994435",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 675,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994435",
    "postTime": "2024-10-16 23:52:36",
    "diggCount": 18,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142994282,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994282",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 711,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994282",
    "postTime": "2024-10-16 23:37:51",
    "diggCount": 11,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142994275,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994275",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 445,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994275",
    "postTime": "2024-10-16 23:37:12",
    "diggCount": 12,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142994220,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994220",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 437,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994220",
    "postTime": "2024-10-16 23:31:25",
    "diggCount": 14,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142994208,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994208",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 531,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994208",
    "postTime": "2024-10-16 23:29:19",
    "diggCount": 10,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142994200,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 598,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994200",
    "postTime": "2024-10-16 23:29:01",
    "diggCount": 26,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142994186,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994186",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 556,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994186",
    "postTime": "2024-10-16 23:27:45",
    "diggCount": 8,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142994173,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994173",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 729,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994173",
    "postTime": "2024-10-16 23:27:41",
    "diggCount": 16,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142994165,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142994165",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 777,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142994165",
    "postTime": "2024-10-16 23:27:37",
    "diggCount": 13,
    "formatTime": "2024.10.16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142901063,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142901063",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 313,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901063",
    "postTime": "2024-10-13 17:27:12",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142900981,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142900981",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 353,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142900981",
    "postTime": "2024-10-13 17:27:08",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142901027,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142901027",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 392,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901027",
    "postTime": "2024-10-13 17:27:05",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142901093,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142901093",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 318,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901093",
    "postTime": "2024-10-13 17:27:02",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142901062,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142901062",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 244,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901062",
    "postTime": "2024-10-13 17:26:59",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142901073,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142901073",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 209,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901073",
    "postTime": "2024-10-13 17:26:55",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142901049,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142901049",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 372,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901049",
    "postTime": "2024-10-13 17:21:33",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142901009,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142901009",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 419,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901009",
    "postTime": "2024-10-13 17:20:13",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142900990,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142900990",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142900990",
    "postTime": "2024-10-13 17:17:04",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142900969,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142900969",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142900969",
    "postTime": "2024-10-13 17:17:00",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142900946,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142900946",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 290,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142900946",
    "postTime": "2024-10-13 17:16:57",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142900917,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142900917",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142900917",
    "postTime": "2024-10-13 17:16:52",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142900934,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142900934",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 466,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142900934",
    "postTime": "2024-10-13 17:16:49",
    "diggCount": 7,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142900895,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142900895",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 344,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142900895",
    "postTime": "2024-10-13 17:16:45",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142900873,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142900873",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 405,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142900873",
    "postTime": "2024-10-13 17:16:41",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142885491,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885491",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 167,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885491",
    "postTime": "2024-10-12 20:10:21",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885511,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885511",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 199,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885511",
    "postTime": "2024-10-12 20:10:16",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885461,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885461",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 127,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885461",
    "postTime": "2024-10-12 20:10:13",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885338,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885338",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 215,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885338",
    "postTime": "2024-10-12 20:10:10",
    "diggCount": 5,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885554,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885554",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 112,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885554",
    "postTime": "2024-10-12 20:10:06",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885532,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885532",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 197,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885532",
    "postTime": "2024-10-12 20:10:03",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885492,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885492",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 344,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885492",
    "postTime": "2024-10-12 20:10:00",
    "diggCount": 6,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885444,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885444",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 44,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885444",
    "postTime": "2024-10-12 20:09:57",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885422,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885422",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 96,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885422",
    "postTime": "2024-10-12 20:09:53",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885403,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885403",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 177,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885403",
    "postTime": "2024-10-12 20:09:49",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885371,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885371",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885371",
    "postTime": "2024-10-12 20:09:46",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885351,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885351",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 114,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885351",
    "postTime": "2024-10-12 20:09:43",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885570,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885570",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 166,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885570",
    "postTime": "2024-10-12 20:09:39",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885329,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885329",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 155,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885329",
    "postTime": "2024-10-12 19:58:44",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142885304,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142885304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 134,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142885304",
    "postTime": "2024-10-12 19:58:40",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a0ef9f0aace4f8981ef5fe258e2fe53.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142834845,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834845",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 909,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834845",
    "postTime": "2024-10-10 23:37:54",
    "diggCount": 9,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142834818,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834818",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 871,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834818",
    "postTime": "2024-10-10 23:36:25",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142834802,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834802",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 570,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834802",
    "postTime": "2024-10-10 23:36:21",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142834826,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834826",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 920,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834826",
    "postTime": "2024-10-10 23:36:17",
    "diggCount": 12,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142834790,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834790",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 699,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834790",
    "postTime": "2024-10-10 23:36:13",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142834768,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834768",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 807,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834768",
    "postTime": "2024-10-10 23:32:55",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142834782,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834782",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 892,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834782",
    "postTime": "2024-10-10 23:32:52",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142834769,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834769",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 746,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834769",
    "postTime": "2024-10-10 23:32:49",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142834757,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 487,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834757",
    "postTime": "2024-10-10 23:32:45",
    "diggCount": 9,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142834740,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834740",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 724,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834740",
    "postTime": "2024-10-10 23:30:58",
    "diggCount": 21,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142834728,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834728",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 762,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834728",
    "postTime": "2024-10-10 23:30:13",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142834704,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834704",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 630,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834704",
    "postTime": "2024-10-10 23:30:07",
    "diggCount": 16,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142834684,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834684",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 888,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834684",
    "postTime": "2024-10-10 23:30:03",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142834666,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834666",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 942,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834666",
    "postTime": "2024-10-10 23:27:13",
    "diggCount": 9,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/04ca06bd97e64a889e553784f55d33cb.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142834640,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142834640",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 702,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834640",
    "postTime": "2024-10-10 23:27:09",
    "diggCount": 15,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ff5732e805214067a2ae4ffa0ee9be82.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142701949,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701949",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 404,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701949",
    "postTime": "2024-10-04 12:43:09",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142701972,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701972",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 390,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701972",
    "postTime": "2024-10-04 12:43:06",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142701966,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701966",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 372,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701966",
    "postTime": "2024-10-04 12:43:02",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142701929,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701929",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 343,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701929",
    "postTime": "2024-10-04 12:42:59",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142701950,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701950",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 315,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701950",
    "postTime": "2024-10-04 12:42:56",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701957,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701957",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 371,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701957",
    "postTime": "2024-10-04 12:42:52",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142701967,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701967",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 270,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701967",
    "postTime": "2024-10-04 12:42:49",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701958,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701958",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 463,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701958",
    "postTime": "2024-10-04 12:42:45",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142701980,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701980",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 388,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701980",
    "postTime": "2024-10-04 12:42:41",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142701939,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701939",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701939",
    "postTime": "2024-10-04 12:42:38",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142701933,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701933",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 216,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701933",
    "postTime": "2024-10-04 12:42:35",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142702022,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142702022",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 216,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702022",
    "postTime": "2024-10-04 12:42:31",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142701923,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701923",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 240,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701923",
    "postTime": "2024-10-04 12:29:38",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142701915,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701915",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701915",
    "postTime": "2024-10-04 12:29:32",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142701908,
    "title": "腾讯高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142701908",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 257,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142701908",
    "postTime": "2024-10-04 12:27:50",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696322,
    "title": "腾讯高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696322",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 372,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696322",
    "postTime": "2024-10-03 21:11:26",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142696318,
    "title": "腾讯高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696318",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 428,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696318",
    "postTime": "2024-10-03 21:10:54",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696310,
    "title": "腾讯高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696310",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 283,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696310",
    "postTime": "2024-10-03 21:10:15",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142696303,
    "title": "腾讯高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696303",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 260,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696303",
    "postTime": "2024-10-03 21:09:38",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696295,
    "title": "腾讯高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696295",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 902,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696295",
    "postTime": "2024-10-03 21:09:01",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142696283,
    "title": "腾讯高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696283",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 275,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696283",
    "postTime": "2024-10-03 21:08:30",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142696274,
    "title": "腾讯高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696274",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 618,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696274",
    "postTime": "2024-10-03 21:07:54",
    "diggCount": 12,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142696267,
    "title": "高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696267",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696267",
    "postTime": "2024-10-03 21:07:19",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142696259,
    "title": "腾讯高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696259",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 219,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696259",
    "postTime": "2024-10-03 21:06:47",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696251,
    "title": "腾讯高频编程考题：环形链表（简单）",
    "description": "题目描述给你一个链表的头节点head，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数pos来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos不作为参数进行传递。仅仅是为了标识链表的实际情况。如果链表中存在环，则返回true。 否则，返回false。示例 1：输入：head = [3,2,0,-4], pos = 1输出：true解",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696251",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 254,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696251",
    "postTime": "2024-10-03 21:06:12",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696226,
    "title": "腾讯高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696226",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 431,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696226",
    "postTime": "2024-10-03 21:04:01",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142696218,
    "title": "腾讯高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696218",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 286,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696218",
    "postTime": "2024-10-03 21:03:28",
    "diggCount": 9,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142696202,
    "title": "腾讯高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696202",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 260,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696202",
    "postTime": "2024-10-03 21:02:18",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142696191,
    "title": "腾讯高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696191",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 137,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696191",
    "postTime": "2024-10-03 21:01:44",
    "diggCount": 9,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142696185,
    "title": "腾讯高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142696185",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 285,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696185",
    "postTime": "2024-10-03 21:01:06",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684809,
    "title": "腾讯高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684809",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 368,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684809",
    "postTime": "2024-10-02 20:32:20",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142684801,
    "title": "腾讯高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684801",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684801",
    "postTime": "2024-10-02 20:31:42",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684794,
    "title": "腾讯高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684794",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684794",
    "postTime": "2024-10-02 20:31:08",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684787,
    "title": "腾讯高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684787",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 240,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684787",
    "postTime": "2024-10-02 20:30:36",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142684777,
    "title": "腾讯高频编程考题：和为 K 的子数组 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684777",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 247,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684777",
    "postTime": "2024-10-02 20:29:53",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142684772,
    "title": "腾讯高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684772",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 299,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684772",
    "postTime": "2024-10-02 20:29:14",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684762,
    "title": "腾讯高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684762",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684762",
    "postTime": "2024-10-02 20:28:41",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142684756,
    "title": "腾讯高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684756",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 392,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684756",
    "postTime": "2024-10-02 20:28:11",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142684750,
    "title": "腾讯高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684750",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 430,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684750",
    "postTime": "2024-10-02 20:27:39",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142684740,
    "title": "腾讯高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684740",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 273,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684740",
    "postTime": "2024-10-02 20:27:05",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142684737,
    "title": "腾讯高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684737",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 343,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684737",
    "postTime": "2024-10-02 20:26:29",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142684729,
    "title": "腾讯高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684729",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 422,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684729",
    "postTime": "2024-10-02 20:25:53",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142684722,
    "title": "腾讯高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684722",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 287,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684722",
    "postTime": "2024-10-02 20:25:18",
    "diggCount": 2,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684713,
    "title": "腾讯高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684713",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 206,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684713",
    "postTime": "2024-10-02 20:24:18",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684707,
    "title": "腾讯高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/PZX87654323/article/details/142684707",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684707",
    "postTime": "2024-10-02 20:23:41",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142996602,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996602",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 390,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996602",
    "postTime": "2024-10-17 08:43:10",
    "diggCount": 20,
    "formatTime": "前天 08:43",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142996526,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996526",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 442,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996526",
    "postTime": "2024-10-17 08:42:28",
    "diggCount": 11,
    "formatTime": "前天 08:42",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142996565,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996565",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 409,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996565",
    "postTime": "2024-10-17 08:42:19",
    "diggCount": 12,
    "formatTime": "前天 08:42",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142996516,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996516",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 821,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996516",
    "postTime": "2024-10-17 08:42:15",
    "diggCount": 23,
    "formatTime": "前天 08:42",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142996546,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996546",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 633,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996546",
    "postTime": "2024-10-17 08:42:11",
    "diggCount": 19,
    "formatTime": "前天 08:42",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142996592,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996592",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 784,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996592",
    "postTime": "2024-10-17 08:42:07",
    "diggCount": 18,
    "formatTime": "前天 08:42",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142996502,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996502",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 461,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996502",
    "postTime": "2024-10-17 08:36:30",
    "diggCount": 16,
    "formatTime": "前天 08:36",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142996470,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996470",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 740,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996470",
    "postTime": "2024-10-17 08:36:05",
    "diggCount": 14,
    "formatTime": "前天 08:36",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142996491,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996491",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 627,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996491",
    "postTime": "2024-10-17 08:35:56",
    "diggCount": 11,
    "formatTime": "前天 08:35",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142996479,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996479",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 479,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996479",
    "postTime": "2024-10-17 08:34:52",
    "diggCount": 19,
    "formatTime": "前天 08:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142996449,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 792,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996449",
    "postTime": "2024-10-17 08:34:46",
    "diggCount": 10,
    "formatTime": "前天 08:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142996439,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996439",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 510,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996439",
    "postTime": "2024-10-17 08:34:40",
    "diggCount": 27,
    "formatTime": "前天 08:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142996426,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996426",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 444,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996426",
    "postTime": "2024-10-17 08:34:35",
    "diggCount": 6,
    "formatTime": "前天 08:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142996415,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996415",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 733,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996415",
    "postTime": "2024-10-17 08:34:31",
    "diggCount": 18,
    "formatTime": "前天 08:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142996408,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142996408",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 692,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996408",
    "postTime": "2024-10-17 08:34:26",
    "diggCount": 8,
    "formatTime": "前天 08:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142901172,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901172",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 401,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901172",
    "postTime": "2024-10-13 17:49:56",
    "diggCount": 7,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142901189,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901189",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 408,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901189",
    "postTime": "2024-10-13 17:49:52",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142901209,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901209",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 212,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901209",
    "postTime": "2024-10-13 17:49:48",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142901210,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901210",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901210",
    "postTime": "2024-10-13 17:49:45",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142901227,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901227",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 217,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901227",
    "postTime": "2024-10-13 17:49:42",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142901242,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901242",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 250,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901242",
    "postTime": "2024-10-13 17:49:38",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142901369,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901369",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901369",
    "postTime": "2024-10-13 17:49:35",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142901337,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901337",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 377,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901337",
    "postTime": "2024-10-13 17:49:32",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142901295,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901295",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 294,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901295",
    "postTime": "2024-10-13 17:49:29",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142901354,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901354",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901354",
    "postTime": "2024-10-13 17:49:26",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142901324,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901324",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 452,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901324",
    "postTime": "2024-10-13 17:49:23",
    "diggCount": 10,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142901311,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901311",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 304,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901311",
    "postTime": "2024-10-13 17:49:19",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142901283,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901283",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901283",
    "postTime": "2024-10-13 17:49:16",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142901267,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901267",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 377,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901267",
    "postTime": "2024-10-13 17:49:13",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142901255,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142901255",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 267,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901255",
    "postTime": "2024-10-13 17:49:09",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142886484,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886484",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 154,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886484",
    "postTime": "2024-10-12 21:15:26",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886462,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886462",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 122,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886462",
    "postTime": "2024-10-12 21:15:23",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886555,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886555",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 184,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886555",
    "postTime": "2024-10-12 21:15:19",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886593,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886593",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 125,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886593",
    "postTime": "2024-10-12 21:14:56",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886531,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886531",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 302,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886531",
    "postTime": "2024-10-12 21:14:53",
    "diggCount": 6,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886575,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886575",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 69,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886575",
    "postTime": "2024-10-12 21:14:50",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886653,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886653",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 182,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886653",
    "postTime": "2024-10-12 21:14:46",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886600,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886600",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 197,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886600",
    "postTime": "2024-10-12 21:11:41",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886542,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886542",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 196,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886542",
    "postTime": "2024-10-12 21:08:15",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886526,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886526",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 96,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886526",
    "postTime": "2024-10-12 21:06:52",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886511,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886511",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 123,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886511",
    "postTime": "2024-10-12 21:06:49",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886493,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886493",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886493",
    "postTime": "2024-10-12 21:06:44",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886477,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886477",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 151,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886477",
    "postTime": "2024-10-12 21:06:41",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886454,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886454",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 184,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886454",
    "postTime": "2024-10-12 21:03:04",
    "diggCount": 5,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886440,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142886440",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 109,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886440",
    "postTime": "2024-10-12 21:02:58",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c57284b2d939472983c22f6a02f368c5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142835034,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142835034",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 448,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835034",
    "postTime": "2024-10-10 23:55:17",
    "diggCount": 16,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142835023,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142835023",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 831,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835023",
    "postTime": "2024-10-10 23:54:24",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142834997,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834997",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 814,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834997",
    "postTime": "2024-10-10 23:54:19",
    "diggCount": 30,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142835011,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142835011",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 449,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835011",
    "postTime": "2024-10-10 23:54:15",
    "diggCount": 21,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142835019,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142835019",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 869,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835019",
    "postTime": "2024-10-10 23:53:49",
    "diggCount": 16,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142834984,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834984",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 659,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834984",
    "postTime": "2024-10-10 23:51:49",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142834973,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834973",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 490,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834973",
    "postTime": "2024-10-10 23:49:55",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142834963,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834963",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 735,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834963",
    "postTime": "2024-10-10 23:49:52",
    "diggCount": 9,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142834957,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834957",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 854,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834957",
    "postTime": "2024-10-10 23:48:53",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142834945,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834945",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 845,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834945",
    "postTime": "2024-10-10 23:48:50",
    "diggCount": 12,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142834936,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834936",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 651,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834936",
    "postTime": "2024-10-10 23:48:47",
    "diggCount": 22,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142834925,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834925",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 822,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834925",
    "postTime": "2024-10-10 23:45:29",
    "diggCount": 20,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142834909,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834909",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 762,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834909",
    "postTime": "2024-10-10 23:44:43",
    "diggCount": 10,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142834888,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834888",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 773,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834888",
    "postTime": "2024-10-10 23:44:39",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142834877,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142834877",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 408,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142834877",
    "postTime": "2024-10-10 23:42:42",
    "diggCount": 21,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/88cba964708e47baaaf617096efb40b7.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142702152,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702152",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 783,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702152",
    "postTime": "2024-10-04 13:52:30",
    "diggCount": 24,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142702264,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702264",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 716,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702264",
    "postTime": "2024-10-04 13:52:01",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142702188,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702188",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702188",
    "postTime": "2024-10-04 13:51:58",
    "diggCount": 6,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142702238,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702238",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 898,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702238",
    "postTime": "2024-10-04 13:51:56",
    "diggCount": 21,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142702249,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702249",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 577,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702249",
    "postTime": "2024-10-04 13:51:53",
    "diggCount": 9,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142702256,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702256",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702256",
    "postTime": "2024-10-04 13:51:49",
    "diggCount": 17,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142702272,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702272",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 691,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702272",
    "postTime": "2024-10-04 13:51:47",
    "diggCount": 15,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142702248,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702248",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 679,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702248",
    "postTime": "2024-10-04 13:51:43",
    "diggCount": 13,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142702278,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702278",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 769,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702278",
    "postTime": "2024-10-04 13:51:40",
    "diggCount": 17,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142702222,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702222",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 917,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702222",
    "postTime": "2024-10-04 13:51:38",
    "diggCount": 23,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142702208,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702208",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 662,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702208",
    "postTime": "2024-10-04 13:51:35",
    "diggCount": 6,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142702201,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702201",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 641,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702201",
    "postTime": "2024-10-04 13:51:32",
    "diggCount": 17,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142702194,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702194",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 842,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702194",
    "postTime": "2024-10-04 13:51:29",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142702598,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702598",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 713,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702598",
    "postTime": "2024-10-04 13:51:25",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142702184,
    "title": "蚂蚁高频面试：二叉树的最大深度（简单）+翻转二叉树（简单）",
    "description": "给定一个二叉树 root ，返回其最大深度。二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。示例 1：输入：root = [3,9,20,null,null,15,7]输出：3示例 2：输入：root = [1,null,2] 输出：2提示：树中节点的数量在 [0, 104] 区间内。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142702184",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 442,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702184",
    "postTime": "2024-10-04 13:03:37",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/adb484b8ede04444a5401cc2adb08589.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142696141,
    "title": "蚂蚁高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696141",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 236,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696141",
    "postTime": "2024-10-03 20:58:03",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696132,
    "title": "蚂蚁高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696132",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 126,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696132",
    "postTime": "2024-10-03 20:57:31",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142696125,
    "title": "蚂蚁高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696125",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 316,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696125",
    "postTime": "2024-10-03 20:56:54",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142696116,
    "title": "蚂蚁高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696116",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 165,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696116",
    "postTime": "2024-10-03 20:56:18",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696105,
    "title": "蚂蚁高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696105",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 353,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696105",
    "postTime": "2024-10-03 20:55:39",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142696095,
    "title": "蚂蚁高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696095",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 235,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696095",
    "postTime": "2024-10-03 20:55:08",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142696088,
    "title": "蚂蚁高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696088",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 272,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696088",
    "postTime": "2024-10-03 20:54:32",
    "diggCount": 9,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142696080,
    "title": "蚂蚁高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696080",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696080",
    "postTime": "2024-10-03 20:53:48",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142696070,
    "title": "蚂蚁高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696070",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 938,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696070",
    "postTime": "2024-10-03 20:53:09",
    "diggCount": 15,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142696055,
    "title": "蚂蚁高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696055",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 264,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696055",
    "postTime": "2024-10-03 20:52:02",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696041,
    "title": "蚂蚁高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696041",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 916,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696041",
    "postTime": "2024-10-03 20:50:50",
    "diggCount": 26,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142696030,
    "title": "蚂蚁高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696030",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 425,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696030",
    "postTime": "2024-10-03 20:50:15",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142696021,
    "title": "蚂蚁高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696021",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 360,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696021",
    "postTime": "2024-10-03 20:49:43",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696015,
    "title": "蚂蚁高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696015",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 285,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696015",
    "postTime": "2024-10-03 20:49:07",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142696007,
    "title": "蚂蚁高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142696007",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142696007",
    "postTime": "2024-10-03 20:48:36",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142684460,
    "title": "蚂蚁高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684460",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 144,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684460",
    "postTime": "2024-10-02 19:58:55",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142684453,
    "title": "蚂蚁高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684453",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 270,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684453",
    "postTime": "2024-10-02 19:58:19",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684445,
    "title": "蚂蚁高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684445",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 343,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684445",
    "postTime": "2024-10-02 19:57:44",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684433,
    "title": "蚂蚁高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684433",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 238,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684433",
    "postTime": "2024-10-02 19:57:06",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142684424,
    "title": "蚂蚁高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684424",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 237,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684424",
    "postTime": "2024-10-02 19:56:31",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142684420,
    "title": "蚂蚁高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684420",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 400,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684420",
    "postTime": "2024-10-02 19:55:56",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142684411,
    "title": "蚂蚁高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684411",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 406,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684411",
    "postTime": "2024-10-02 19:55:06",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142684404,
    "title": "蚂蚁高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684404",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 235,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684404",
    "postTime": "2024-10-02 19:54:32",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142684396,
    "title": "蚂蚁高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684396",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 245,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684396",
    "postTime": "2024-10-02 19:53:59",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142684391,
    "title": "蚂蚁高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684391",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 417,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684391",
    "postTime": "2024-10-02 19:53:25",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142684384,
    "title": "蚂蚁高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684384",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 264,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684384",
    "postTime": "2024-10-02 19:52:54",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684378,
    "title": "蚂蚁高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684378",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 294,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684378",
    "postTime": "2024-10-02 19:52:16",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684372,
    "title": "蚂蚁高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684372",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684372",
    "postTime": "2024-10-02 19:51:41",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142684361,
    "title": "蚂蚁高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684361",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 285,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684361",
    "postTime": "2024-10-02 19:51:06",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142684356,
    "title": "蚂蚁高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/LYLWDFGH4567/article/details/142684356",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 308,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142684356",
    "postTime": "2024-10-02 19:50:19",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142996948,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996948",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 675,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996948",
    "postTime": "2024-10-17 08:58:50",
    "diggCount": 24,
    "formatTime": "前天 08:58",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142996917,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996917",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 573,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996917",
    "postTime": "2024-10-17 08:57:15",
    "diggCount": 13,
    "formatTime": "前天 08:57",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142996902,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996902",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 542,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996902",
    "postTime": "2024-10-17 08:56:42",
    "diggCount": 6,
    "formatTime": "前天 08:56",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142996863,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996863",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 773,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996863",
    "postTime": "2024-10-17 08:54:58",
    "diggCount": 10,
    "formatTime": "前天 08:54",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142996750,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996750",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 636,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996750",
    "postTime": "2024-10-17 08:54:26",
    "diggCount": 19,
    "formatTime": "前天 08:54",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142996845,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996845",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 924,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996845",
    "postTime": "2024-10-17 08:54:15",
    "diggCount": 12,
    "formatTime": "前天 08:54",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142996792,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996792",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 489,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996792",
    "postTime": "2024-10-17 08:54:10",
    "diggCount": 17,
    "formatTime": "前天 08:54",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142996768,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996768",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 584,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996768",
    "postTime": "2024-10-17 08:54:02",
    "diggCount": 22,
    "formatTime": "前天 08:54",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142996830,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996830",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 707,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996830",
    "postTime": "2024-10-17 08:53:55",
    "diggCount": 10,
    "formatTime": "前天 08:53",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142996810,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996810",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 445,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996810",
    "postTime": "2024-10-17 08:52:51",
    "diggCount": 10,
    "formatTime": "前天 08:52",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142996730,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996730",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 705,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996730",
    "postTime": "2024-10-17 08:50:47",
    "diggCount": 5,
    "formatTime": "前天 08:50",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142996682,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996682",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 782,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996682",
    "postTime": "2024-10-17 08:50:42",
    "diggCount": 23,
    "formatTime": "前天 08:50",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142996705,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996705",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 599,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996705",
    "postTime": "2024-10-17 08:50:37",
    "diggCount": 11,
    "formatTime": "前天 08:50",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142996662,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996662",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 759,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996662",
    "postTime": "2024-10-17 08:48:04",
    "diggCount": 24,
    "formatTime": "前天 08:48",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142996640,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142996640",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 701,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142996640",
    "postTime": "2024-10-17 08:48:00",
    "diggCount": 9,
    "formatTime": "前天 08:48",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142901615,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901615",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 287,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901615",
    "postTime": "2024-10-13 18:12:05",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142901626,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901626",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 293,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901626",
    "postTime": "2024-10-13 18:11:54",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142901661,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901661",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 324,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901661",
    "postTime": "2024-10-13 18:11:52",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142901637,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901637",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 385,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901637",
    "postTime": "2024-10-13 18:11:50",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142901625,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 318,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901625",
    "postTime": "2024-10-13 18:11:47",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142901686,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901686",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 448,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901686",
    "postTime": "2024-10-13 18:11:45",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142901675,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901675",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 518,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901675",
    "postTime": "2024-10-13 18:11:42",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142901586,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901586",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 229,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901586",
    "postTime": "2024-10-13 18:11:39",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142901587,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901587",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901587",
    "postTime": "2024-10-13 18:11:36",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142901564,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901564",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 302,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901564",
    "postTime": "2024-10-13 18:11:34",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142901563,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901563",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901563",
    "postTime": "2024-10-13 18:11:31",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142901549,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901549",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 275,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901549",
    "postTime": "2024-10-13 18:11:28",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142901537,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901537",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 378,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901537",
    "postTime": "2024-10-13 18:11:26",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142901521,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901521",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 301,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901521",
    "postTime": "2024-10-13 18:11:22",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142901598,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142901598",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 318,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901598",
    "postTime": "2024-10-13 18:11:17",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142886870,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886870",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 176,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886870",
    "postTime": "2024-10-12 21:30:31",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886913,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886913",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 167,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886913",
    "postTime": "2024-10-12 21:30:21",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886869,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886869",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 70,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886869",
    "postTime": "2024-10-12 21:30:18",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886741,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886741",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 118,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886741",
    "postTime": "2024-10-12 21:30:15",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886902,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886902",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 204,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886902",
    "postTime": "2024-10-12 21:30:13",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886855,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886855",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 98,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886855",
    "postTime": "2024-10-12 21:30:11",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886887,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886887",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 143,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886887",
    "postTime": "2024-10-12 21:30:05",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886903,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886903",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 142,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886903",
    "postTime": "2024-10-12 21:30:03",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886810,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886810",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 98,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886810",
    "postTime": "2024-10-12 21:29:59",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886778,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886778",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 106,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886778",
    "postTime": "2024-10-12 21:29:56",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886761,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886761",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 181,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886761",
    "postTime": "2024-10-12 21:29:54",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886745,
    "title": "FairSync extends Sync 线程抢锁分析4​",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4​。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886745",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 208,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886745",
    "postTime": "2024-10-12 21:29:51",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886925,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886925",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886925",
    "postTime": "2024-10-12 21:29:47",
    "diggCount": 8,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886732,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886732",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 96,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886732",
    "postTime": "2024-10-12 21:19:31",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886713,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142886713",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 174,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886713",
    "postTime": "2024-10-12 21:19:25",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/73a3e464130d4116be00e73a0357044d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142835125,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835125",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 519,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835125",
    "postTime": "2024-10-11 00:13:54",
    "diggCount": 10,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142835124,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835124",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 799,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835124",
    "postTime": "2024-10-11 00:13:50",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142835100,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835100",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 504,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835100",
    "postTime": "2024-10-11 00:13:46",
    "diggCount": 11,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142835108,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835108",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 699,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835108",
    "postTime": "2024-10-11 00:13:42",
    "diggCount": 12,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142835159,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835159",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 419,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835159",
    "postTime": "2024-10-11 00:13:38",
    "diggCount": 23,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142835119,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835119",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 860,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835119",
    "postTime": "2024-10-11 00:12:31",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142835150,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835150",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 368,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835150",
    "postTime": "2024-10-11 00:12:23",
    "diggCount": 12,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142835111,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835111",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 886,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835111",
    "postTime": "2024-10-11 00:07:51",
    "diggCount": 7,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142835095,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835095",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 752,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835095",
    "postTime": "2024-10-11 00:05:09",
    "diggCount": 18,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142835087,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835087",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 486,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835087",
    "postTime": "2024-10-11 00:05:05",
    "diggCount": 10,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142835080,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835080",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 655,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835080",
    "postTime": "2024-10-11 00:05:02",
    "diggCount": 18,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142835073,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835073",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 947,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835073",
    "postTime": "2024-10-11 00:04:59",
    "diggCount": 26,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142835066,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835066",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 780,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835066",
    "postTime": "2024-10-11 00:04:55",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142835063,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835063",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1020,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835063",
    "postTime": "2024-10-11 00:04:51",
    "diggCount": 20,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142835053,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142835053",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 948,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835053",
    "postTime": "2024-10-11 00:02:24",
    "diggCount": 27,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f72cf4a7a32c419fa84f9087e83f95b2.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142702796,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702796",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 580,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702796",
    "postTime": "2024-10-04 15:58:45",
    "diggCount": 15,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142702786,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702786",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 721,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702786",
    "postTime": "2024-10-04 15:58:41",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142702807,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702807",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 848,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702807",
    "postTime": "2024-10-04 15:58:38",
    "diggCount": 21,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142702760,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702760",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 679,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702760",
    "postTime": "2024-10-04 15:58:35",
    "diggCount": 20,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142702785,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702785",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 754,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702785",
    "postTime": "2024-10-04 15:58:32",
    "diggCount": 11,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142702771,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702771",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 772,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702771",
    "postTime": "2024-10-04 15:58:28",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142702759,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702759",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 652,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702759",
    "postTime": "2024-10-04 15:58:25",
    "diggCount": 6,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142702815,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702815",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 488,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702815",
    "postTime": "2024-10-04 15:58:21",
    "diggCount": 8,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142702832,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702832",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 665,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702832",
    "postTime": "2024-10-04 15:58:18",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142702739,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702739",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 577,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702739",
    "postTime": "2024-10-04 15:58:14",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142702730,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702730",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 915,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702730",
    "postTime": "2024-10-04 15:58:11",
    "diggCount": 25,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142702719,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702719",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 870,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702719",
    "postTime": "2024-10-04 15:58:07",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142702704,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702704",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 431,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702704",
    "postTime": "2024-10-04 15:58:03",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142702697,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702697",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 584,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702697",
    "postTime": "2024-10-04 15:57:59",
    "diggCount": 12,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142702675,
    "title": "网易对称二叉树（简单）+二叉树的直径（简单）",
    "description": "给你一个二叉树的根节点 root ， 检查它是否轴对称。示例 1：输入：root = [1,2,2,3,4,4,3]输出：true示例 2：输入：root = [1,2,2,null,3,null,3]输出：false提示：树中节点数目在范围 [1, 1000] 内进阶：你可以运用递归和迭代两种方法解决这个问题吗？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142702675",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 599,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142702675",
    "postTime": "2024-10-04 13:59:16",
    "diggCount": 22,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/09b72bfef42549f386fdde54227e3f60.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142695940,
    "title": "网易高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695940",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 415,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695940",
    "postTime": "2024-10-03 20:43:50",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142695933,
    "title": "网易高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695933",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 273,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695933",
    "postTime": "2024-10-03 20:43:19",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142695925,
    "title": "网易高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695925",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 246,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695925",
    "postTime": "2024-10-03 20:42:48",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142695919,
    "title": "网易高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695919",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695919",
    "postTime": "2024-10-03 20:42:05",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142695913,
    "title": "网易高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695913",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 950,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695913",
    "postTime": "2024-10-03 20:41:25",
    "diggCount": 21,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142695908,
    "title": "网易高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695908",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 244,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695908",
    "postTime": "2024-10-03 20:40:49",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695906,
    "title": "网易高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695906",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 894,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695906",
    "postTime": "2024-10-03 20:40:16",
    "diggCount": 13,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142695899,
    "title": "微博高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695899",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 276,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695899",
    "postTime": "2024-10-03 20:39:41",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142695894,
    "title": "微博高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695894",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695894",
    "postTime": "2024-10-03 20:39:09",
    "diggCount": 10,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142695886,
    "title": "微博高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695886",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695886",
    "postTime": "2024-10-03 20:38:31",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142695880,
    "title": "微博高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695880",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695880",
    "postTime": "2024-10-03 20:37:57",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695875,
    "title": "微博高频编程考题：合并两个有序链表（简单）",
    "description": "题目描述将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例 1：输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]示例 2：输入：l1 = [], l2 = [] 输出：[]示例 3：输入：l1 = [], l2 = [0] 输出：[0]提示：两个链表的节点数目范围是[0, 50]\t-100 <= Node.val <= 100\tl1和l2均",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 269,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695875",
    "postTime": "2024-10-03 20:37:21",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142695868,
    "title": "微博高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695868",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695868",
    "postTime": "2024-10-03 20:36:47",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142695862,
    "title": "微博高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695862",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695862",
    "postTime": "2024-10-03 20:36:12",
    "diggCount": 10,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142695859,
    "title": "微博高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142695859",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 268,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695859",
    "postTime": "2024-10-03 20:35:42",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142682502,
    "title": "微博高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682502",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 289,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682502",
    "postTime": "2024-10-02 16:28:36",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142682499,
    "title": "微博高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682499",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 318,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682499",
    "postTime": "2024-10-02 16:28:01",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142682495,
    "title": "微博高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682495",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 381,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682495",
    "postTime": "2024-10-02 16:27:27",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142682491,
    "title": "微博高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682491",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 300,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682491",
    "postTime": "2024-10-02 16:26:54",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142682483,
    "title": "微博高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682483",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 367,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682483",
    "postTime": "2024-10-02 16:26:24",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142682477,
    "title": "微博高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682477",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 261,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682477",
    "postTime": "2024-10-02 16:25:45",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142682468,
    "title": "微博高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682468",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 353,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682468",
    "postTime": "2024-10-02 16:25:09",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142682463,
    "title": "微博高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682463",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 316,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682463",
    "postTime": "2024-10-02 16:24:29",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142682453,
    "title": "微博高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682453",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682453",
    "postTime": "2024-10-02 16:23:51",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142682444,
    "title": "微博高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682444",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 127,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682444",
    "postTime": "2024-10-02 16:22:44",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142682439,
    "title": "微博高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682439",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 315,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682439",
    "postTime": "2024-10-02 16:22:12",
    "diggCount": 9,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142682427,
    "title": "微博高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682427",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 362,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682427",
    "postTime": "2024-10-02 16:21:24",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142682417,
    "title": "微博高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682417",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682417",
    "postTime": "2024-10-02 16:20:50",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142682410,
    "title": "微博高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682410",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 357,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682410",
    "postTime": "2024-10-02 16:20:18",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142682402,
    "title": "微博高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/CMuhgf7654/article/details/142682402",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 301,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682402",
    "postTime": "2024-10-02 16:19:41",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 143017645,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143017645",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 164,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017645",
    "postTime": "2024-10-17 14:18:19",
    "diggCount": 3,
    "formatTime": "前天 14:18",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143016970,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143016970",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 759,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143016970",
    "postTime": "2024-10-17 14:18:16",
    "diggCount": 13,
    "formatTime": "前天 14:18",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 143016859,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143016859",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 540,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143016859",
    "postTime": "2024-10-17 14:18:13",
    "diggCount": 12,
    "formatTime": "前天 14:18",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 143016757,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143016757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 617,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143016757",
    "postTime": "2024-10-17 14:18:10",
    "diggCount": 10,
    "formatTime": "前天 14:18",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143016650,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143016650",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 519,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143016650",
    "postTime": "2024-10-17 14:18:07",
    "diggCount": 11,
    "formatTime": "前天 14:18",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 143016535,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143016535",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 401,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143016535",
    "postTime": "2024-10-17 14:18:04",
    "diggCount": 16,
    "formatTime": "前天 14:18",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143017179,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143017179",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 750,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017179",
    "postTime": "2024-10-17 14:18:00",
    "diggCount": 17,
    "formatTime": "前天 14:18",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 143017290,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143017290",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 658,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017290",
    "postTime": "2024-10-17 14:17:56",
    "diggCount": 17,
    "formatTime": "前天 14:17",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 143016913,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143016913",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 896,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143016913",
    "postTime": "2024-10-17 14:17:53",
    "diggCount": 23,
    "formatTime": "前天 14:17",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 143016805,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143016805",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 848,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143016805",
    "postTime": "2024-10-17 14:17:50",
    "diggCount": 22,
    "formatTime": "前天 14:17",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 143016706,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143016706",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 621,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143016706",
    "postTime": "2024-10-17 14:17:45",
    "diggCount": 11,
    "formatTime": "前天 14:17",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 143017072,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143017072",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 838,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017072",
    "postTime": "2024-10-17 14:16:18",
    "diggCount": 17,
    "formatTime": "前天 14:16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 143017397,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143017397",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 453,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017397",
    "postTime": "2024-10-17 14:16:16",
    "diggCount": 9,
    "formatTime": "前天 14:16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143016582,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143016582",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 583,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143016582",
    "postTime": "2024-10-17 14:16:14",
    "diggCount": 12,
    "formatTime": "前天 14:16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143016486,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/143016486",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 672,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143016486",
    "postTime": "2024-10-17 14:16:10",
    "diggCount": 10,
    "formatTime": "前天 14:16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142901969,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901969",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901969",
    "postTime": "2024-10-13 18:29:28",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142901837,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901837",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 430,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901837",
    "postTime": "2024-10-13 18:29:21",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142901884,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901884",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 401,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901884",
    "postTime": "2024-10-13 18:29:04",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142901899,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901899",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 328,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901899",
    "postTime": "2024-10-13 18:28:57",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142901928,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901928",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 209,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901928",
    "postTime": "2024-10-13 18:28:53",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142901898,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901898",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 213,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901898",
    "postTime": "2024-10-13 18:28:50",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142901941,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901941",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 510,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901941",
    "postTime": "2024-10-13 18:28:48",
    "diggCount": 6,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142901917,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901917",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 335,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901917",
    "postTime": "2024-10-13 18:28:45",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142901916,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901916",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 222,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901916",
    "postTime": "2024-10-13 18:28:38",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142901940,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901940",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901940",
    "postTime": "2024-10-13 18:28:36",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142901869,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901869",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901869",
    "postTime": "2024-10-13 18:28:33",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142901911,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901911",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 394,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901911",
    "postTime": "2024-10-13 18:28:30",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142901849,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901849",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 350,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901849",
    "postTime": "2024-10-13 18:28:26",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142901827,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901827",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 350,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901827",
    "postTime": "2024-10-13 18:28:14",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142901815,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142901815",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 263,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901815",
    "postTime": "2024-10-13 18:28:10",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142887076,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887076",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 132,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887076",
    "postTime": "2024-10-12 21:45:19",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887042,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887042",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 98,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887042",
    "postTime": "2024-10-12 21:45:07",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887023,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887023",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887023",
    "postTime": "2024-10-12 21:45:00",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887140,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887140",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 150,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887140",
    "postTime": "2024-10-12 21:44:47",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887001,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887001",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 161,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887001",
    "postTime": "2024-10-12 21:44:26",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887141,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887141",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 192,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887141",
    "postTime": "2024-10-12 21:44:22",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887106,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887106",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 133,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887106",
    "postTime": "2024-10-12 21:44:17",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887091,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887091",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 176,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887091",
    "postTime": "2024-10-12 21:44:14",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887052,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887052",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 192,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887052",
    "postTime": "2024-10-12 21:44:11",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887063,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887063",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887063",
    "postTime": "2024-10-12 21:44:05",
    "diggCount": 9,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887032,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887032",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 136,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887032",
    "postTime": "2024-10-12 21:44:01",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887013,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887013",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 190,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887013",
    "postTime": "2024-10-12 21:43:59",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887275,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142887275",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 137,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887275",
    "postTime": "2024-10-12 21:43:56",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142886991,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142886991",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 244,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886991",
    "postTime": "2024-10-12 21:34:20",
    "diggCount": 4,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142886969,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142886969",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 152,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142886969",
    "postTime": "2024-10-12 21:34:15",
    "diggCount": 4,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccdc912bfa664d62b12eb34031847b1c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142835500,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835500",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 620,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835500",
    "postTime": "2024-10-11 07:50:51",
    "diggCount": 24,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142835509,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1008,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835509",
    "postTime": "2024-10-11 07:50:48",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142835530,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835530",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 722,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835530",
    "postTime": "2024-10-11 07:50:46",
    "diggCount": 17,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142835525,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835525",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 493,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835525",
    "postTime": "2024-10-11 07:50:43",
    "diggCount": 16,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142835536,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835536",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 500,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835536",
    "postTime": "2024-10-11 07:50:40",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142835529,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835529",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 785,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835529",
    "postTime": "2024-10-11 07:50:36",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142835515,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835515",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 425,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835515",
    "postTime": "2024-10-11 07:50:34",
    "diggCount": 14,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142835519,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835519",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 798,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835519",
    "postTime": "2024-10-11 07:50:31",
    "diggCount": 12,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142835540,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835540",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 733,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835540",
    "postTime": "2024-10-11 07:50:29",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142835520,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835520",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 598,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835520",
    "postTime": "2024-10-11 07:50:26",
    "diggCount": 20,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142835492,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835492",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 752,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835492",
    "postTime": "2024-10-11 07:50:23",
    "diggCount": 24,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142835481,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835481",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 551,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835481",
    "postTime": "2024-10-11 07:50:21",
    "diggCount": 17,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142835475,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835475",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 534,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835475",
    "postTime": "2024-10-11 07:50:18",
    "diggCount": 17,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142835463,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835463",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 739,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835463",
    "postTime": "2024-10-11 07:50:16",
    "diggCount": 23,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142835455,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142835455",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 785,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142835455",
    "postTime": "2024-10-11 01:01:49",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1afe889296cc492697089c1dc2a62f21.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142704237,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704237",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 584,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704237",
    "postTime": "2024-10-04 16:17:15",
    "diggCount": 23,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142704231,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704231",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 569,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704231",
    "postTime": "2024-10-04 16:16:42",
    "diggCount": 22,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142704107,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704107",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 425,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704107",
    "postTime": "2024-10-04 16:15:21",
    "diggCount": 19,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142704197,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704197",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 574,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704197",
    "postTime": "2024-10-04 16:15:17",
    "diggCount": 21,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142704130,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704130",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 624,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704130",
    "postTime": "2024-10-04 16:15:14",
    "diggCount": 19,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142704147,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704147",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 726,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704147",
    "postTime": "2024-10-04 16:15:06",
    "diggCount": 15,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142704173,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704173",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 843,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704173",
    "postTime": "2024-10-04 16:14:55",
    "diggCount": 13,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142704161,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704161",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 552,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704161",
    "postTime": "2024-10-04 16:14:52",
    "diggCount": 24,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142704098,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704098",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 409,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704098",
    "postTime": "2024-10-04 16:14:49",
    "diggCount": 8,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142704189,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704189",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 692,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704189",
    "postTime": "2024-10-04 16:14:46",
    "diggCount": 6,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142704069,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704069",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 922,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704069",
    "postTime": "2024-10-04 16:07:32",
    "diggCount": 23,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142704036,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704036",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 483,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704036",
    "postTime": "2024-10-04 16:07:28",
    "diggCount": 24,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142704078,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704078",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 740,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704078",
    "postTime": "2024-10-04 16:07:24",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142704016,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704016",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 518,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704016",
    "postTime": "2024-10-04 16:04:34",
    "diggCount": 17,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142704008,
    "title": "二叉树的层序遍历（中等）",
    "description": "给你二叉树的根节点 root ，返回其节点值的 层序遍历。（即逐层地，从左到右访问所有节点）。示例 1：输入：root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]示例 2：输入：root = [1] 输出：[[1]]示例 3：输入：root = [] 输出：[]提示：树中节点数目在范围 [0, 2000] 内。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142704008",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 641,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704008",
    "postTime": "2024-10-04 16:04:30",
    "diggCount": 16,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4e49e8d4be3d4b6589df00bf141160d8.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695839,
    "title": "网易高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695839",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 120,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695839",
    "postTime": "2024-10-03 20:34:19",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142695828,
    "title": "网易高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695828",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 251,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695828",
    "postTime": "2024-10-03 20:33:33",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695821,
    "title": "网易高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695821",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 229,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695821",
    "postTime": "2024-10-03 20:32:59",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695817,
    "title": "网易高频编程考题：合并两个有序链表（简单）",
    "description": "题目描述将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例 1：输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]示例 2：输入：l1 = [], l2 = [] 输出：[]示例 3：输入：l1 = [], l2 = [0] 输出：[0]提示：两个链表的节点数目范围是[0, 50]\t-100 <= Node.val <= 100\tl1和l2均",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695817",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 254,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695817",
    "postTime": "2024-10-03 20:32:27",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142695810,
    "title": "网易高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695810",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 335,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695810",
    "postTime": "2024-10-03 20:31:51",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695803,
    "title": "网易高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695803",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 224,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695803",
    "postTime": "2024-10-03 20:31:21",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695798,
    "title": "网易高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695798",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 182,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695798",
    "postTime": "2024-10-03 20:30:46",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695788,
    "title": "网易高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695788",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 270,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695788",
    "postTime": "2024-10-03 20:30:06",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142695781,
    "title": "网易高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695781",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1068,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695781",
    "postTime": "2024-10-03 20:29:32",
    "diggCount": 14,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142695772,
    "title": "网易高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695772",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 385,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695772",
    "postTime": "2024-10-03 20:28:53",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142695763,
    "title": "网易高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695763",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 534,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695763",
    "postTime": "2024-10-03 20:28:13",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142695748,
    "title": "网易高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695748",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 309,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695748",
    "postTime": "2024-10-03 20:27:21",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695741,
    "title": "网易高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695741",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 301,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695741",
    "postTime": "2024-10-03 20:26:45",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695731,
    "title": "网易高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695731",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695731",
    "postTime": "2024-10-03 20:26:14",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695724,
    "title": "网易高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142695724",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695724",
    "postTime": "2024-10-03 20:25:42",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142682350,
    "title": "网易高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682350",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 367,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682350",
    "postTime": "2024-10-02 16:14:36",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142682346,
    "title": "网易高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682346",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682346",
    "postTime": "2024-10-02 16:14:05",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142682342,
    "title": "网易高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682342",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 245,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682342",
    "postTime": "2024-10-02 16:13:31",
    "diggCount": 10,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142682335,
    "title": "网易高频编程考题：移动零 （简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682335",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 299,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682335",
    "postTime": "2024-10-02 16:12:55",
    "diggCount": 10,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142682327,
    "title": "网易高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682327",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 312,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682327",
    "postTime": "2024-10-02 16:12:20",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142682317,
    "title": "网易高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682317",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 232,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682317",
    "postTime": "2024-10-02 16:11:43",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142682312,
    "title": "网易高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682312",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682312",
    "postTime": "2024-10-02 16:11:09",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142682302,
    "title": "网易高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682302",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 223,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682302",
    "postTime": "2024-10-02 16:10:37",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142682296,
    "title": "网易高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682296",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 243,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682296",
    "postTime": "2024-10-02 16:10:04",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142682292,
    "title": "网易高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682292",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 281,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682292",
    "postTime": "2024-10-02 16:09:30",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142682286,
    "title": "网易高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682286",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 349,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682286",
    "postTime": "2024-10-02 16:08:56",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142682279,
    "title": "网易高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682279",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 386,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682279",
    "postTime": "2024-10-02 16:08:25",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142682271,
    "title": "网易高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682271",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 397,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682271",
    "postTime": "2024-10-02 16:07:49",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142682267,
    "title": "网易高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682267",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 217,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682267",
    "postTime": "2024-10-02 16:07:15",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142682263,
    "title": "网易高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/ZXYokjhgf9/article/details/142682263",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 226,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142682263",
    "postTime": "2024-10-02 16:06:34",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 143018007,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143018007",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 593,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018007",
    "postTime": "2024-10-17 14:38:24",
    "diggCount": 23,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 143017767,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143017767",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 710,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017767",
    "postTime": "2024-10-17 14:38:21",
    "diggCount": 19,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 143018123,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143018123",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018123",
    "postTime": "2024-10-17 14:38:18",
    "diggCount": 9,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 143018154,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143018154",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 543,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018154",
    "postTime": "2024-10-17 14:38:16",
    "diggCount": 4,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 143018087,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143018087",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 803,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018087",
    "postTime": "2024-10-17 14:38:13",
    "diggCount": 11,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 143018043,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143018043",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 575,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018043",
    "postTime": "2024-10-17 14:38:11",
    "diggCount": 11,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143018006,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143018006",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 820,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018006",
    "postTime": "2024-10-17 14:38:09",
    "diggCount": 14,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 143017970,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143017970",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017970",
    "postTime": "2024-10-17 14:38:07",
    "diggCount": 13,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 143017900,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143017900",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 403,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017900",
    "postTime": "2024-10-17 14:38:04",
    "diggCount": 15,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 143017862,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143017862",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 504,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017862",
    "postTime": "2024-10-17 14:38:02",
    "diggCount": 4,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 143017828,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143017828",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 734,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017828",
    "postTime": "2024-10-17 14:38:00",
    "diggCount": 19,
    "formatTime": "前天 14:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 143017782,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143017782",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017782",
    "postTime": "2024-10-17 14:37:58",
    "diggCount": 9,
    "formatTime": "前天 14:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143018350,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143018350",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 558,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018350",
    "postTime": "2024-10-17 14:37:55",
    "diggCount": 12,
    "formatTime": "前天 14:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 143017747,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143017747",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 520,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017747",
    "postTime": "2024-10-17 14:21:43",
    "diggCount": 7,
    "formatTime": "前天 14:21",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143017712,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/143017712",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 453,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143017712",
    "postTime": "2024-10-17 14:21:40",
    "diggCount": 21,
    "formatTime": "前天 14:21",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142902127,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902127",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 486,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902127",
    "postTime": "2024-10-13 18:45:46",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142902047,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902047",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 279,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902047",
    "postTime": "2024-10-13 18:45:39",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142902088,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902088",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 314,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902088",
    "postTime": "2024-10-13 18:45:37",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142902076,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902076",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 232,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902076",
    "postTime": "2024-10-13 18:45:34",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142902058,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902058",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 241,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902058",
    "postTime": "2024-10-13 18:45:31",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142902114,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902114",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 344,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902114",
    "postTime": "2024-10-13 18:45:28",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142902087,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902087",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 247,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902087",
    "postTime": "2024-10-13 18:45:26",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142902099,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902099",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902099",
    "postTime": "2024-10-13 18:45:23",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142902063,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902063",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 426,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902063",
    "postTime": "2024-10-13 18:45:17",
    "diggCount": 10,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142902139,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902139",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 368,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902139",
    "postTime": "2024-10-13 18:45:15",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142902037,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902037",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902037",
    "postTime": "2024-10-13 18:45:12",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142902026,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902026",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 269,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902026",
    "postTime": "2024-10-13 18:45:09",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142902015,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902015",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 286,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902015",
    "postTime": "2024-10-13 18:45:06",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142902008,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142902008",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 240,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902008",
    "postTime": "2024-10-13 18:45:03",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142901994,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142901994",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142901994",
    "postTime": "2024-10-13 18:45:00",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142887568,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887568",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 151,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887568",
    "postTime": "2024-10-12 22:18:47",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887520,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887520",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 200,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887520",
    "postTime": "2024-10-12 22:18:44",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887774,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887774",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 175,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887774",
    "postTime": "2024-10-12 22:18:41",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887775,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887775",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 306,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887775",
    "postTime": "2024-10-12 22:18:39",
    "diggCount": 7,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887897,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887897",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 112,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887897",
    "postTime": "2024-10-12 22:18:36",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887860,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887860",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 150,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887860",
    "postTime": "2024-10-12 22:18:35",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887736,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887736",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 165,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887736",
    "postTime": "2024-10-12 22:18:31",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887861,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887861",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 178,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887861",
    "postTime": "2024-10-12 22:18:28",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887822,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887822",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 202,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887822",
    "postTime": "2024-10-12 22:18:25",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887680,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887680",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 137,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887680",
    "postTime": "2024-10-12 22:18:22",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887636,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887636",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 170,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887636",
    "postTime": "2024-10-12 22:18:19",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887592,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887592",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 201,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887592",
    "postTime": "2024-10-12 22:18:16",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887541,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887541",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 264,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887541",
    "postTime": "2024-10-12 22:18:14",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887497,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887497",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 130,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887497",
    "postTime": "2024-10-12 22:18:12",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142887456,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142887456",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 162,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142887456",
    "postTime": "2024-10-12 22:18:10",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/854d00ca14b94e1e9a3c06806c76f57c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142842312,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142842312",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 475,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142842312",
    "postTime": "2024-10-11 08:07:59",
    "diggCount": 9,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142842398,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142842398",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 550,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142842398",
    "postTime": "2024-10-11 08:07:55",
    "diggCount": 24,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142842399,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142842399",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 436,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142842399",
    "postTime": "2024-10-11 08:07:52",
    "diggCount": 24,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142842482,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142842482",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 703,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142842482",
    "postTime": "2024-10-11 08:07:50",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142842222,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142842222",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 578,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142842222",
    "postTime": "2024-10-11 08:07:47",
    "diggCount": 9,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142842221,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142842221",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 814,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142842221",
    "postTime": "2024-10-11 08:07:44",
    "diggCount": 24,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142842220,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142842220",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 720,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142842220",
    "postTime": "2024-10-11 08:07:41",
    "diggCount": 29,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142842219,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142842219",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 421,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142842219",
    "postTime": "2024-10-11 08:07:38",
    "diggCount": 9,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142842400,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142842400",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 646,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142842400",
    "postTime": "2024-10-11 08:07:35",
    "diggCount": 6,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142842073,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142842073",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 564,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142842073",
    "postTime": "2024-10-11 08:07:31",
    "diggCount": 16,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142841986,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142841986",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 699,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142841986",
    "postTime": "2024-10-11 07:59:17",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142841893,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142841893",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 657,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142841893",
    "postTime": "2024-10-11 07:59:03",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142841808,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142841808",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 798,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142841808",
    "postTime": "2024-10-11 07:59:00",
    "diggCount": 31,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142841723,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142841723",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 449,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142841723",
    "postTime": "2024-10-11 07:58:56",
    "diggCount": 18,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142841634,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142841634",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 713,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142841634",
    "postTime": "2024-10-11 07:54:38",
    "diggCount": 18,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a80d612622a4b4e963ea3917ad75fc6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142704580,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704580",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 604,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704580",
    "postTime": "2024-10-04 16:38:42",
    "diggCount": 15,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142704572,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704572",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704572",
    "postTime": "2024-10-04 16:38:12",
    "diggCount": 16,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142704514,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704514",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 845,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704514",
    "postTime": "2024-10-04 16:34:16",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142704494,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704494",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 753,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704494",
    "postTime": "2024-10-04 16:32:36",
    "diggCount": 12,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142704452,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704452",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 668,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704452",
    "postTime": "2024-10-04 16:30:48",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142704406,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704406",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 434,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704406",
    "postTime": "2024-10-04 16:27:56",
    "diggCount": 11,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142704385,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704385",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 594,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704385",
    "postTime": "2024-10-04 16:26:42",
    "diggCount": 24,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142704371,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704371",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 610,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704371",
    "postTime": "2024-10-04 16:26:05",
    "diggCount": 16,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142704365,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704365",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 730,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704365",
    "postTime": "2024-10-04 16:25:34",
    "diggCount": 23,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142704345,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704345",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 749,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704345",
    "postTime": "2024-10-04 16:25:13",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142704319,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704319",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 476,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704319",
    "postTime": "2024-10-04 16:25:10",
    "diggCount": 14,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142704308,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704308",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 649,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704308",
    "postTime": "2024-10-04 16:25:06",
    "diggCount": 8,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142704357,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704357",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 592,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704357",
    "postTime": "2024-10-04 16:24:58",
    "diggCount": 12,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142704291,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704291",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 854,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704291",
    "postTime": "2024-10-04 16:21:08",
    "diggCount": 8,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142704258,
    "title": "滴滴高频笔试编程题：将有序数组转换为二叉搜索树（简单）",
    "description": "给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。示例 1：输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：输入：nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。提示：nums 按 严格递增 顺序排列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142704258",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 597,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704258",
    "postTime": "2024-10-04 16:21:03",
    "diggCount": 25,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3655022bfb4549a0976a15b1a2ddbe47.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142695679,
    "title": "滴滴高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695679",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695679",
    "postTime": "2024-10-03 20:22:34",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695674,
    "title": "滴滴高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695674",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 275,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695674",
    "postTime": "2024-10-03 20:22:00",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142695667,
    "title": "滴滴高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695667",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 356,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695667",
    "postTime": "2024-10-03 20:21:23",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142695662,
    "title": "滴滴高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695662",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 250,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695662",
    "postTime": "2024-10-03 20:20:51",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695655,
    "title": "滴滴高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695655",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 684,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695655",
    "postTime": "2024-10-03 20:20:16",
    "diggCount": 20,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142695649,
    "title": "滴滴高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695649",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 380,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695649",
    "postTime": "2024-10-03 20:19:41",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142695631,
    "title": "滴滴高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695631",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 675,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695631",
    "postTime": "2024-10-03 20:18:05",
    "diggCount": 20,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142695626,
    "title": "滴滴高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695626",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 381,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695626",
    "postTime": "2024-10-03 20:17:33",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142695619,
    "title": "滴滴高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695619",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 182,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695619",
    "postTime": "2024-10-03 20:17:00",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142695613,
    "title": "滴滴高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695613",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 240,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695613",
    "postTime": "2024-10-03 20:16:26",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142695608,
    "title": "滴滴高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695608",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 400,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695608",
    "postTime": "2024-10-03 20:15:47",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695604,
    "title": "滴滴高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695604",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 218,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695604",
    "postTime": "2024-10-03 20:15:15",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142695598,
    "title": "滴滴高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695598",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 302,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695598",
    "postTime": "2024-10-03 20:14:40",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142695586,
    "title": "滴滴高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695586",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 162,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695586",
    "postTime": "2024-10-03 20:14:07",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142695578,
    "title": "滴滴高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142695578",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 142,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695578",
    "postTime": "2024-10-03 20:13:27",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142681977,
    "title": "滴滴高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681977",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 238,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681977",
    "postTime": "2024-10-02 15:37:06",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681971,
    "title": "滴滴高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681971",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 383,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681971",
    "postTime": "2024-10-02 15:36:28",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142681964,
    "title": "高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681964",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681964",
    "postTime": "2024-10-02 15:35:39",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681961,
    "title": "滴滴高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681961",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 368,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681961",
    "postTime": "2024-10-02 15:35:03",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681949,
    "title": "滴滴高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681949",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 266,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681949",
    "postTime": "2024-10-02 15:33:44",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142681940,
    "title": "滴滴高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681940",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681940",
    "postTime": "2024-10-02 15:33:08",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681931,
    "title": "滴滴高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681931",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 308,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681931",
    "postTime": "2024-10-02 15:32:36",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142681923,
    "title": "滴滴高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681923",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 243,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681923",
    "postTime": "2024-10-02 15:32:03",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142681912,
    "title": "滴滴高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681912",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 413,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681912",
    "postTime": "2024-10-02 15:31:32",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142681904,
    "title": "滴滴高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681904",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 365,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681904",
    "postTime": "2024-10-02 15:31:01",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681894,
    "title": "滴滴高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681894",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 255,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681894",
    "postTime": "2024-10-02 15:30:23",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681887,
    "title": "滴滴高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681887",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 197,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681887",
    "postTime": "2024-10-02 15:29:52",
    "diggCount": 9,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681882,
    "title": "滴滴高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681882",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 157,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681882",
    "postTime": "2024-10-02 15:29:19",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142681873,
    "title": "滴滴高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681873",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 403,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681873",
    "postTime": "2024-10-02 15:28:42",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142681863,
    "title": "滴滴高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/CWFDSDFGHJ1098/article/details/142681863",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681863",
    "postTime": "2024-10-02 15:28:03",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143018718,
    "title": "【无标题】Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018718",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 572,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018718",
    "postTime": "2024-10-17 15:00:26",
    "diggCount": 11,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 143018509,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 849,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018509",
    "postTime": "2024-10-17 15:00:23",
    "diggCount": 15,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 143018809,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018809",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 476,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018809",
    "postTime": "2024-10-17 15:00:20",
    "diggCount": 7,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 143018780,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018780",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 626,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018780",
    "postTime": "2024-10-17 15:00:18",
    "diggCount": 9,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 143018717,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018717",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 397,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018717",
    "postTime": "2024-10-17 15:00:16",
    "diggCount": 15,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 143018840,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018840",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 738,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018840",
    "postTime": "2024-10-17 15:00:14",
    "diggCount": 7,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143018751,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018751",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 446,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018751",
    "postTime": "2024-10-17 15:00:12",
    "diggCount": 6,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 143018810,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018810",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 479,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018810",
    "postTime": "2024-10-17 15:00:09",
    "diggCount": 13,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 143018839,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018839",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 541,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018839",
    "postTime": "2024-10-17 15:00:07",
    "diggCount": 7,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 143018646,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018646",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018646",
    "postTime": "2024-10-17 15:00:03",
    "diggCount": 15,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 143018602,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018602",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 776,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018602",
    "postTime": "2024-10-17 15:00:00",
    "diggCount": 10,
    "formatTime": "前天 15:00",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 143018559,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018559",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 378,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018559",
    "postTime": "2024-10-17 14:59:58",
    "diggCount": 15,
    "formatTime": "前天 14:59",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143018532,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018532",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 778,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018532",
    "postTime": "2024-10-17 14:59:56",
    "diggCount": 5,
    "formatTime": "前天 14:59",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143018496,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018496",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 811,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018496",
    "postTime": "2024-10-17 14:42:19",
    "diggCount": 15,
    "formatTime": "前天 14:42",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 143018454,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZF265467/article/details/143018454",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 594,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143018454",
    "postTime": "2024-10-17 14:42:15",
    "diggCount": 9,
    "formatTime": "前天 14:42",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142902239,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902239",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 377,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902239",
    "postTime": "2024-10-13 19:03:08",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142902273,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902273",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 254,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902273",
    "postTime": "2024-10-13 19:03:01",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142902304,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902304",
    "postTime": "2024-10-13 19:02:58",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142902256,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902256",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 266,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902256",
    "postTime": "2024-10-13 19:02:55",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142902274,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902274",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 493,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902274",
    "postTime": "2024-10-13 19:02:50",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142902257,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902257",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 238,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902257",
    "postTime": "2024-10-13 19:02:47",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142902255,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902255",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 254,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902255",
    "postTime": "2024-10-13 19:02:45",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142902272,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902272",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 275,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902272",
    "postTime": "2024-10-13 19:02:42",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142902288,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902288",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 434,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902288",
    "postTime": "2024-10-13 19:02:37",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142902275,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902275",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 269,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902275",
    "postTime": "2024-10-13 19:02:35",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142902227,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902227",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 362,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902227",
    "postTime": "2024-10-13 19:02:33",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142902199,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902199",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 392,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902199",
    "postTime": "2024-10-13 19:02:30",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142902213,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902213",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 392,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902213",
    "postTime": "2024-10-13 19:02:27",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142902188,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902188",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 318,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902188",
    "postTime": "2024-10-13 19:02:25",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142902176,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142902176",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 302,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902176",
    "postTime": "2024-10-13 19:02:22",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142889442,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889442",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 145,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889442",
    "postTime": "2024-10-12 22:33:43",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889370,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889370",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 198,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889370",
    "postTime": "2024-10-12 22:33:41",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889233,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889233",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 192,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889233",
    "postTime": "2024-10-12 22:33:38",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889162,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889162",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 158,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889162",
    "postTime": "2024-10-12 22:33:36",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889093,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889093",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 196,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889093",
    "postTime": "2024-10-12 22:33:32",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889023,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889023",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 150,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889023",
    "postTime": "2024-10-12 22:33:30",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142888955,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142888955",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142888955",
    "postTime": "2024-10-12 22:33:27",
    "diggCount": 5,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889309,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889309",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 125,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889309",
    "postTime": "2024-10-12 22:33:24",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889514,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889514",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 246,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889514",
    "postTime": "2024-10-12 22:33:21",
    "diggCount": 8,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889198,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889198",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889198",
    "postTime": "2024-10-12 22:33:18",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889129,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889129",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 114,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889129",
    "postTime": "2024-10-12 22:33:14",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889059,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889059",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 139,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889059",
    "postTime": "2024-10-12 22:33:06",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142888989,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142888989",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 169,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142888989",
    "postTime": "2024-10-12 22:33:03",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142889624,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142889624",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 160,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142889624",
    "postTime": "2024-10-12 22:32:57",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142888924,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142888924",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 52,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142888924",
    "postTime": "2024-10-12 22:22:55",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9a044dc573084d9ca9290e92da51817e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142843562,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843562",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 577,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843562",
    "postTime": "2024-10-11 08:24:17",
    "diggCount": 12,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142843594,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843594",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 532,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843594",
    "postTime": "2024-10-11 08:24:13",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142843615,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843615",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 637,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843615",
    "postTime": "2024-10-11 08:24:11",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142843574,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843574",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 772,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843574",
    "postTime": "2024-10-11 08:24:08",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142843588,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843588",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843588",
    "postTime": "2024-10-11 08:24:05",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142843604,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843604",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 593,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843604",
    "postTime": "2024-10-11 08:24:02",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142843590,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843590",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 861,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843590",
    "postTime": "2024-10-11 08:23:59",
    "diggCount": 24,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142843589,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843589",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 913,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843589",
    "postTime": "2024-10-11 08:23:56",
    "diggCount": 14,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142843627,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843627",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 545,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843627",
    "postTime": "2024-10-11 08:23:52",
    "diggCount": 24,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142843547,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843547",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 769,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843547",
    "postTime": "2024-10-11 08:21:11",
    "diggCount": 16,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142843509,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 796,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843509",
    "postTime": "2024-10-11 08:21:07",
    "diggCount": 20,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142843419,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843419",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 939,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843419",
    "postTime": "2024-10-11 08:21:04",
    "diggCount": 20,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142843330,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843330",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 531,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843330",
    "postTime": "2024-10-11 08:21:01",
    "diggCount": 13,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142843232,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843232",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 749,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843232",
    "postTime": "2024-10-11 08:20:57",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142843140,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142843140",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 720,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843140",
    "postTime": "2024-10-11 08:20:53",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4addb2926937431d91d288fa33a59551.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142704780,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704780",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 699,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704780",
    "postTime": "2024-10-04 16:52:01",
    "diggCount": 22,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142704758,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704758",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 584,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704758",
    "postTime": "2024-10-04 16:51:30",
    "diggCount": 25,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142704745,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704745",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 876,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704745",
    "postTime": "2024-10-04 16:50:58",
    "diggCount": 13,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142704755,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704755",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 609,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704755",
    "postTime": "2024-10-04 16:50:54",
    "diggCount": 13,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142704706,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704706",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 797,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704706",
    "postTime": "2024-10-04 16:49:15",
    "diggCount": 22,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142704736,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704736",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 817,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704736",
    "postTime": "2024-10-04 16:49:06",
    "diggCount": 9,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142704733,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704733",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 709,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704733",
    "postTime": "2024-10-04 16:49:01",
    "diggCount": 6,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142704685,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704685",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 806,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704685",
    "postTime": "2024-10-04 16:47:15",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142704676,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704676",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 586,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704676",
    "postTime": "2024-10-04 16:47:11",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142704690,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704690",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 637,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704690",
    "postTime": "2024-10-04 16:47:07",
    "diggCount": 25,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142704669,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704669",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 594,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704669",
    "postTime": "2024-10-04 16:44:56",
    "diggCount": 6,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142704658,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 660,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704658",
    "postTime": "2024-10-04 16:44:53",
    "diggCount": 24,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142704627,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704627",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 693,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704627",
    "postTime": "2024-10-04 16:44:38",
    "diggCount": 19,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142704618,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704618",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 489,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704618",
    "postTime": "2024-10-04 16:42:24",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142704600,
    "title": "2024快手高频笔试编程题：二叉搜索树中第 K 小的元素（中等）",
    "description": "给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。示例 1：输入：root = [3,1,4,null,2], k = 1输出：1示例 2：输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：树中的节点数为 n。进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142704600",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 845,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142704600",
    "postTime": "2024-10-04 16:42:19",
    "diggCount": 16,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caa2408afc4a4016bdc81ea16f46a61f.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695555,
    "title": "快手高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695555",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 244,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695555",
    "postTime": "2024-10-03 20:11:51",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142695550,
    "title": "快手高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695550",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 167,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695550",
    "postTime": "2024-10-03 20:11:16",
    "diggCount": 1,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142695540,
    "title": "快手高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695540",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 327,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695540",
    "postTime": "2024-10-03 20:10:40",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695529,
    "title": "快手高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695529",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 138,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695529",
    "postTime": "2024-10-03 20:09:59",
    "diggCount": 1,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142695522,
    "title": "快手高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695522",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695522",
    "postTime": "2024-10-03 20:09:26",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695513,
    "title": "快手高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695513",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 316,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695513",
    "postTime": "2024-10-03 20:08:49",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142695507,
    "title": "快手高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695507",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695507",
    "postTime": "2024-10-03 20:08:15",
    "diggCount": 10,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142695502,
    "title": "快手高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695502",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 246,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695502",
    "postTime": "2024-10-03 20:07:42",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695498,
    "title": "快手高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695498",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 939,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695498",
    "postTime": "2024-10-03 20:07:11",
    "diggCount": 21,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142695491,
    "title": "快手高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695491",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 322,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695491",
    "postTime": "2024-10-03 20:06:34",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695481,
    "title": "快手高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695481",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 931,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695481",
    "postTime": "2024-10-03 20:06:02",
    "diggCount": 17,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142695474,
    "title": "快手高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695474",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 391,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695474",
    "postTime": "2024-10-03 20:05:25",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142695463,
    "title": "快手高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695463",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 419,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695463",
    "postTime": "2024-10-03 20:04:54",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142695457,
    "title": "快手高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695457",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695457",
    "postTime": "2024-10-03 20:04:17",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142695444,
    "title": "快手高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142695444",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 371,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695444",
    "postTime": "2024-10-03 20:03:43",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142681814,
    "title": "快手高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681814",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 334,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681814",
    "postTime": "2024-10-02 15:23:26",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681811,
    "title": "快手高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681811",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 437,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681811",
    "postTime": "2024-10-02 15:22:54",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681805,
    "title": "快手高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681805",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 304,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681805",
    "postTime": "2024-10-02 15:22:22",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142681801,
    "title": "快手高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681801",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 247,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681801",
    "postTime": "2024-10-02 15:21:44",
    "diggCount": 10,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142681794,
    "title": "快手高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681794",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 424,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681794",
    "postTime": "2024-10-02 15:21:11",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142681782,
    "title": "快手高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681782",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 266,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681782",
    "postTime": "2024-10-02 15:20:36",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681772,
    "title": "快手高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681772",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 352,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681772",
    "postTime": "2024-10-02 15:19:57",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142681764,
    "title": "快手高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681764",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 292,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681764",
    "postTime": "2024-10-02 15:19:21",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142681755,
    "title": "快手高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681755",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 386,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681755",
    "postTime": "2024-10-02 15:18:45",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681743,
    "title": "快手高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681743",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 316,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681743",
    "postTime": "2024-10-02 15:18:06",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142681736,
    "title": "快手高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681736",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 428,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681736",
    "postTime": "2024-10-02 15:17:31",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681732,
    "title": "快手高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681732",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 421,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681732",
    "postTime": "2024-10-02 15:17:01",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681722,
    "title": "快手高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681722",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 367,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681722",
    "postTime": "2024-10-02 15:16:26",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142681714,
    "title": "快手高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681714",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 231,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681714",
    "postTime": "2024-10-02 15:15:42",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681709,
    "title": "快手高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/ZF265467/article/details/142681709",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 426,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681709",
    "postTime": "2024-10-02 15:15:08",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143019524,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019524",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 819,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019524",
    "postTime": "2024-10-17 15:16:03",
    "diggCount": 15,
    "formatTime": "前天 15:16",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 143019539,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019539",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 540,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019539",
    "postTime": "2024-10-17 15:15:59",
    "diggCount": 12,
    "formatTime": "前天 15:15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143019625,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 652,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019625",
    "postTime": "2024-10-17 15:15:55",
    "diggCount": 23,
    "formatTime": "前天 15:15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143019670,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019670",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 634,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019670",
    "postTime": "2024-10-17 15:15:28",
    "diggCount": 11,
    "formatTime": "前天 15:15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 143019480,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019480",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 512,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019480",
    "postTime": "2024-10-17 15:15:14",
    "diggCount": 8,
    "formatTime": "前天 15:15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143019442,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019442",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 435,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019442",
    "postTime": "2024-10-17 15:15:12",
    "diggCount": 23,
    "formatTime": "前天 15:15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 143019319,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019319",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 470,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019319",
    "postTime": "2024-10-17 15:15:09",
    "diggCount": 22,
    "formatTime": "前天 15:15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143019403,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019403",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 645,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019403",
    "postTime": "2024-10-17 15:15:07",
    "diggCount": 8,
    "formatTime": "前天 15:15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 143019284,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019284",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 787,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019284",
    "postTime": "2024-10-17 15:15:04",
    "diggCount": 9,
    "formatTime": "前天 15:15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 143019351,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019351",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 702,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019351",
    "postTime": "2024-10-17 15:15:01",
    "diggCount": 15,
    "formatTime": "前天 15:15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 143019245,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019245",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 406,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019245",
    "postTime": "2024-10-17 15:14:58",
    "diggCount": 10,
    "formatTime": "前天 15:14",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 143019195,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019195",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 576,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019195",
    "postTime": "2024-10-17 15:14:56",
    "diggCount": 5,
    "formatTime": "前天 15:14",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 143019303,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019303",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 422,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019303",
    "postTime": "2024-10-17 15:14:52",
    "diggCount": 11,
    "formatTime": "前天 15:14",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 143019261,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019261",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 803,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019261",
    "postTime": "2024-10-17 15:14:46",
    "diggCount": 24,
    "formatTime": "前天 15:14",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 143019222,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LLN98765/article/details/143019222",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 394,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019222",
    "postTime": "2024-10-17 15:14:43",
    "diggCount": 12,
    "formatTime": "前天 15:14",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142902570,
    "title": "ookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902570",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902570",
    "postTime": "2024-10-13 19:24:25",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142902508,
    "title": "ookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902508",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 324,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902508",
    "postTime": "2024-10-13 19:24:16",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142902509,
    "title": "ookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902509",
    "postTime": "2024-10-13 19:24:08",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142902490,
    "title": "ookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902490",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902490",
    "postTime": "2024-10-13 19:24:00",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142902584,
    "title": "ookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902584",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 454,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902584",
    "postTime": "2024-10-13 19:23:51",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142902526,
    "title": "ookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902526",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 358,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902526",
    "postTime": "2024-10-13 19:23:42",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142902540,
    "title": "ookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902540",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902540",
    "postTime": "2024-10-13 19:23:34",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142902525,
    "title": "ookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902525",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 347,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902525",
    "postTime": "2024-10-13 19:23:25",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142902557,
    "title": "ookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902557",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902557",
    "postTime": "2024-10-13 19:23:15",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142902478,
    "title": "ookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902478",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 497,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902478",
    "postTime": "2024-10-13 19:23:06",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142902465,
    "title": "ookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902465",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 349,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902465",
    "postTime": "2024-10-13 19:22:56",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142902455,
    "title": "ookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902455",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902455",
    "postTime": "2024-10-13 19:22:47",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142902454,
    "title": "ookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902454",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 243,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902454",
    "postTime": "2024-10-13 19:22:38",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142902444,
    "title": "ookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902444",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 250,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902444",
    "postTime": "2024-10-13 19:22:30",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142902429,
    "title": "ookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142902429",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 274,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902429",
    "postTime": "2024-10-13 19:22:20",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142890800,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890800",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 131,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890800",
    "postTime": "2024-10-12 22:52:52",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890784,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890784",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 86,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890784",
    "postTime": "2024-10-12 22:52:24",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890489,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890489",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 187,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890489",
    "postTime": "2024-10-12 22:52:18",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890772,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890772",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 177,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890772",
    "postTime": "2024-10-12 22:52:15",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890747,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890747",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 258,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890747",
    "postTime": "2024-10-12 22:52:07",
    "diggCount": 6,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890556,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890556",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 85,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890556",
    "postTime": "2024-10-12 22:52:04",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890677,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890677",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 146,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890677",
    "postTime": "2024-10-12 22:52:01",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890623,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890623",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 179,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890623",
    "postTime": "2024-10-12 22:51:58",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890319,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890319",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 85,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890319",
    "postTime": "2024-10-12 22:51:54",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890247,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890247",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 176,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890247",
    "postTime": "2024-10-12 22:51:51",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890185,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890185",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 173,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890185",
    "postTime": "2024-10-12 22:51:48",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890114,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890114",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890114",
    "postTime": "2024-10-12 22:51:45",
    "diggCount": 7,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890035,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890035",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890035",
    "postTime": "2024-10-12 22:51:42",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890731,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890731",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 151,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890731",
    "postTime": "2024-10-12 22:51:33",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890412,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142890412",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 76,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890412",
    "postTime": "2024-10-12 22:51:30",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5d249a289450484b86cfdeb1c3d3aced.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142844057,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142844057",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 768,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844057",
    "postTime": "2024-10-11 08:51:55",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142843676,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843676",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 737,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843676",
    "postTime": "2024-10-11 08:51:51",
    "diggCount": 22,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142843863,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843863",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 508,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843863",
    "postTime": "2024-10-11 08:51:48",
    "diggCount": 11,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142843864,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843864",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 728,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843864",
    "postTime": "2024-10-11 08:51:45",
    "diggCount": 12,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142843849,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843849",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 893,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843849",
    "postTime": "2024-10-11 08:51:42",
    "diggCount": 14,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142843828,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843828",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 693,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843828",
    "postTime": "2024-10-11 08:51:38",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142843811,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843811",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 482,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843811",
    "postTime": "2024-10-11 08:35:46",
    "diggCount": 13,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142843802,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843802",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 757,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843802",
    "postTime": "2024-10-11 08:35:43",
    "diggCount": 16,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142843780,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843780",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 624,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843780",
    "postTime": "2024-10-11 08:34:07",
    "diggCount": 13,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142843762,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843762",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 724,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843762",
    "postTime": "2024-10-11 08:34:02",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142843727,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843727",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 671,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843727",
    "postTime": "2024-10-11 08:33:58",
    "diggCount": 13,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142843716,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843716",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 689,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843716",
    "postTime": "2024-10-11 08:32:16",
    "diggCount": 14,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142843695,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843695",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 467,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843695",
    "postTime": "2024-10-11 08:30:49",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142843683,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843683",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 874,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843683",
    "postTime": "2024-10-11 08:30:46",
    "diggCount": 28,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142843665,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142843665",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 849,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142843665",
    "postTime": "2024-10-11 08:29:32",
    "diggCount": 6,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/843abe5f9e0349189286c64c393e154d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142705694,
    "title": "性能优化的过程方法思考3",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705694",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 542,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705694",
    "postTime": "2024-10-04 18:14:57",
    "diggCount": 17,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142705686,
    "title": "性能优化的过程方法思考12",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705686",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 476,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705686",
    "postTime": "2024-10-04 18:13:57",
    "diggCount": 9,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142705680,
    "title": "性能优化的过程方法思考8",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705680",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 642,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705680",
    "postTime": "2024-10-04 18:13:52",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142705666,
    "title": "性能优化的过程方法思考7",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705666",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 939,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705666",
    "postTime": "2024-10-04 18:13:48",
    "diggCount": 16,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142705611,
    "title": "性能优化的过程方法思考1",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705611",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 636,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705611",
    "postTime": "2024-10-04 18:13:42",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142705663,
    "title": "性能优化的过程方法思考15",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705663",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 926,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705663",
    "postTime": "2024-10-04 18:13:36",
    "diggCount": 10,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142705647,
    "title": "性能优化的过程方法思考14",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705647",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 731,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705647",
    "postTime": "2024-10-04 18:13:31",
    "diggCount": 19,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142705634,
    "title": "性能优化的过程方法思考13",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705634",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 809,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705634",
    "postTime": "2024-10-04 18:13:27",
    "diggCount": 8,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142705676,
    "title": "性能优化的过程方法思考11",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705676",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 641,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705676",
    "postTime": "2024-10-04 18:12:32",
    "diggCount": 9,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142705622,
    "title": "性能优化的过程方法思考10",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705622",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705622",
    "postTime": "2024-10-04 18:12:13",
    "diggCount": 7,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142705669,
    "title": "性能优化的过程方法思考9",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705669",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 723,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705669",
    "postTime": "2024-10-04 18:11:59",
    "diggCount": 22,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142705654,
    "title": "性能优化的过程方法思考6",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705654",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 449,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705654",
    "postTime": "2024-10-04 18:11:24",
    "diggCount": 15,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142705638,
    "title": "性能优化的过程方法思考5",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705638",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 710,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705638",
    "postTime": "2024-10-04 18:11:20",
    "diggCount": 8,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142705631,
    "title": "性能优化的过程方法思考4",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705631",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 997,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705631",
    "postTime": "2024-10-04 18:11:17",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142705615,
    "title": "性能优化的过程方法思考2",
    "description": "即使熟悉了开发中的各项技术和优化技巧，但在真正的性能优化场景下，自己依旧很难开展优化任务。其实这是因为你脑海里的知识杂乱无章，仅能靠回忆仅能完成片面的优化。这时我通常都会在手边准备一份详细的提纲，这样在性能优化的时候，能够为我指明方向，并以完整的思维方式进行思考。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142705615",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 939,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705615",
    "postTime": "2024-10-04 18:07:04",
    "diggCount": 11,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b6ce4278155149e3947839c8a636d2fd.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142695431,
    "title": "京东高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695431",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 263,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695431",
    "postTime": "2024-10-03 20:02:24",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695424,
    "title": "京东高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695424",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695424",
    "postTime": "2024-10-03 20:01:50",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695416,
    "title": "京东高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695416",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 248,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695416",
    "postTime": "2024-10-03 20:01:18",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142695410,
    "title": "京东高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695410",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 236,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695410",
    "postTime": "2024-10-03 20:00:46",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142695400,
    "title": "京东高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695400",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 383,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695400",
    "postTime": "2024-10-03 20:00:11",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142695391,
    "title": "京东高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695391",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 369,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695391",
    "postTime": "2024-10-03 19:59:41",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142695388,
    "title": "京东高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695388",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 757,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695388",
    "postTime": "2024-10-03 19:59:05",
    "diggCount": 18,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142695378,
    "title": "京东高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695378",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695378",
    "postTime": "2024-10-03 19:58:32",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142695369,
    "title": "京东高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695369",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 246,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695369",
    "postTime": "2024-10-03 19:57:58",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142695350,
    "title": "京东高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695350",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 319,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695350",
    "postTime": "2024-10-03 19:56:36",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695345,
    "title": "京东高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695345",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 237,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695345",
    "postTime": "2024-10-03 19:56:02",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142695339,
    "title": "京东高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695339",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 205,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695339",
    "postTime": "2024-10-03 19:55:28",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142695333,
    "title": "京东高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695333",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 426,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695333",
    "postTime": "2024-10-03 19:54:56",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695329,
    "title": "京东高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695329",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 135,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695329",
    "postTime": "2024-10-03 19:54:24",
    "diggCount": 6,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695321,
    "title": "京东高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/LLN98765/article/details/142695321",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 139,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695321",
    "postTime": "2024-10-03 19:53:27",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142681668,
    "title": "京东高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681668",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 256,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681668",
    "postTime": "2024-10-02 15:10:16",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142681660,
    "title": "京东高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681660",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 267,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681660",
    "postTime": "2024-10-02 15:09:43",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681656,
    "title": "京东高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681656",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 221,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681656",
    "postTime": "2024-10-02 15:09:04",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142681649,
    "title": "京东高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681649",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 172,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681649",
    "postTime": "2024-10-02 15:08:27",
    "diggCount": 9,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142681639,
    "title": "京东高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681639",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 402,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681639",
    "postTime": "2024-10-02 15:07:48",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681631,
    "title": "京东高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681631",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 251,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681631",
    "postTime": "2024-10-02 15:07:14",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681624,
    "title": "京东高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681624",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681624",
    "postTime": "2024-10-02 15:06:29",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142681619,
    "title": "京东高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681619",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681619",
    "postTime": "2024-10-02 15:05:52",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142681613,
    "title": "京东高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681613",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 303,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681613",
    "postTime": "2024-10-02 15:05:17",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681604,
    "title": "京东高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681604",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 406,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681604",
    "postTime": "2024-10-02 15:04:40",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681597,
    "title": "京东高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681597",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 351,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681597",
    "postTime": "2024-10-02 15:04:03",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681591,
    "title": "京东高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681591",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 373,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681591",
    "postTime": "2024-10-02 15:03:30",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142681583,
    "title": "京东高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681583",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 259,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681583",
    "postTime": "2024-10-02 15:02:39",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681579,
    "title": "京东高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681579",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681579",
    "postTime": "2024-10-02 15:02:01",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681571,
    "title": "京东高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/LLN98765/article/details/142681571",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 226,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681571",
    "postTime": "2024-10-02 15:01:22",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143020026,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143020026",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 755,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020026",
    "postTime": "2024-10-17 15:37:50",
    "diggCount": 15,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143020126,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143020126",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 466,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020126",
    "postTime": "2024-10-17 15:37:48",
    "diggCount": 10,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 143020090,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143020090",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 482,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020090",
    "postTime": "2024-10-17 15:37:45",
    "diggCount": 14,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 143020059,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143020059",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 675,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020059",
    "postTime": "2024-10-17 15:37:43",
    "diggCount": 17,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 143020248,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143020248",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 389,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020248",
    "postTime": "2024-10-17 15:37:40",
    "diggCount": 7,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 143020168,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143020168",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 689,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020168",
    "postTime": "2024-10-17 15:37:39",
    "diggCount": 11,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 143020169,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143020169",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 357,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020169",
    "postTime": "2024-10-17 15:37:36",
    "diggCount": 16,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 143020213,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143020213",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 875,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020213",
    "postTime": "2024-10-17 15:37:34",
    "diggCount": 12,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 143019996,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143019996",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 472,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019996",
    "postTime": "2024-10-17 15:37:30",
    "diggCount": 20,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143019963,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143019963",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 666,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019963",
    "postTime": "2024-10-17 15:37:28",
    "diggCount": 8,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143019930,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143019930",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 505,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019930",
    "postTime": "2024-10-17 15:37:26",
    "diggCount": 7,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 143019896,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143019896",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 571,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019896",
    "postTime": "2024-10-17 15:37:24",
    "diggCount": 15,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 143019867,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143019867",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 642,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019867",
    "postTime": "2024-10-17 15:37:22",
    "diggCount": 7,
    "formatTime": "前天 15:37",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 143019829,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143019829",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 553,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019829",
    "postTime": "2024-10-17 15:19:30",
    "diggCount": 10,
    "formatTime": "前天 15:19",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 143019787,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LH34568/article/details/143019787",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 772,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143019787",
    "postTime": "2024-10-17 15:19:27",
    "diggCount": 16,
    "formatTime": "前天 15:19",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142902802,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902802",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 378,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902802",
    "postTime": "2024-10-13 19:39:18",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142902815,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902815",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 364,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902815",
    "postTime": "2024-10-13 19:39:14",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142902877,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902877",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 373,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902877",
    "postTime": "2024-10-13 19:39:11",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142902813,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902813",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 335,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902813",
    "postTime": "2024-10-13 19:39:08",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142902831,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902831",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 386,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902831",
    "postTime": "2024-10-13 19:39:01",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142902862,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902862",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902862",
    "postTime": "2024-10-13 19:38:51",
    "diggCount": 6,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142902816,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902816",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 378,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902816",
    "postTime": "2024-10-13 19:38:42",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142902842,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902842",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902842",
    "postTime": "2024-10-13 19:38:34",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142902814,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902814",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 278,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902814",
    "postTime": "2024-10-13 19:38:24",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142902843,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902843",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902843",
    "postTime": "2024-10-13 19:38:14",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142902775,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902775",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 381,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902775",
    "postTime": "2024-10-13 19:38:06",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142902784,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902784",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 443,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902784",
    "postTime": "2024-10-13 19:37:59",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142902762,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902762",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 384,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902762",
    "postTime": "2024-10-13 19:37:49",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142902739,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902739",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 357,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902739",
    "postTime": "2024-10-13 19:37:46",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142902723,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LH34568/article/details/142902723",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 361,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902723",
    "postTime": "2024-10-13 19:37:38",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142891050,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/LH34568/article/details/142891050",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 151,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891050",
    "postTime": "2024-10-12 23:09:20",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891017,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/LH34568/article/details/142891017",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891017",
    "postTime": "2024-10-12 23:08:51",
    "diggCount": 6,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891041,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/LH34568/article/details/142891041",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 116,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891041",
    "postTime": "2024-10-12 23:08:48",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890987,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/LH34568/article/details/142890987",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 143,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890987",
    "postTime": "2024-10-12 23:08:45",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891016,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/LH34568/article/details/142891016",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 160,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891016",
    "postTime": "2024-10-12 23:08:41",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890966,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/LH34568/article/details/142890966",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 93,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890966",
    "postTime": "2024-10-12 23:08:38",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890944,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/LH34568/article/details/142890944",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 114,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890944",
    "postTime": "2024-10-12 23:08:36",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891029,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/LH34568/article/details/142891029",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 114,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891029",
    "postTime": "2024-10-12 23:08:32",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890957,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/LH34568/article/details/142890957",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 267,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890957",
    "postTime": "2024-10-12 23:08:28",
    "diggCount": 4,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891004,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/LH34568/article/details/142891004",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 85,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891004",
    "postTime": "2024-10-12 23:08:25",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890925,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/LH34568/article/details/142890925",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 165,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890925",
    "postTime": "2024-10-12 23:08:23",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890905,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/LH34568/article/details/142890905",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 135,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890905",
    "postTime": "2024-10-12 23:08:19",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890890,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/LH34568/article/details/142890890",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 103,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890890",
    "postTime": "2024-10-12 23:08:16",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890874,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/LH34568/article/details/142890874",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 129,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890874",
    "postTime": "2024-10-12 23:08:13",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142890860,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/LH34568/article/details/142890860",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 156,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142890860",
    "postTime": "2024-10-12 23:08:10",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd549cb9810f4d8e9fd84ec4215db67f.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142844321,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844321",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 704,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844321",
    "postTime": "2024-10-11 09:26:42",
    "diggCount": 23,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142844427,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844427",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 822,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844427",
    "postTime": "2024-10-11 09:26:38",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142844428,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844428",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 595,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844428",
    "postTime": "2024-10-11 09:26:34",
    "diggCount": 7,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142844402,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844402",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 810,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844402",
    "postTime": "2024-10-11 09:26:29",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142844346,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844346",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 850,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844346",
    "postTime": "2024-10-11 09:26:25",
    "diggCount": 24,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142844289,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844289",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 872,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844289",
    "postTime": "2024-10-11 09:26:21",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142844401,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844401",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 858,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844401",
    "postTime": "2024-10-11 09:26:17",
    "diggCount": 22,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142844378,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844378",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 782,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844378",
    "postTime": "2024-10-11 09:26:13",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142844377,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844377",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844377",
    "postTime": "2024-10-11 09:26:10",
    "diggCount": 20,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142844257,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844257",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 422,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844257",
    "postTime": "2024-10-11 09:26:06",
    "diggCount": 20,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142844239,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844239",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 678,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844239",
    "postTime": "2024-10-11 09:26:03",
    "diggCount": 23,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142844215,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844215",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 892,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844215",
    "postTime": "2024-10-11 09:25:59",
    "diggCount": 24,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142844187,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844187",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 547,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844187",
    "postTime": "2024-10-11 09:25:55",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142844163,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844163",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 760,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844163",
    "postTime": "2024-10-11 09:25:51",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142844142,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LH34568/article/details/142844142",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 539,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142844142",
    "postTime": "2024-10-11 09:25:46",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/67d34b7710ac442a99d32fac4c636e6c.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142705805,
    "title": "go语言学习---concurrency14",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705805",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 176,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705805",
    "postTime": "2024-10-04 22:15:43",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705769,
    "title": "go语言学习---concurrency13",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705769",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 202,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705769",
    "postTime": "2024-10-04 22:15:34",
    "diggCount": 1,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705753,
    "title": "go语言学习---concurrency12",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705753",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 151,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705753",
    "postTime": "2024-10-04 22:15:26",
    "diggCount": 2,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705827,
    "title": "go语言学习---concurrency11",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705827",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 205,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705827",
    "postTime": "2024-10-04 22:15:17",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705818,
    "title": "go语言学习---concurrency10",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705818",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 201,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705818",
    "postTime": "2024-10-04 22:15:09",
    "diggCount": 2,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705817,
    "title": "go语言学习---concurrency9",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705817",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 199,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705817",
    "postTime": "2024-10-04 22:15:01",
    "diggCount": 2,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705826,
    "title": "go语言学习---concurrency8",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705826",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 224,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705826",
    "postTime": "2024-10-04 22:14:52",
    "diggCount": 2,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705828,
    "title": "go语言学习---concurrency7",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705828",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 188,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705828",
    "postTime": "2024-10-04 22:14:44",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705792,
    "title": "go语言学习---concurrency6",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705792",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 165,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705792",
    "postTime": "2024-10-04 22:14:36",
    "diggCount": 2,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705780,
    "title": "go语言学习---concurrency5",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705780",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705780",
    "postTime": "2024-10-04 22:14:28",
    "diggCount": 1,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705801,
    "title": "go语言学习---concurrency4",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705801",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 211,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705801",
    "postTime": "2024-10-04 22:14:20",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705759,
    "title": "go语言学习---concurrency3",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705759",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 243,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705759",
    "postTime": "2024-10-04 22:14:11",
    "diggCount": 1,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705745,
    "title": "go语言学习---concurrency2",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705745",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 243,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705745",
    "postTime": "2024-10-04 22:14:03",
    "diggCount": 2,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705734,
    "title": "go语言学习---concurrency1",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705734",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 145,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705734",
    "postTime": "2024-10-04 22:13:55",
    "diggCount": 2,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142705788,
    "title": "go语言学习---concurrency15",
    "description": "import (\"fmt\"\"testing\"\"time\"select {default:for i := 0;i < 5;i++ {for {break。",
    "url": "https://blog.csdn.net/LH34568/article/details/142705788",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 217,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142705788",
    "postTime": "2024-10-04 22:13:46",
    "diggCount": 2,
    "formatTime": "2024.10.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142695299,
    "title": "小红书高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/LH34568/article/details/142695299",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 264,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695299",
    "postTime": "2024-10-03 19:51:07",
    "diggCount": 1,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142695293,
    "title": "小红书高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/LH34568/article/details/142695293",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 273,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695293",
    "postTime": "2024-10-03 19:50:30",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695289,
    "title": "小红书高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/LH34568/article/details/142695289",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 273,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695289",
    "postTime": "2024-10-03 19:49:55",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142695282,
    "title": "小红书高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/LH34568/article/details/142695282",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 185,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695282",
    "postTime": "2024-10-03 19:49:23",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695275,
    "title": "小红书高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/LH34568/article/details/142695275",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 325,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695275",
    "postTime": "2024-10-03 19:48:47",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695263,
    "title": "小红书高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/LH34568/article/details/142695263",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 367,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695263",
    "postTime": "2024-10-03 19:48:07",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695255,
    "title": "小红书高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/LH34568/article/details/142695255",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695255",
    "postTime": "2024-10-03 19:47:34",
    "diggCount": 6,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142695247,
    "title": "小红书高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/LH34568/article/details/142695247",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 369,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695247",
    "postTime": "2024-10-03 19:46:57",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695242,
    "title": "小红书高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/LH34568/article/details/142695242",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 686,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695242",
    "postTime": "2024-10-03 19:46:23",
    "diggCount": 28,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142695235,
    "title": "小红书高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/LH34568/article/details/142695235",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 285,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695235",
    "postTime": "2024-10-03 19:45:52",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695230,
    "title": "小红书高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/LH34568/article/details/142695230",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 668,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695230",
    "postTime": "2024-10-03 19:45:16",
    "diggCount": 24,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142695223,
    "title": "小红书高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/LH34568/article/details/142695223",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 418,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695223",
    "postTime": "2024-10-03 19:44:43",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142695211,
    "title": "小红书高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/LH34568/article/details/142695211",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 362,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695211",
    "postTime": "2024-10-03 19:44:12",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142695200,
    "title": "小红书高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LH34568/article/details/142695200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695200",
    "postTime": "2024-10-03 19:43:40",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695196,
    "title": "小红书高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LH34568/article/details/142695196",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 325,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695196",
    "postTime": "2024-10-03 19:43:05",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681461,
    "title": "小红书高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681461",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 303,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681461",
    "postTime": "2024-10-02 14:51:31",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142681453,
    "title": "小红书高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681453",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 378,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681453",
    "postTime": "2024-10-02 14:51:00",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681447,
    "title": "小红书高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681447",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681447",
    "postTime": "2024-10-02 14:50:21",
    "diggCount": 9,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142681441,
    "title": "小红书高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681441",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681441",
    "postTime": "2024-10-02 14:49:45",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142681437,
    "title": "小红书高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681437",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 219,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681437",
    "postTime": "2024-10-02 14:49:15",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681431,
    "title": "小红书高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681431",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681431",
    "postTime": "2024-10-02 14:48:39",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142681427,
    "title": "小红书高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681427",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 301,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681427",
    "postTime": "2024-10-02 14:48:08",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681422,
    "title": "小红书高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681422",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 321,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681422",
    "postTime": "2024-10-02 14:47:36",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681412,
    "title": "小红书高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681412",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 306,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681412",
    "postTime": "2024-10-02 14:47:01",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681406,
    "title": "小红书高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681406",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681406",
    "postTime": "2024-10-02 14:46:03",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681398,
    "title": "小红书高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681398",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681398",
    "postTime": "2024-10-02 14:45:28",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681393,
    "title": "小红书高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681393",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681393",
    "postTime": "2024-10-02 14:44:54",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681388,
    "title": "小红书高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681388",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681388",
    "postTime": "2024-10-02 14:44:22",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681386,
    "title": "小红书高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681386",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681386",
    "postTime": "2024-10-02 14:43:47",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142681373,
    "title": "小红书高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/LH34568/article/details/142681373",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 309,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681373",
    "postTime": "2024-10-02 14:43:05",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 143020866,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020866",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 565,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020866",
    "postTime": "2024-10-17 16:03:09",
    "diggCount": 9,
    "formatTime": "前天 16:03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 143020907,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020907",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 629,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020907",
    "postTime": "2024-10-17 16:03:07",
    "diggCount": 27,
    "formatTime": "前天 16:03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143020828,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020828",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 671,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020828",
    "postTime": "2024-10-17 16:03:03",
    "diggCount": 7,
    "formatTime": "前天 16:03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143020988,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020988",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 635,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020988",
    "postTime": "2024-10-17 16:03:00",
    "diggCount": 16,
    "formatTime": "前天 16:03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 143021015,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143021015",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 487,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021015",
    "postTime": "2024-10-17 16:02:58",
    "diggCount": 24,
    "formatTime": "前天 16:02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143021058,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143021058",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 506,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021058",
    "postTime": "2024-10-17 16:02:54",
    "diggCount": 9,
    "formatTime": "前天 16:02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 143021095,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143021095",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 507,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021095",
    "postTime": "2024-10-17 16:02:52",
    "diggCount": 14,
    "formatTime": "前天 16:02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 143020942,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020942",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 566,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020942",
    "postTime": "2024-10-17 16:02:50",
    "diggCount": 14,
    "formatTime": "前天 16:02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 143020791,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020791",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 540,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020791",
    "postTime": "2024-10-17 16:02:48",
    "diggCount": 13,
    "formatTime": "前天 16:02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 143020727,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020727",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 608,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020727",
    "postTime": "2024-10-17 16:02:46",
    "diggCount": 7,
    "formatTime": "前天 16:02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 143020684,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020684",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 463,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020684",
    "postTime": "2024-10-17 16:02:44",
    "diggCount": 17,
    "formatTime": "前天 16:02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 143020653,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020653",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 875,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020653",
    "postTime": "2024-10-17 16:02:42",
    "diggCount": 21,
    "formatTime": "前天 16:02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 143020627,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020627",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 456,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020627",
    "postTime": "2024-10-17 16:02:39",
    "diggCount": 20,
    "formatTime": "前天 16:02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 143020588,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020588",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 759,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020588",
    "postTime": "2024-10-17 15:41:27",
    "diggCount": 20,
    "formatTime": "前天 15:41",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 143020554,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/JH8876434/article/details/143020554",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 452,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143020554",
    "postTime": "2024-10-17 15:41:25",
    "diggCount": 8,
    "formatTime": "前天 15:41",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142903101,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903101",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903101",
    "postTime": "2024-10-13 19:59:27",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142903118,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903118",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 364,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903118",
    "postTime": "2024-10-13 19:59:24",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142903102,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903102",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 322,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903102",
    "postTime": "2024-10-13 19:59:22",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142903035,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903035",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 388,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903035",
    "postTime": "2024-10-13 19:59:20",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142903033,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903033",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 276,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903033",
    "postTime": "2024-10-13 19:59:18",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142903034,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903034",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 361,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903034",
    "postTime": "2024-10-13 19:59:15",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142903063,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903063",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 389,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903063",
    "postTime": "2024-10-13 19:59:13",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142903077,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903077",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 308,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903077",
    "postTime": "2024-10-13 19:59:10",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142903050,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903050",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903050",
    "postTime": "2024-10-13 19:59:08",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142903004,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903004",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 479,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903004",
    "postTime": "2024-10-13 19:59:05",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142902988,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142902988",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 404,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902988",
    "postTime": "2024-10-13 19:59:02",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142902968,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142902968",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 245,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902968",
    "postTime": "2024-10-13 19:58:59",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142902956,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142902956",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 287,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902956",
    "postTime": "2024-10-13 19:58:56",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142902932,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142902932",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 258,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142902932",
    "postTime": "2024-10-13 19:58:53",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142903019,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142903019",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 380,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903019",
    "postTime": "2024-10-13 19:58:48",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142891329,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891329",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 173,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891329",
    "postTime": "2024-10-12 23:32:41",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891237,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891237",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 122,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891237",
    "postTime": "2024-10-12 23:32:26",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891222,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891222",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 149,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891222",
    "postTime": "2024-10-12 23:32:22",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891208,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891208",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 139,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891208",
    "postTime": "2024-10-12 23:32:19",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891194,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891194",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 193,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891194",
    "postTime": "2024-10-12 23:32:15",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891183,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891183",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 201,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891183",
    "postTime": "2024-10-12 23:32:12",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891174,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891174",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 153,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891174",
    "postTime": "2024-10-12 23:31:58",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891317,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891317",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 135,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891317",
    "postTime": "2024-10-12 23:31:54",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891152,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891152",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 143,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891152",
    "postTime": "2024-10-12 23:17:31",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891141,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891141",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 127,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891141",
    "postTime": "2024-10-12 23:17:25",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891115,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891115",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 130,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891115",
    "postTime": "2024-10-12 23:17:22",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891128,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891128",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 110,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891128",
    "postTime": "2024-10-12 23:17:19",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891102,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891102",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 117,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891102",
    "postTime": "2024-10-12 23:17:15",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891088,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891088",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 196,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891088",
    "postTime": "2024-10-12 23:17:10",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891076,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142891076",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 287,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891076",
    "postTime": "2024-10-12 23:17:07",
    "diggCount": 9,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9647cfef7dd646e5bdd6464e2f010e2d.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142860486,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860486",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 615,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860486",
    "postTime": "2024-10-11 22:32:56",
    "diggCount": 10,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16cece21e4cc47bc817f345abcfe0bfd.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142860413,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860413",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 756,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860413",
    "postTime": "2024-10-11 22:32:49",
    "diggCount": 13,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16cece21e4cc47bc817f345abcfe0bfd.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142860475,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860475",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 427,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860475",
    "postTime": "2024-10-11 22:32:43",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16cece21e4cc47bc817f345abcfe0bfd.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142860288,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860288",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 722,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860288",
    "postTime": "2024-10-11 22:32:37",
    "diggCount": 10,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16cece21e4cc47bc817f345abcfe0bfd.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142860451,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860451",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 813,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860451",
    "postTime": "2024-10-11 22:32:31",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/4623e588ca14457f867b5aa618627168.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142860452,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860452",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 721,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860452",
    "postTime": "2024-10-11 22:32:26",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16cece21e4cc47bc817f345abcfe0bfd.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142860392,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860392",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 958,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860392",
    "postTime": "2024-10-11 22:32:19",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/4623e588ca14457f867b5aa618627168.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142860426,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860426",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 788,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860426",
    "postTime": "2024-10-11 22:32:13",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16cece21e4cc47bc817f345abcfe0bfd.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142860449,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 785,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860449",
    "postTime": "2024-10-11 22:32:05",
    "diggCount": 20,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16cece21e4cc47bc817f345abcfe0bfd.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142860450,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860450",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 526,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860450",
    "postTime": "2024-10-11 22:31:59",
    "diggCount": 17,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16cece21e4cc47bc817f345abcfe0bfd.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142860373,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860373",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 483,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860373",
    "postTime": "2024-10-11 22:31:52",
    "diggCount": 7,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16cece21e4cc47bc817f345abcfe0bfd.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142860356,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860356",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 513,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860356",
    "postTime": "2024-10-11 22:31:45",
    "diggCount": 13,
    "formatTime": "2024.10.11",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/4623e588ca14457f867b5aa618627168.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142860337,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860337",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 479,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860337",
    "postTime": "2024-10-11 22:31:20",
    "diggCount": 12,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/cf4a6224874e42efae5076f10c4ebe5f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142860321,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860321",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 623,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860321",
    "postTime": "2024-10-11 22:30:34",
    "diggCount": 23,
    "formatTime": "2024.10.11",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/4623e588ca14457f867b5aa618627168.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142860300,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142860300",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 593,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142860300",
    "postTime": "2024-10-11 22:30:30",
    "diggCount": 22,
    "formatTime": "2024.10.11",
    "picList": [],
    "collectCount": 10
  },
  {
    "articleId": 142799188,
    "title": "如何设计可以动态扩容缩容的分库分表方案？-面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799188",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 563,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799188",
    "postTime": "2024-10-09 23:33:13",
    "diggCount": 12,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142799167,
    "title": "如何设计可以动态扩容缩容的分库分表方案？-面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799167",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 908,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799167",
    "postTime": "2024-10-09 23:32:39",
    "diggCount": 18,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142799180,
    "title": "面试题剖析5：如何设计可以动态扩容缩容的分库分表方案？",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799180",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 894,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799180",
    "postTime": "2024-10-09 23:32:35",
    "diggCount": 21,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142799127,
    "title": "如何设计可以动态扩容缩容的分库分表方案？-面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799127",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 463,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799127",
    "postTime": "2024-10-09 23:32:25",
    "diggCount": 10,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142799155,
    "title": "如何设计可以动态扩容缩容的分库分表方案？-面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799155",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 918,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799155",
    "postTime": "2024-10-09 23:32:22",
    "diggCount": 16,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142799111,
    "title": "如何设计可以动态扩容缩容的分库分表方案？-面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799111",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 797,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799111",
    "postTime": "2024-10-09 23:32:19",
    "diggCount": 24,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142799119,
    "title": "如何设计可以动态扩容缩容的分库分表方案？-面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799119",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 735,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799119",
    "postTime": "2024-10-09 23:32:16",
    "diggCount": 30,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142799142,
    "title": "面试题剖析2：如何设计可以动态扩容缩容的分库分表方案？",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799142",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 501,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799142",
    "postTime": "2024-10-09 23:29:38",
    "diggCount": 16,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142799104,
    "title": "如何设计可以动态扩容缩容的分库分表方案？-面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799104",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 711,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799104",
    "postTime": "2024-10-09 23:29:28",
    "diggCount": 14,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142799098,
    "title": "如何设计可以动态扩容缩容的分库分表方案？-面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799098",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 847,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799098",
    "postTime": "2024-10-09 23:28:45",
    "diggCount": 21,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142799086,
    "title": "如何设计可以动态扩容缩容的分库分表方案？-面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799086",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 944,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799086",
    "postTime": "2024-10-09 23:28:40",
    "diggCount": 20,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142799066,
    "title": "如何设计可以动态扩容缩容的分库分表方案？-面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799066",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 772,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799066",
    "postTime": "2024-10-09 23:28:36",
    "diggCount": 25,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142799093,
    "title": "面试题剖析4：如何设计可以动态扩容缩容的分库分表方案？",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799093",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 575,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799093",
    "postTime": "2024-10-09 23:28:24",
    "diggCount": 20,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142799077,
    "title": "面试题剖析3：如何设计可以动态扩容缩容的分库分表方案？",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799077",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 524,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799077",
    "postTime": "2024-10-09 23:28:19",
    "diggCount": 19,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142799006,
    "title": "面试题剖析1：如何设计可以动态扩容缩容的分库分表方案？",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142799006",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 506,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799006",
    "postTime": "2024-10-09 23:27:54",
    "diggCount": 5,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7970d40cad4f4e18b0d28caa9b19c804.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695173,
    "title": "阿里云高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142695173",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 380,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695173",
    "postTime": "2024-10-03 19:41:06",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142695169,
    "title": "阿里云高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142695169",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 368,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695169",
    "postTime": "2024-10-03 19:40:32",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142695161,
    "title": "阿里云高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142695161",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 244,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695161",
    "postTime": "2024-10-03 19:40:01",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142695148,
    "title": "阿里云高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142695148",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142695148",
    "postTime": "2024-10-03 19:39:20",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142694930,
    "title": "阿里云高频编程考题：旋转图像（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694930",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 969,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694930",
    "postTime": "2024-10-03 19:20:03",
    "diggCount": 20,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142694920,
    "title": "阿里云高频编程考题：搜索二维矩阵 II（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694920",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 319,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694920",
    "postTime": "2024-10-03 19:19:32",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142694914,
    "title": "阿里云高频编程考题：相交链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694914",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 622,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694914",
    "postTime": "2024-10-03 19:18:59",
    "diggCount": 12,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142694902,
    "title": "阿里云高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694902",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 219,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694902",
    "postTime": "2024-10-03 19:18:17",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142694893,
    "title": "阿里云高频编程考题：回文链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694893",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694893",
    "postTime": "2024-10-03 19:17:47",
    "diggCount": 9,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142694885,
    "title": "阿里云高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694885",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 233,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694885",
    "postTime": "2024-10-03 19:17:12",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142694875,
    "title": "阿里云高频编程考题：环形链表 II（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 261,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694875",
    "postTime": "2024-10-03 19:16:40",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142694862,
    "title": "阿里云高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694862",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 158,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694862",
    "postTime": "2024-10-03 19:16:10",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142694858,
    "title": "阿里云高频编程考题：两数相加（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694858",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 329,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694858",
    "postTime": "2024-10-03 19:15:39",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142694850,
    "title": "阿里云高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694850",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 162,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694850",
    "postTime": "2024-10-03 19:15:02",
    "diggCount": 6,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142694790,
    "title": "阿里云高频编程考题：两两交换链表中的节点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/JH8876434/article/details/142694790",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 120,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694790",
    "postTime": "2024-10-03 19:10:33",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681336,
    "title": "阿里云高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681336",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 222,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681336",
    "postTime": "2024-10-02 14:38:17",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681330,
    "title": "阿里云高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681330",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 275,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681330",
    "postTime": "2024-10-02 14:37:46",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681318,
    "title": "阿里云高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681318",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 131,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681318",
    "postTime": "2024-10-02 14:37:03",
    "diggCount": 1,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142681313,
    "title": "阿里云高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681313",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 161,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681313",
    "postTime": "2024-10-02 14:36:30",
    "diggCount": 6,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681310,
    "title": "阿里云高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681310",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 289,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681310",
    "postTime": "2024-10-02 14:35:57",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681300,
    "title": "阿里云高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681300",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681300",
    "postTime": "2024-10-02 14:35:20",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142681297,
    "title": "阿里云高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681297",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 255,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681297",
    "postTime": "2024-10-02 14:34:43",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142681291,
    "title": "阿里云高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681291",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 366,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681291",
    "postTime": "2024-10-02 14:34:10",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681285,
    "title": "阿里云高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681285",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 289,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681285",
    "postTime": "2024-10-02 14:33:40",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681276,
    "title": "阿里云高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681276",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681276",
    "postTime": "2024-10-02 14:33:07",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142681268,
    "title": "阿里云高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681268",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 315,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681268",
    "postTime": "2024-10-02 14:32:35",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142681262,
    "title": "阿里云高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681262",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 278,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681262",
    "postTime": "2024-10-02 14:32:05",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142681256,
    "title": "阿里云高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681256",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681256",
    "postTime": "2024-10-02 14:31:25",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681245,
    "title": "阿里云高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681245",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681245",
    "postTime": "2024-10-02 14:30:52",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681238,
    "title": "阿里云高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/JH8876434/article/details/142681238",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681238",
    "postTime": "2024-10-02 14:30:20",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143021782,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021782",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 513,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021782",
    "postTime": "2024-10-17 18:57:10",
    "diggCount": 25,
    "formatTime": "前天 18:57",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143021981,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021981",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 563,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021981",
    "postTime": "2024-10-17 18:57:08",
    "diggCount": 2,
    "formatTime": "前天 18:57",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143021865,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021865",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 578,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021865",
    "postTime": "2024-10-17 18:57:06",
    "diggCount": 4,
    "formatTime": "前天 18:57",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143021571,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021571",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 866,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021571",
    "postTime": "2024-10-17 18:57:03",
    "diggCount": 8,
    "formatTime": "前天 18:57",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 143021866,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021866",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 428,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021866",
    "postTime": "2024-10-17 18:57:01",
    "diggCount": 5,
    "formatTime": "前天 18:57",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143021910,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021910",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 369,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021910",
    "postTime": "2024-10-17 18:56:59",
    "diggCount": 9,
    "formatTime": "前天 18:56",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143021823,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021823",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 392,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021823",
    "postTime": "2024-10-17 18:56:57",
    "diggCount": 20,
    "formatTime": "前天 18:56",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 143021945,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021945",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 414,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021945",
    "postTime": "2024-10-17 18:56:54",
    "diggCount": 16,
    "formatTime": "前天 18:56",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143021726,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021726",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 836,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021726",
    "postTime": "2024-10-17 18:56:52",
    "diggCount": 18,
    "formatTime": "前天 18:56",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 143021683,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021683",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 559,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021683",
    "postTime": "2024-10-17 18:56:49",
    "diggCount": 15,
    "formatTime": "前天 18:56",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 143021633,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021633",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 605,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021633",
    "postTime": "2024-10-17 18:56:47",
    "diggCount": 13,
    "formatTime": "前天 18:56",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 143021593,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021593",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 552,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021593",
    "postTime": "2024-10-17 18:56:45",
    "diggCount": 15,
    "formatTime": "前天 18:56",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143026091,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3​",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143026091",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 544,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143026091",
    "postTime": "2024-10-17 18:56:43",
    "diggCount": 11,
    "formatTime": "前天 18:56",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143021554,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021554",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 591,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021554",
    "postTime": "2024-10-17 16:08:10",
    "diggCount": 14,
    "formatTime": "前天 16:08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 143021524,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/BXL3456/article/details/143021524",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 891,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143021524",
    "postTime": "2024-10-17 16:08:07",
    "diggCount": 13,
    "formatTime": "前天 16:08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142903594,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903594",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903594",
    "postTime": "2024-10-13 20:21:57",
    "diggCount": 6,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142903381,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903381",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903381",
    "postTime": "2024-10-13 20:21:46",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142903424,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903424",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 240,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903424",
    "postTime": "2024-10-13 20:21:43",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142903396,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903396",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 357,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903396",
    "postTime": "2024-10-13 20:21:40",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142903413,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903413",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 336,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903413",
    "postTime": "2024-10-13 20:21:37",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142903423,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903423",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 281,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903423",
    "postTime": "2024-10-13 20:21:35",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142903395,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903395",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903395",
    "postTime": "2024-10-13 20:21:26",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142903467,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903467",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903467",
    "postTime": "2024-10-13 20:21:24",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142903480,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903480",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 468,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903480",
    "postTime": "2024-10-13 20:21:21",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142903449,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 304,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903449",
    "postTime": "2024-10-13 20:21:19",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142903339,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903339",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 383,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903339",
    "postTime": "2024-10-13 20:21:16",
    "diggCount": 6,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142903354,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903354",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 403,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903354",
    "postTime": "2024-10-13 20:21:13",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142903322,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903322",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903322",
    "postTime": "2024-10-13 20:21:10",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142903311,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903311",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 403,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903311",
    "postTime": "2024-10-13 20:21:07",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142903287,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142903287",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 383,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903287",
    "postTime": "2024-10-13 20:21:04",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142891474,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891474",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 272,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891474",
    "postTime": "2024-10-12 23:51:14",
    "diggCount": 6,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891453,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891453",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 126,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891453",
    "postTime": "2024-10-12 23:51:10",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891484,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891484",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 116,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891484",
    "postTime": "2024-10-12 23:51:08",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891426,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891426",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 171,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891426",
    "postTime": "2024-10-12 23:51:05",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891475,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891475",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 298,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891475",
    "postTime": "2024-10-12 23:51:02",
    "diggCount": 6,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891441,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891441",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 156,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891441",
    "postTime": "2024-10-12 23:50:59",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891485,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891485",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 164,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891485",
    "postTime": "2024-10-12 23:50:56",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891461,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891461",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 116,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891461",
    "postTime": "2024-10-12 23:50:54",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891414,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891414",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 151,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891414",
    "postTime": "2024-10-12 23:50:51",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891400,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891400",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 174,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891400",
    "postTime": "2024-10-12 23:50:48",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891388,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891388",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 129,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891388",
    "postTime": "2024-10-12 23:50:45",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891378,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891378",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 93,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891378",
    "postTime": "2024-10-12 23:50:42",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891367,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891367",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 94,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891367",
    "postTime": "2024-10-12 23:50:39",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891358,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891358",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 71,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891358",
    "postTime": "2024-10-12 23:50:36",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891498,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142891498",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 179,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891498",
    "postTime": "2024-10-12 23:50:31",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8a1f6583bae34a8993b7beae8a775ad6.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142865047,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142865047",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 684,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865047",
    "postTime": "2024-10-11 22:48:58",
    "diggCount": 6,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142865008,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142865008",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 760,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865008",
    "postTime": "2024-10-11 22:48:26",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142865024,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142865024",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 634,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865024",
    "postTime": "2024-10-11 22:48:23",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142865039,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142865039",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 660,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865039",
    "postTime": "2024-10-11 22:48:20",
    "diggCount": 13,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142864915,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864915",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 633,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864915",
    "postTime": "2024-10-11 22:48:15",
    "diggCount": 9,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142864987,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864987",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 889,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864987",
    "postTime": "2024-10-11 22:45:02",
    "diggCount": 16,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142864978,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864978",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 602,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864978",
    "postTime": "2024-10-11 22:44:57",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142864960,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864960",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 505,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864960",
    "postTime": "2024-10-11 22:44:04",
    "diggCount": 22,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142864971,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864971",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 433,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864971",
    "postTime": "2024-10-11 22:43:51",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142864933,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864933",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 745,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864933",
    "postTime": "2024-10-11 22:42:12",
    "diggCount": 22,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142864946,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864946",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 843,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864946",
    "postTime": "2024-10-11 22:42:08",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142864912,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864912",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 521,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864912",
    "postTime": "2024-10-11 22:39:56",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142864878,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864878",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 849,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864878",
    "postTime": "2024-10-11 22:39:53",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142864894,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864894",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 574,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864894",
    "postTime": "2024-10-11 22:39:50",
    "diggCount": 12,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142864856,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142864856",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 731,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142864856",
    "postTime": "2024-10-11 22:39:45",
    "diggCount": 24,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fbea461efb88492ea2c454fec0c279cd.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142694723,
    "title": "高德高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694723",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 404,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694723",
    "postTime": "2024-10-03 19:02:51",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142694718,
    "title": "高德高频编程考题：回文链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694718",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 135,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694718",
    "postTime": "2024-10-03 19:02:18",
    "diggCount": 1,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142694709,
    "title": "高德高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694709",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 244,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694709",
    "postTime": "2024-10-03 19:01:46",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142694702,
    "title": "高德高频编程考题：相交链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694702",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1019,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694702",
    "postTime": "2024-10-03 19:01:12",
    "diggCount": 13,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142694694,
    "title": "高德高频编程考题：搜索二维矩阵 II（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694694",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 263,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694694",
    "postTime": "2024-10-03 19:00:41",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142694689,
    "title": "高德高频编程考题：旋转图像（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694689",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 425,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694689",
    "postTime": "2024-10-03 19:00:04",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142694681,
    "title": "高德高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 344,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694681",
    "postTime": "2024-10-03 18:59:29",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142694677,
    "title": "高德高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694677",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 257,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694677",
    "postTime": "2024-10-03 18:58:55",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142694671,
    "title": "高德高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694671",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694671",
    "postTime": "2024-10-03 18:58:20",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142694616,
    "title": "高德高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694616",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 346,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694616",
    "postTime": "2024-10-03 18:52:15",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681181,
    "title": "高德高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681181",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 250,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681181",
    "postTime": "2024-10-02 14:25:02",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142681174,
    "title": "高德高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681174",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 305,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681174",
    "postTime": "2024-10-02 14:24:28",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142681156,
    "title": "高德高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681156",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 334,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681156",
    "postTime": "2024-10-02 14:23:11",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142681147,
    "title": "高德高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681147",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 385,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681147",
    "postTime": "2024-10-02 14:22:31",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142681140,
    "title": "高德高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681140",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 429,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681140",
    "postTime": "2024-10-02 14:21:59",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142681130,
    "title": "高德高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681130",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 257,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681130",
    "postTime": "2024-10-02 14:21:30",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142681107,
    "title": "高德高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681107",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681107",
    "postTime": "2024-10-02 14:19:08",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681096,
    "title": "高德高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681096",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 346,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681096",
    "postTime": "2024-10-02 14:18:31",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681088,
    "title": "高德高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681088",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681088",
    "postTime": "2024-10-02 14:17:58",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142681084,
    "title": "高德高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681084",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 273,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681084",
    "postTime": "2024-10-02 14:17:24",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142681072,
    "title": "高德高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681072",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 406,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681072",
    "postTime": "2024-10-02 14:16:48",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142681062,
    "title": "高德高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681062",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 151,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681062",
    "postTime": "2024-10-02 14:16:10",
    "diggCount": 6,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142681049,
    "title": "高德高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681049",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 249,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681049",
    "postTime": "2024-10-02 14:15:33",
    "diggCount": 6,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142681042,
    "title": "高德高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681042",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681042",
    "postTime": "2024-10-02 14:14:56",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142681035,
    "title": "高德高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142681035",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 351,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142681035",
    "postTime": "2024-10-02 14:14:11",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142799435,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799435",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 885,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799435",
    "postTime": "2024-10-09 23:52:04",
    "diggCount": 16,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142799429,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799429",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 620,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799429",
    "postTime": "2024-10-09 23:51:32",
    "diggCount": 14,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142799420,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799420",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 633,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799420",
    "postTime": "2024-10-09 23:50:54",
    "diggCount": 18,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142799405,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799405",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1010,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799405",
    "postTime": "2024-10-09 23:49:40",
    "diggCount": 21,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142799377,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799377",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 777,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799377",
    "postTime": "2024-10-09 23:48:08",
    "diggCount": 8,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142799364,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799364",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 776,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799364",
    "postTime": "2024-10-09 23:48:03",
    "diggCount": 14,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142799346,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799346",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 688,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799346",
    "postTime": "2024-10-09 23:47:54",
    "diggCount": 19,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142799330,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "大背景对于分库分表来说，主要是面对以下问题：选择一个数据库中间件，调研、学习、测试；\t设计你的分库分表的一个方案，你要分成多少个库，每个库分成多少个表，比如 3 个库，每个库 4 个表；\t基于选择好的数据库中间件，以及在测试环境建立好的分库分表的环境，然后测试一下能否正常进行分库分表的读写；\t完成单库单表到分库分表的迁移，双写方案；\t线上系统开始基于分库分表对外提供服务；\t扩容了，扩容成 6 个库，每个库需要 12 个表，你怎么来增加更多库和表呢？这个是你必须面对的一个事儿，就是你",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799330",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 563,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799330",
    "postTime": "2024-10-09 23:44:55",
    "diggCount": 15,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142799313,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799313",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 585,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799313",
    "postTime": "2024-10-09 23:44:41",
    "diggCount": 21,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142799304,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 760,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799304",
    "postTime": "2024-10-09 23:44:37",
    "diggCount": 24,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142799281,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799281",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 869,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799281",
    "postTime": "2024-10-09 23:44:33",
    "diggCount": 30,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142799296,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799296",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 737,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799296",
    "postTime": "2024-10-09 23:44:26",
    "diggCount": 7,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142799321,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799321",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 633,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799321",
    "postTime": "2024-10-09 23:44:21",
    "diggCount": 19,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142799289,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799289",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 466,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799289",
    "postTime": "2024-10-09 23:41:11",
    "diggCount": 25,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142799256,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "每个库正常承载的写入并发量是 1000，那么 32 个库就可以承载 32 * 1000 = 32000 的写并发，如果每个库承载 1500 的写并发，32 * 1500 = 48000 的写并发，接近 5 万每秒的写入并发，前面再加一个MQ，削峰，每秒写入 MQ 8 万条数据，每秒消费 5 万条数据。光是导 2 亿数据，都要导个几个小时，6 点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10 点才可以搞完。就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。",
    "url": "https://blog.csdn.net/BXL3456/article/details/142799256",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 955,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799256",
    "postTime": "2024-10-09 23:41:00",
    "diggCount": 29,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c1601d22d0d4e2bbd57fa43d5693904.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142694778,
    "title": "高德高频编程考题：两两交换链表中的节点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694778",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 158,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694778",
    "postTime": "2024-10-03 19:09:01",
    "diggCount": 6,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142694748,
    "title": "高德高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694748",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 223,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694748",
    "postTime": "2024-10-03 19:05:02",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142694740,
    "title": "高德高频编程考题：两数相加（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694740",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 356,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694740",
    "postTime": "2024-10-03 19:04:29",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142694735,
    "title": "高德高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694735",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 200,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694735",
    "postTime": "2024-10-03 19:03:54",
    "diggCount": 9,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142694732,
    "title": "高德高频编程考题：环形链表 II（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/BXL3456/article/details/142694732",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 422,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142694732",
    "postTime": "2024-10-03 19:03:24",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 143027722,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027722",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 737,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027722",
    "postTime": "2024-10-17 20:35:00",
    "diggCount": 21,
    "formatTime": "前天 20:35",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 143027708,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027708",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 526,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027708",
    "postTime": "2024-10-17 20:34:57",
    "diggCount": 20,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 143027743,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027743",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 725,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027743",
    "postTime": "2024-10-17 20:34:54",
    "diggCount": 8,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143027686,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027686",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027686",
    "postTime": "2024-10-17 20:34:51",
    "diggCount": 13,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 143027554,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027554",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 468,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027554",
    "postTime": "2024-10-17 20:34:48",
    "diggCount": 9,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 143027744,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027744",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 800,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027744",
    "postTime": "2024-10-17 20:34:45",
    "diggCount": 20,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143027760,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027760",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027760",
    "postTime": "2024-10-17 20:34:41",
    "diggCount": 18,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143027662,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027662",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 614,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027662",
    "postTime": "2024-10-17 20:34:38",
    "diggCount": 9,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 143027638,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027638",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 444,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027638",
    "postTime": "2024-10-17 20:34:35",
    "diggCount": 13,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 143027613,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027613",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 680,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027613",
    "postTime": "2024-10-17 20:34:32",
    "diggCount": 7,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143027585,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027585",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 751,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027585",
    "postTime": "2024-10-17 20:34:29",
    "diggCount": 18,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143027568,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027568",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 721,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027568",
    "postTime": "2024-10-17 20:34:22",
    "diggCount": 17,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 143027808,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027808",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 583,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027808",
    "postTime": "2024-10-17 20:34:19",
    "diggCount": 7,
    "formatTime": "前天 20:34",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143027540,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027540",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 504,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027540",
    "postTime": "2024-10-17 20:21:56",
    "diggCount": 19,
    "formatTime": "前天 20:21",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 143027521,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/143027521",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 839,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027521",
    "postTime": "2024-10-17 20:21:52",
    "diggCount": 12,
    "formatTime": "前天 20:21",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142903713,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903713",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 410,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903713",
    "postTime": "2024-10-13 20:42:08",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142903819,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903819",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 316,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903819",
    "postTime": "2024-10-13 20:42:02",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142903832,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903832",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 478,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903832",
    "postTime": "2024-10-13 20:41:57",
    "diggCount": 12,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142903729,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903729",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 335,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903729",
    "postTime": "2024-10-13 20:41:52",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142903740,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903740",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 218,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903740",
    "postTime": "2024-10-13 20:41:46",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142903798,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903798",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 382,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903798",
    "postTime": "2024-10-13 20:41:41",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142903806,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903806",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 215,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903806",
    "postTime": "2024-10-13 20:41:35",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142903861,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903861",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 474,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903861",
    "postTime": "2024-10-13 20:39:37",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142903773,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903773",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 365,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903773",
    "postTime": "2024-10-13 20:34:43",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142903757,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 214,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903757",
    "postTime": "2024-10-13 20:32:16",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142903673,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903673",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 367,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903673",
    "postTime": "2024-10-13 20:32:11",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142903691,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903691",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 401,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903691",
    "postTime": "2024-10-13 20:32:08",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142903658,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 345,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903658",
    "postTime": "2024-10-13 20:32:04",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142903637,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903637",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 216,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903637",
    "postTime": "2024-10-13 20:28:05",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142903625,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142903625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 404,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903625",
    "postTime": "2024-10-13 20:28:02",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142891676,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891676",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 163,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891676",
    "postTime": "2024-10-13 00:05:04",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891670,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891670",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 258,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891670",
    "postTime": "2024-10-13 00:04:08",
    "diggCount": 6,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891665,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891665",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 104,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891665",
    "postTime": "2024-10-13 00:03:24",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891661,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891661",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 141,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891661",
    "postTime": "2024-10-13 00:02:45",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891657,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891657",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 151,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891657",
    "postTime": "2024-10-13 00:02:09",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891621,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891621",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 160,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891621",
    "postTime": "2024-10-13 00:01:48",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891640,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891640",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 197,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891640",
    "postTime": "2024-10-13 00:01:44",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891652,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891652",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 199,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891652",
    "postTime": "2024-10-13 00:01:37",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891645,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891645",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 206,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891645",
    "postTime": "2024-10-13 00:00:57",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891624,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891624",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 91,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891624",
    "postTime": "2024-10-12 23:58:15",
    "diggCount": 3,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891591,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891591",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 95,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891591",
    "postTime": "2024-10-12 23:57:14",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891613,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891613",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 204,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891613",
    "postTime": "2024-10-12 23:57:09",
    "diggCount": 9,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891602,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891602",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 171,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891602",
    "postTime": "2024-10-12 23:56:23",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891581,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891581",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 99,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891581",
    "postTime": "2024-10-12 23:54:36",
    "diggCount": 2,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142891568,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142891568",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 179,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142891568",
    "postTime": "2024-10-12 23:54:00",
    "diggCount": 1,
    "formatTime": "2024.10.12",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9fa241f81734a1eacc4be1b7bc15b66.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142865157,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865157",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 589,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865157",
    "postTime": "2024-10-11 23:06:36",
    "diggCount": 9,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142865220,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865220",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 701,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865220",
    "postTime": "2024-10-11 23:06:33",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142865134,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865134",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 662,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865134",
    "postTime": "2024-10-11 23:06:30",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142865267,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865267",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 648,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865267",
    "postTime": "2024-10-11 23:06:26",
    "diggCount": 6,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142865278,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865278",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 882,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865278",
    "postTime": "2024-10-11 23:06:20",
    "diggCount": 11,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142865257,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865257",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 821,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865257",
    "postTime": "2024-10-11 23:06:17",
    "diggCount": 23,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142865245,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865245",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 912,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865245",
    "postTime": "2024-10-11 23:01:54",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142865183,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865183",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 556,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865183",
    "postTime": "2024-10-11 23:01:51",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142865235,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865235",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 757,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865235",
    "postTime": "2024-10-11 23:01:48",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142865194,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865194",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 547,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865194",
    "postTime": "2024-10-11 23:01:45",
    "diggCount": 13,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142865164,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865164",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 611,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865164",
    "postTime": "2024-10-11 23:01:43",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142865144,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865144",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 816,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865144",
    "postTime": "2024-10-11 22:56:53",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142865171,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865171",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 841,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865171",
    "postTime": "2024-10-11 22:56:50",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142865129,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865129",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 475,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865129",
    "postTime": "2024-10-11 22:54:37",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3e2db3747d2e45cfb198e266708a01b7.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142865112,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142865112",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 784,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865112",
    "postTime": "2024-10-11 22:54:32",
    "diggCount": 15,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8754aa8bbd1946da9e5eedc9d3a7c033.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142799602,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799602",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 576,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799602",
    "postTime": "2024-10-10 00:07:17",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142799598,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799598",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 858,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799598",
    "postTime": "2024-10-10 00:06:34",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142799593,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799593",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 876,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799593",
    "postTime": "2024-10-10 00:05:55",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142799588,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799588",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 669,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799588",
    "postTime": "2024-10-10 00:05:02",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142799556,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799556",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 585,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799556",
    "postTime": "2024-10-10 00:03:34",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142799572,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799572",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 882,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799572",
    "postTime": "2024-10-10 00:03:24",
    "diggCount": 5,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142799548,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799548",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 443,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799548",
    "postTime": "2024-10-10 00:01:03",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142799540,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799540",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 584,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799540",
    "postTime": "2024-10-10 00:00:45",
    "diggCount": 17,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142799523,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799523",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 526,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799523",
    "postTime": "2024-10-10 00:00:07",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142799532,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799532",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 435,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799532",
    "postTime": "2024-10-10 00:00:02",
    "diggCount": 22,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142799516,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799516",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 776,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799516",
    "postTime": "2024-10-09 23:58:52",
    "diggCount": 32,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142799507,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799507",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 867,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799507",
    "postTime": "2024-10-09 23:58:19",
    "diggCount": 15,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142799498,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799498",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 722,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799498",
    "postTime": "2024-10-09 23:57:33",
    "diggCount": 19,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142799491,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799491",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 757,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799491",
    "postTime": "2024-10-09 23:57:30",
    "diggCount": 24,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142799475,
    "title": "如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142799475",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 558,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799475",
    "postTime": "2024-10-09 23:57:26",
    "diggCount": 13,
    "formatTime": "2024.10.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9c2f4d4dfe4341e897c2f3c4d15f9f70.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142689732,
    "title": "美团高频编程考题：两两交换链表中的节点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689732",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 215,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689732",
    "postTime": "2024-10-03 10:36:24",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142689726,
    "title": "美团高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689726",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 267,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689726",
    "postTime": "2024-10-03 10:35:45",
    "diggCount": 1,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142689720,
    "title": "美团高频编程考题：两数相加（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689720",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 247,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689720",
    "postTime": "2024-10-03 10:35:10",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142689713,
    "title": "美团高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689713",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 256,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689713",
    "postTime": "2024-10-03 10:34:34",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142689709,
    "title": "美团高频编程考题：环形链表 II（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689709",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689709",
    "postTime": "2024-10-03 10:34:01",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142689685,
    "title": "美团高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689685",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 358,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689685",
    "postTime": "2024-10-03 10:31:57",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142689676,
    "title": "美团高频编程考题：回文链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689676",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 261,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689676",
    "postTime": "2024-10-03 10:31:17",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142689670,
    "title": "美团高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689670",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 420,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689670",
    "postTime": "2024-10-03 10:30:45",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142689659,
    "title": "美团高频编程考题：相交链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689659",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 313,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689659",
    "postTime": "2024-10-03 10:30:11",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142689654,
    "title": "美团高频编程考题：搜索二维矩阵 II（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689654",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 299,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689654",
    "postTime": "2024-10-03 10:29:37",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142689647,
    "title": "美团高频编程考题：旋转图像（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689647",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 963,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689647",
    "postTime": "2024-10-03 10:29:02",
    "diggCount": 14,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142689640,
    "title": "美团高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689640",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689640",
    "postTime": "2024-10-03 10:28:28",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142689636,
    "title": "美团高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689636",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 413,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689636",
    "postTime": "2024-10-03 10:27:52",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142689629,
    "title": "美团高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689629",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 349,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689629",
    "postTime": "2024-10-03 10:27:22",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142689621,
    "title": "美团高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142689621",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 419,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689621",
    "postTime": "2024-10-03 10:26:50",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142680975,
    "title": "美团高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680975",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 381,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680975",
    "postTime": "2024-10-02 14:08:12",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142680965,
    "title": "美团高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680965",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 386,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680965",
    "postTime": "2024-10-02 14:07:27",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142680960,
    "title": "美团高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680960",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 164,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680960",
    "postTime": "2024-10-02 14:06:55",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142680954,
    "title": "美团高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680954",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 257,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680954",
    "postTime": "2024-10-02 14:06:18",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142680949,
    "title": "美团高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680949",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 292,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680949",
    "postTime": "2024-10-02 14:05:47",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142680938,
    "title": "美团高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680938",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 368,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680938",
    "postTime": "2024-10-02 14:05:07",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142680929,
    "title": "美团高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680929",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 315,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680929",
    "postTime": "2024-10-02 14:04:36",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142680922,
    "title": "美团高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680922",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 230,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680922",
    "postTime": "2024-10-02 14:04:05",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142680916,
    "title": "美团高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680916",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 330,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680916",
    "postTime": "2024-10-02 14:03:26",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142680906,
    "title": "美团高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680906",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 367,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680906",
    "postTime": "2024-10-02 14:02:39",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142680868,
    "title": "美团高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680868",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 420,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680868",
    "postTime": "2024-10-02 13:58:09",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142680861,
    "title": "美团高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680861",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 385,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680861",
    "postTime": "2024-10-02 13:57:29",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142680853,
    "title": "美团高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680853",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 345,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680853",
    "postTime": "2024-10-02 13:56:58",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142680845,
    "title": "美团高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680845",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 380,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680845",
    "postTime": "2024-10-02 13:56:20",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142680838,
    "title": "美团高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/XWL9875435/article/details/142680838",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 325,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680838",
    "postTime": "2024-10-02 13:55:49",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 143028148,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143028148",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 550,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028148",
    "postTime": "2024-10-17 20:51:06",
    "diggCount": 21,
    "formatTime": "前天 20:51",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 143027890,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143027890",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 332,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027890",
    "postTime": "2024-10-17 20:51:03",
    "diggCount": 8,
    "formatTime": "前天 20:51",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 143028070,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143028070",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 497,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028070",
    "postTime": "2024-10-17 20:50:59",
    "diggCount": 21,
    "formatTime": "前天 20:50",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143028090,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143028090",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 492,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028090",
    "postTime": "2024-10-17 20:50:56",
    "diggCount": 13,
    "formatTime": "前天 20:50",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 143028021,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143028021",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 378,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028021",
    "postTime": "2024-10-17 20:50:51",
    "diggCount": 4,
    "formatTime": "前天 20:50",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143028123,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143028123",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 621,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028123",
    "postTime": "2024-10-17 20:50:48",
    "diggCount": 14,
    "formatTime": "前天 20:50",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 143028044,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143028044",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 409,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028044",
    "postTime": "2024-10-17 20:50:44",
    "diggCount": 12,
    "formatTime": "前天 20:50",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143028071,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143028071",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 750,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028071",
    "postTime": "2024-10-17 20:50:40",
    "diggCount": 17,
    "formatTime": "前天 20:50",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 143028191,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143028191",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 418,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028191",
    "postTime": "2024-10-17 20:50:35",
    "diggCount": 17,
    "formatTime": "前天 20:50",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 143028168,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143028168",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 532,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028168",
    "postTime": "2024-10-17 20:49:32",
    "diggCount": 8,
    "formatTime": "前天 20:49",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143027988,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143027988",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 302,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027988",
    "postTime": "2024-10-17 20:46:41",
    "diggCount": 13,
    "formatTime": "前天 20:46",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 143027956,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143027956",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 595,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027956",
    "postTime": "2024-10-17 20:46:37",
    "diggCount": 5,
    "formatTime": "前天 20:46",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 143027929,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143027929",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 747,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027929",
    "postTime": "2024-10-17 20:46:35",
    "diggCount": 5,
    "formatTime": "前天 20:46",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 143027909,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143027909",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 589,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027909",
    "postTime": "2024-10-17 20:46:32",
    "diggCount": 11,
    "formatTime": "前天 20:46",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 143027877,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/143027877",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 912,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143027877",
    "postTime": "2024-10-17 20:38:05",
    "diggCount": 11,
    "formatTime": "前天 20:38",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142931022,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142931022",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 251,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931022",
    "postTime": "2024-10-14 22:54:43",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142930968,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930968",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 305,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930968",
    "postTime": "2024-10-14 22:54:39",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142930981,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930981",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 389,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930981",
    "postTime": "2024-10-14 22:54:36",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142930969,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930969",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 385,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930969",
    "postTime": "2024-10-14 22:54:29",
    "diggCount": 3,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142930996,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930996",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 238,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930996",
    "postTime": "2024-10-14 22:54:25",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142931005,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142931005",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 325,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931005",
    "postTime": "2024-10-14 22:54:20",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142930980,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930980",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 228,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930980",
    "postTime": "2024-10-14 22:54:16",
    "diggCount": 3,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142930997,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930997",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 364,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930997",
    "postTime": "2024-10-14 22:54:12",
    "diggCount": 3,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142930921,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930921",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 247,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930921",
    "postTime": "2024-10-14 22:54:08",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142930904,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930904",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 372,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930904",
    "postTime": "2024-10-14 22:54:05",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142930884,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930884",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 283,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930884",
    "postTime": "2024-10-14 22:54:01",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142930995,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930995",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 280,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930995",
    "postTime": "2024-10-14 22:49:51",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142930942,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930942",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 264,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930942",
    "postTime": "2024-10-14 22:48:48",
    "diggCount": 3,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142930866,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930866",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 275,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930866",
    "postTime": "2024-10-14 22:46:57",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142930850,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142930850",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 236,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930850",
    "postTime": "2024-10-14 22:46:53",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142895727,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895727",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 181,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895727",
    "postTime": "2024-10-13 11:30:03",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895761,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895761",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 91,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895761",
    "postTime": "2024-10-13 11:29:57",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895775,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895775",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 180,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895775",
    "postTime": "2024-10-13 11:29:51",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895814,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895814",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 198,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895814",
    "postTime": "2024-10-13 11:29:41",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895834,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895834",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 100,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895834",
    "postTime": "2024-10-13 11:29:31",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895875,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895875",
    "postTime": "2024-10-13 11:29:21",
    "diggCount": 10,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895908,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895908",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 99,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895908",
    "postTime": "2024-10-13 11:29:11",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895853,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895853",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 222,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895853",
    "postTime": "2024-10-13 11:29:01",
    "diggCount": 9,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895891,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895891",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 276,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895891",
    "postTime": "2024-10-13 11:28:51",
    "diggCount": 7,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895792,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895792",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 97,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895792",
    "postTime": "2024-10-13 11:28:31",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895740,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895740",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 175,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895740",
    "postTime": "2024-10-13 11:27:32",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895703,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895703",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 156,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895703",
    "postTime": "2024-10-13 11:27:24",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895681,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 135,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895681",
    "postTime": "2024-10-13 11:27:17",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895667,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895667",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 132,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895667",
    "postTime": "2024-10-13 11:27:09",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895648,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142895648",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 181,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895648",
    "postTime": "2024-10-13 11:26:59",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fea43ed9dba64f6e849c0debe3effda4.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142865513,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865513",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 502,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865513",
    "postTime": "2024-10-11 23:26:35",
    "diggCount": 16,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142865477,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865477",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 836,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865477",
    "postTime": "2024-10-11 23:26:31",
    "diggCount": 7,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142865454,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865454",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 680,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865454",
    "postTime": "2024-10-11 23:26:28",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142865464,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 657,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865464",
    "postTime": "2024-10-11 23:26:25",
    "diggCount": 20,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142865448,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865448",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 903,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865448",
    "postTime": "2024-10-11 23:26:22",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142865522,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865522",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 813,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865522",
    "postTime": "2024-10-11 23:26:19",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142865465,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865465",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 838,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865465",
    "postTime": "2024-10-11 23:21:50",
    "diggCount": 7,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142865495,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865495",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 384,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865495",
    "postTime": "2024-10-11 23:21:46",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142865486,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865486",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 440,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865486",
    "postTime": "2024-10-11 23:21:07",
    "diggCount": 10,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142865433,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865433",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 706,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865433",
    "postTime": "2024-10-11 23:19:16",
    "diggCount": 9,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142865422,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865422",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 602,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865422",
    "postTime": "2024-10-11 23:15:25",
    "diggCount": 11,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142865402,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865402",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 869,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865402",
    "postTime": "2024-10-11 23:15:20",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142865388,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865388",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 719,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865388",
    "postTime": "2024-10-11 23:15:16",
    "diggCount": 9,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142865375,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865375",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 547,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865375",
    "postTime": "2024-10-11 23:13:59",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142865357,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142865357",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 723,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865357",
    "postTime": "2024-10-11 23:13:56",
    "diggCount": 8,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f294fd838e1401f803bc414c1d24238.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142799715,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799715",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 919,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799715",
    "postTime": "2024-10-10 00:21:31",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142799706,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799706",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 705,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799706",
    "postTime": "2024-10-10 00:20:49",
    "diggCount": 18,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142799699,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799699",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 446,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799699",
    "postTime": "2024-10-10 00:20:17",
    "diggCount": 9,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142799681,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 592,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799681",
    "postTime": "2024-10-10 00:19:38",
    "diggCount": 16,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142799666,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799666",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 736,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799666",
    "postTime": "2024-10-10 00:19:32",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142799690,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799690",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 714,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799690",
    "postTime": "2024-10-10 00:19:17",
    "diggCount": 14,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142799672,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799672",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 445,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799672",
    "postTime": "2024-10-10 00:17:32",
    "diggCount": 6,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142799664,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799664",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 669,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799664",
    "postTime": "2024-10-10 00:16:18",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142799658,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 615,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799658",
    "postTime": "2024-10-10 00:16:14",
    "diggCount": 9,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142799625,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 731,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799625",
    "postTime": "2024-10-10 00:16:08",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142799648,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799648",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 413,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799648",
    "postTime": "2024-10-10 00:16:04",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142799642,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799642",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 880,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799642",
    "postTime": "2024-10-10 00:13:22",
    "diggCount": 23,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142799636,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799636",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 494,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799636",
    "postTime": "2024-10-10 00:13:18",
    "diggCount": 24,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142799632,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799632",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 551,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799632",
    "postTime": "2024-10-10 00:13:14",
    "diggCount": 16,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/782fa7900cd44a6685d4fa583bab5752.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142799620,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142799620",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 660,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799620",
    "postTime": "2024-10-10 00:10:36",
    "diggCount": 15,
    "formatTime": "2024.10.10",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/4623e588ca14457f867b5aa618627168.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142689576,
    "title": "字节高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689576",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 292,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689576",
    "postTime": "2024-10-03 10:22:29",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142689568,
    "title": "字节高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689568",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 237,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689568",
    "postTime": "2024-10-03 10:21:55",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142689564,
    "title": "字节高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689564",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 378,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689564",
    "postTime": "2024-10-03 10:21:25",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142689558,
    "title": "字节高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689558",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689558",
    "postTime": "2024-10-03 10:20:46",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142689550,
    "title": "字节高频编程考题：旋转图像（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689550",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 767,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689550",
    "postTime": "2024-10-03 10:20:12",
    "diggCount": 26,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142689545,
    "title": "字节高频编程考题：搜索二维矩阵 II（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689545",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 405,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689545",
    "postTime": "2024-10-03 10:19:32",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142689537,
    "title": "字节高频编程考题：相交链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689537",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 874,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689537",
    "postTime": "2024-10-03 10:18:48",
    "diggCount": 27,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142689531,
    "title": "字节高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689531",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 220,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689531",
    "postTime": "2024-10-03 10:18:17",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142689528,
    "title": "字节高频编程考题：回文链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689528",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 255,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689528",
    "postTime": "2024-10-03 10:17:44",
    "diggCount": 7,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142689524,
    "title": "字节高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689524",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689524",
    "postTime": "2024-10-03 10:17:09",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142689522,
    "title": "字节高频编程考题：环形链表 II（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689522",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689522",
    "postTime": "2024-10-03 10:16:36",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142689518,
    "title": "字节高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689518",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 181,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689518",
    "postTime": "2024-10-03 10:16:05",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142689511,
    "title": "字节高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689511",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689511",
    "postTime": "2024-10-03 10:15:30",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142689507,
    "title": "字节高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689507",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 278,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689507",
    "postTime": "2024-10-03 10:14:54",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142689498,
    "title": "字节高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142689498",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 165,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689498",
    "postTime": "2024-10-03 10:14:21",
    "diggCount": 8,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142680801,
    "title": "字节高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680801",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 321,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680801",
    "postTime": "2024-10-02 13:50:27",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142680794,
    "title": "字节高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680794",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 331,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680794",
    "postTime": "2024-10-02 13:49:55",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142680792,
    "title": "字节高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680792",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 281,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680792",
    "postTime": "2024-10-02 13:49:17",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142680786,
    "title": "字节高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680786",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 341,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680786",
    "postTime": "2024-10-02 13:48:37",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142680779,
    "title": "字节高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680779",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 425,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680779",
    "postTime": "2024-10-02 13:48:05",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142680775,
    "title": "字节高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680775",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680775",
    "postTime": "2024-10-02 13:47:31",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142680771,
    "title": "字节高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680771",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 306,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680771",
    "postTime": "2024-10-02 13:46:58",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142680757,
    "title": "字节高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 385,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680757",
    "postTime": "2024-10-02 13:46:00",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142680753,
    "title": "字节高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680753",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680753",
    "postTime": "2024-10-02 13:45:28",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142680747,
    "title": "字节高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680747",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 356,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680747",
    "postTime": "2024-10-02 13:44:50",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142680739,
    "title": "字节高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680739",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 255,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680739",
    "postTime": "2024-10-02 13:44:07",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142680732,
    "title": "字节高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680732",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680732",
    "postTime": "2024-10-02 13:43:15",
    "diggCount": 10,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142680720,
    "title": "字节高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680720",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 175,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680720",
    "postTime": "2024-10-02 13:42:29",
    "diggCount": 1,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142680631,
    "title": "字节高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680631",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 360,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680631",
    "postTime": "2024-10-02 13:33:07",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142680623,
    "title": "字节高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/ZWL53223456789/article/details/142680623",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680623",
    "postTime": "2024-10-02 13:32:23",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 143028464,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 491,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028464",
    "postTime": "2024-10-17 21:10:07",
    "diggCount": 10,
    "formatTime": "前天 21:10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 143028510,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028510",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 684,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028510",
    "postTime": "2024-10-17 21:10:04",
    "diggCount": 8,
    "formatTime": "前天 21:10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143028537,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028537",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 359,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028537",
    "postTime": "2024-10-17 21:10:01",
    "diggCount": 19,
    "formatTime": "前天 21:10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143028485,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028485",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 491,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028485",
    "postTime": "2024-10-17 21:09:59",
    "diggCount": 21,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 143028359,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028359",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028359",
    "postTime": "2024-10-17 21:09:55",
    "diggCount": 14,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 143028563,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028563",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 376,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028563",
    "postTime": "2024-10-17 21:09:51",
    "diggCount": 8,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 143028445,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028445",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028445",
    "postTime": "2024-10-17 21:09:47",
    "diggCount": 8,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143028376,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028376",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 684,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028376",
    "postTime": "2024-10-17 21:09:45",
    "diggCount": 19,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 143028420,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028420",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 528,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028420",
    "postTime": "2024-10-17 21:09:41",
    "diggCount": 20,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 143028330,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028330",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 413,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028330",
    "postTime": "2024-10-17 21:09:38",
    "diggCount": 14,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 143028304,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028304",
    "postTime": "2024-10-17 21:09:36",
    "diggCount": 22,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 143028280,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028280",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 512,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028280",
    "postTime": "2024-10-17 21:09:33",
    "diggCount": 14,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 143028260,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028260",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 634,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028260",
    "postTime": "2024-10-17 21:09:31",
    "diggCount": 14,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 143028246,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028246",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028246",
    "postTime": "2024-10-17 21:09:28",
    "diggCount": 8,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 143028392,
    "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/LFY5678/article/details/143028392",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 803,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/143028392",
    "postTime": "2024-10-17 21:09:25",
    "diggCount": 9,
    "formatTime": "前天 21:09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142930708,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930708",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930708",
    "postTime": "2024-10-14 22:37:58",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142930730,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930730",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 350,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930730",
    "postTime": "2024-10-14 22:37:54",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142930750,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930750",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 304,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930750",
    "postTime": "2024-10-14 22:37:49",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142930731,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930731",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 224,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930731",
    "postTime": "2024-10-14 22:37:38",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142930751,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930751",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930751",
    "postTime": "2024-10-14 22:37:35",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142930770,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930770",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 222,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930770",
    "postTime": "2024-10-14 22:37:28",
    "diggCount": 3,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142930729,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930729",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930729",
    "postTime": "2024-10-14 22:37:21",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142930786,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930786",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 394,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930786",
    "postTime": "2024-10-14 22:37:16",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142930692,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930692",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930692",
    "postTime": "2024-10-14 22:37:12",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142930693,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930693",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 370,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930693",
    "postTime": "2024-10-14 22:37:08",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142930677,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930677",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930677",
    "postTime": "2024-10-14 22:37:04",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142930676,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930676",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 203,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930676",
    "postTime": "2024-10-14 22:37:00",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142930664,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930664",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 277,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930664",
    "postTime": "2024-10-14 22:34:19",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142930647,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930647",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 290,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930647",
    "postTime": "2024-10-14 22:34:16",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142930625,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142930625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 234,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142930625",
    "postTime": "2024-10-14 22:34:12",
    "diggCount": 3,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142896070,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896070",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 205,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896070",
    "postTime": "2024-10-13 11:49:09",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896141,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896141",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 98,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896141",
    "postTime": "2024-10-13 11:49:06",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896119,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896119",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 132,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896119",
    "postTime": "2024-10-13 11:49:03",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896162,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896162",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 159,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896162",
    "postTime": "2024-10-13 11:48:59",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896147,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896147",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 223,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896147",
    "postTime": "2024-10-13 11:48:56",
    "diggCount": 8,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896171,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896171",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 191,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896171",
    "postTime": "2024-10-13 11:48:53",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896098,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896098",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 152,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896098",
    "postTime": "2024-10-13 11:48:50",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896087,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896087",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 101,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896087",
    "postTime": "2024-10-13 11:48:47",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896128,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896128",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 133,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896128",
    "postTime": "2024-10-13 11:48:44",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896111,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896111",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 202,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896111",
    "postTime": "2024-10-13 11:48:41",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896056,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896056",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 103,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896056",
    "postTime": "2024-10-13 11:48:32",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896040,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896040",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 149,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896040",
    "postTime": "2024-10-13 11:48:29",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896024,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896024",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 93,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896024",
    "postTime": "2024-10-13 11:48:26",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896005,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142896005",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 164,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896005",
    "postTime": "2024-10-13 11:48:23",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142895993,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142895993",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 199,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142895993",
    "postTime": "2024-10-13 11:48:19",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e75dbfc7b3af47749ec5071052a85cf5.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142799857,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799857",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 449,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799857",
    "postTime": "2024-10-10 00:40:03",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142799828,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799828",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 515,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799828",
    "postTime": "2024-10-10 00:36:19",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142799814,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799814",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 862,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799814",
    "postTime": "2024-10-10 00:35:15",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142799818,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799818",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 827,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799818",
    "postTime": "2024-10-10 00:35:04",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142799801,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799801",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 698,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799801",
    "postTime": "2024-10-10 00:34:44",
    "diggCount": 25,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142799794,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799794",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 739,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799794",
    "postTime": "2024-10-10 00:34:41",
    "diggCount": 19,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142799790,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799790",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 642,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799790",
    "postTime": "2024-10-10 00:32:21",
    "diggCount": 16,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142799784,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799784",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 664,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799784",
    "postTime": "2024-10-10 00:31:54",
    "diggCount": 7,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142799767,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799767",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 516,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799767",
    "postTime": "2024-10-10 00:31:47",
    "diggCount": 8,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142799750,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799750",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 674,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799750",
    "postTime": "2024-10-10 00:31:36",
    "diggCount": 22,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142799778,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799778",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 529,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799778",
    "postTime": "2024-10-10 00:30:36",
    "diggCount": 15,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142799774,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799774",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 776,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799774",
    "postTime": "2024-10-10 00:30:32",
    "diggCount": 16,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142799764,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799764",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 532,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799764",
    "postTime": "2024-10-10 00:30:29",
    "diggCount": 13,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142799757,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 545,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799757",
    "postTime": "2024-10-10 00:30:25",
    "diggCount": 18,
    "formatTime": "2024.10.10",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d53006d108044002ac092d675aa0e3ea.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142799762,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142799762",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 719,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142799762",
    "postTime": "2024-10-10 00:30:21",
    "diggCount": 11,
    "formatTime": "2024.10.10",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/4623e588ca14457f867b5aa618627168.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142700105,
    "title": "高频编程考题：二叉树的右视图（中等）",
    "description": "要从二叉树的右侧查看并返回节点值，我们可以使用层序遍历（广度优先遍历）来实现。具体来说，我们需要从右侧依次访问每一层的节点，并从每一层的最右侧节点开始返回结果。，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142700105",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 298,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700105",
    "postTime": "2024-10-04 09:56:42",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b6e4941ea10b490a8db4b67f420a3305.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142700094,
    "title": "高频编程考题：二叉搜索树中第 K 小的元素（中等）",
    "description": "小元素，我们可以利用 BST 的中序遍历特性。中序遍历 BST 会以升序方式访问所有节点，因此第。：中序遍历 BST 的结果是一个升序排列的节点值列表。可以使用递归或迭代的方式进行中序遍历。：在遍历过程中，维护一个计数器来记录已经遍历的节点数量，当计数器等于。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第。要查找二叉搜索树（BST）中的第。小的元素就是中序遍历结果中的第。小的元素（从 1 开始计数）。给定一个二叉搜索树的根节点。小的值，你将如何优化算法？时，返回当前节点的值。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142700094",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 231,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700094",
    "postTime": "2024-10-04 09:55:14",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7be7b92a469348fe9165d76356a1a0fc.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700048,
    "title": "高频编程考题：验证二叉搜索树（中等）",
    "description": "根节点的值是 5 ，但是右子节点的值是 4。，判断其是否是一个有效的二叉搜索树。给你一个二叉树的根节点。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142700048",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 263,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700048",
    "postTime": "2024-10-04 09:53:48",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/33d363efcf4c482ab02d62a67441d97d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700042,
    "title": "高频编程考题：将有序数组转换为二叉搜索树（简单）",
    "description": "要将一个升序排列的整数数组转换为一棵平衡二叉搜索树（BST），我们可以利用递归方法构建树。这是因为一个平衡的BST的中序遍历应该是升序排列的，因此我们可以通过递归的方式选择中间的元素作为根节点，递归构建左右子树，从而保持平衡。：由于数组已经是升序排列的，选择中间元素作为根节点可以保证树的高度平衡。[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。排列，请你将其转换为一棵 平衡 二叉搜索树。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142700042",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 328,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700042",
    "postTime": "2024-10-04 09:51:57",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f674c50e28b4432a9ebe786a773e0764.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142700066,
    "title": "高频编程考题：二叉树的层序遍历（中等）",
    "description": "层序遍历（二叉树的宽度优先遍历）可以使用队列（FIFO）来实现。我们逐层遍历树中的节点，每次处理一层的所有节点，并将它们的子节点加入队列中。（即逐层地，从左到右访问所有节点）。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142700066",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 238,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700066",
    "postTime": "2024-10-04 09:50:49",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a728c2c3636420b9248f8fe0400e427.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142700067,
    "title": "高频编程考题：二叉树的直径（简单）",
    "description": "要找到二叉树的直径，我们需要找到树中任意两个节点之间的最长路径。：直径是树中两个节点之间最长的路径长度。这个路径可能会经过树的根节点，也可能不会。3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。因此，整体的空间复杂度主要由递归栈的深度决定，对于最坏情况下是。：通过递归计算每个节点的左右子树的深度，返回节点的最大深度。这条路径可能经过也可能不经过根节点。是指树中任意两个节点之间最长路径的。给你一棵二叉树的根节点，返回该树的。由它们之间边数表示。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142700067",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 312,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700067",
    "postTime": "2024-10-04 09:49:20",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/82d34823cc444d24b5582f303808b59d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142700077,
    "title": "高频编程考题：对称二叉树（简单）",
    "description": "要检查一个二叉树是否是轴对称的，我们可以使用递归或迭代的方法。这里提供了两种方法的解题思路和复杂度分析。：可以使用队列来模拟递归检查过程，通过层次遍历来比较每层的节点对称性。：我们需要检查左右子树是否对称。你可以运用递归和迭代两种方法解决这个问题吗？给你一个二叉树的根节点。， 检查它是否轴对称。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142700077",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 870,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700077",
    "postTime": "2024-10-04 09:47:27",
    "diggCount": 18,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f1d3ad76cc91463f8ff63d44ab93ecfa.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700019,
    "title": "高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142700019",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 360,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700019",
    "postTime": "2024-10-04 09:44:57",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142700003,
    "title": "高频编程考题：二叉树的最大深度（简单）",
    "description": "是指从根节点到最远叶子节点的最长路径上的节点数。递归方法较为简洁直观。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142700003",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 219,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700003",
    "postTime": "2024-10-04 09:43:49",
    "diggCount": 8,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caef40e28a5e46a09db40b2d1e1b1cab.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142699995,
    "title": "高频编程考题：二叉树的中序遍历（简单）",
    "description": "要实现二叉树的中序遍历，最常见的方式是使用递归。递归算法很简单，你可以通过迭代算法完成吗？迭代方法使用栈来替代递归。给定一个二叉树的根节点。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142699995",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 322,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142699995",
    "postTime": "2024-10-04 09:42:32",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f3ef3b4a0148408e818b215f1792b710.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142699988,
    "title": "高频编程考题：LRU 缓存（中等）",
    "description": "/ 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.put(4, 4);// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}// 缓存是 {1=1, 2=2}要实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，可以使用。// 返回 -1 (未找到)lRUCache.get(1);// 返回 -1 (未找到)lRUCache.put(1, 1);// 缓存是 {1=1}lRUCache.get(1);",
    "url": "https://blog.csdn.net/LFY5678/article/details/142699988",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 658,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142699988",
    "postTime": "2024-10-04 09:40:52",
    "diggCount": 13,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c37c6a5ba9734596a43ad012b2d6b2ef.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142699982,
    "title": "高频编程考题：合并 K 个升序链表 （困难）",
    "description": "对于每个节点的插入和删除操作，优先队列的时间复杂度为 O(log k)，其中 k 是链表的数量。总的时间复杂度为 O(N log k)，其中 N 是所有节点的总数。要将多个有序链表合并成一个有序链表，可以使用优先队列（最小堆）来实现，这样能够有效地将多个链表中的最小节点逐步合并，最终形成一个有序的链表。：空间复杂度主要取决于优先队列的存储空间，最坏情况下为 O(k)。请你将所有链表合并到一个升序链表中，返回合并后的链表。给你一个链表数组，每个链表都已经按升序排列。将它们合并到一个有序链表中得到。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142699982",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142699982",
    "postTime": "2024-10-04 09:39:44",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/751dafd55ff34389bdf5fe2439f17feb.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142699970,
    "title": "高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/LFY5678/article/details/142699970",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 241,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142699970",
    "postTime": "2024-10-04 09:37:14",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142699955,
    "title": "高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142699955",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 678,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142699955",
    "postTime": "2024-10-04 09:35:41",
    "diggCount": 20,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142699925,
    "title": "高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142699925",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 398,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142699925",
    "postTime": "2024-10-04 09:34:09",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142689138,
    "title": "高频编程考题：两两交换链表中的节点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142689138",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 230,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689138",
    "postTime": "2024-10-03 09:38:13",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142689093,
    "title": "高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142689093",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 251,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689093",
    "postTime": "2024-10-03 09:34:50",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142689074,
    "title": "高频编程考题：两数相加（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142689074",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 241,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689074",
    "postTime": "2024-10-03 09:32:53",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142689050,
    "title": "高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142689050",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 285,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689050",
    "postTime": "2024-10-03 09:30:25",
    "diggCount": 9,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142689037,
    "title": "高频编程考题：环形链表 II（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142689037",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 430,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689037",
    "postTime": "2024-10-03 09:29:02",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142689014,
    "title": "高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142689014",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 294,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689014",
    "postTime": "2024-10-03 09:27:45",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142689005,
    "title": "高频编程考题：回文链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142689005",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 168,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142689005",
    "postTime": "2024-10-03 09:26:18",
    "diggCount": 2,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142688995,
    "title": "高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142688995",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 397,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142688995",
    "postTime": "2024-10-03 09:24:49",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142688981,
    "title": "高频编程考题：相交链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142688981",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 603,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142688981",
    "postTime": "2024-10-03 09:23:37",
    "diggCount": 9,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142688954,
    "title": "高频编程考题：搜索二维矩阵 II（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142688954",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 443,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142688954",
    "postTime": "2024-10-03 09:21:12",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142688937,
    "title": "高频编程考题：旋转图像（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142688937",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 595,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142688937",
    "postTime": "2024-10-03 09:19:44",
    "diggCount": 13,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142688926,
    "title": "高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142688926",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 372,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142688926",
    "postTime": "2024-10-03 09:17:53",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142688913,
    "title": "高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142688913",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 420,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142688913",
    "postTime": "2024-10-03 09:16:42",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142688882,
    "title": "高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712",
    "url": "https://blog.csdn.net/LFY5678/article/details/142688882",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 320,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142688882",
    "postTime": "2024-10-03 09:15:07",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142688860,
    "title": "高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142688860",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 406,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142688860",
    "postTime": "2024-10-03 09:11:18",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142680532,
    "title": "高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680532",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 440,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680532",
    "postTime": "2024-10-02 13:19:39",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142680523,
    "title": "高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680523",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 450,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680523",
    "postTime": "2024-10-02 13:18:24",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142680506,
    "title": "高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680506",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 442,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680506",
    "postTime": "2024-10-02 13:17:07",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142680496,
    "title": "高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680496",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 318,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680496",
    "postTime": "2024-10-02 13:14:21",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142680489,
    "title": "高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680489",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 382,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680489",
    "postTime": "2024-10-02 13:13:03",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142680464,
    "title": "高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 318,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680464",
    "postTime": "2024-10-02 13:09:21",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142680454,
    "title": "高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680454",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 446,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680454",
    "postTime": "2024-10-02 13:07:59",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142680445,
    "title": "高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680445",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 367,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680445",
    "postTime": "2024-10-02 13:06:31",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142680431,
    "title": "高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680431",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 442,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680431",
    "postTime": "2024-10-02 13:03:59",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142680415,
    "title": "高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680415",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 243,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680415",
    "postTime": "2024-10-02 13:02:46",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142680403,
    "title": "高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680403",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 414,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680403",
    "postTime": "2024-10-02 13:01:11",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142680392,
    "title": "高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680392",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 308,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680392",
    "postTime": "2024-10-02 12:59:12",
    "diggCount": 1,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142680360,
    "title": "高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680360",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 294,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680360",
    "postTime": "2024-10-02 12:55:32",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142680352,
    "title": "高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680352",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 450,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680352",
    "postTime": "2024-10-02 12:54:36",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142680334,
    "title": "高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/LFY5678/article/details/142680334",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 428,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142680334",
    "postTime": "2024-10-02 12:52:52",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142904218,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904218",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 412,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904218",
    "postTime": "2024-10-13 21:00:53",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142904198,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904198",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 382,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904198",
    "postTime": "2024-10-13 20:59:35",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142904022,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904022",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 482,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904022",
    "postTime": "2024-10-13 20:59:23",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142904096,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904096",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 451,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904096",
    "postTime": "2024-10-13 20:59:20",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142904072,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904072",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 402,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904072",
    "postTime": "2024-10-13 20:59:17",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142904095,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904095",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 395,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904095",
    "postTime": "2024-10-13 20:59:14",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142904073,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904073",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904073",
    "postTime": "2024-10-13 20:59:06",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142904071,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904071",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 427,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904071",
    "postTime": "2024-10-13 20:59:04",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142904185,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904185",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 507,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904185",
    "postTime": "2024-10-13 20:59:00",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142904054,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904054",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 385,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904054",
    "postTime": "2024-10-13 20:51:24",
    "diggCount": 4,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142904003,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142904003",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 430,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142904003",
    "postTime": "2024-10-13 20:51:20",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142903970,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903970",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 363,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903970",
    "postTime": "2024-10-13 20:51:17",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142903989,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "大致来说，zookeeper 的使用场景如下，我就举几个简单的，大家能说几个就好了：分布式协调\t分布式锁\t元数据/配置信息管理\tHA高可用性分布式协调这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？用 zookeeper 就可以实现分布式系统之间的协调工作。A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，一旦 B 系统处理完了就修改 z",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903989",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 475,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903989",
    "postTime": "2024-10-13 20:51:13",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142903954,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903954",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 405,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903954",
    "postTime": "2024-10-13 20:51:10",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142903935,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142903935",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142903935",
    "postTime": "2024-10-13 20:51:07",
    "diggCount": 5,
    "formatTime": "2024.10.13",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142058366,
    "title": "案例分析：并行计算让代码“飞”起来10",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058366",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 810,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058366",
    "postTime": "2024-09-09 14:32:01",
    "diggCount": 19,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142058346,
    "title": "案例分析：并行计算让代码“飞”起来9",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058346",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1309,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058346",
    "postTime": "2024-09-09 14:31:24",
    "diggCount": 30,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142058299,
    "title": "案例分析：并行计算让代码“飞”起来8",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058299",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 852,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058299",
    "postTime": "2024-09-09 14:30:00",
    "diggCount": 21,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142058248,
    "title": "案例分析：并行计算让代码“飞”起来7",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058248",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 926,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058248",
    "postTime": "2024-09-09 14:28:26",
    "diggCount": 7,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142058012,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142058012",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 848,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058012",
    "postTime": "2024-09-09 14:21:34",
    "diggCount": 14,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142057981,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057981",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1194,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057981",
    "postTime": "2024-09-09 14:20:52",
    "diggCount": 30,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142057961,
    "title": "案例分析：并行计算让代码“飞”起来5",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057961",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057961",
    "postTime": "2024-09-09 14:20:21",
    "diggCount": 8,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142057939,
    "title": "案例分析：并行计算让代码“飞”起来4",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057939",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 894,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057939",
    "postTime": "2024-09-09 14:19:45",
    "diggCount": 13,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142057719,
    "title": "案例分析：并行计算让代码“飞”起来3",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057719",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 946,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057719",
    "postTime": "2024-09-09 14:14:07",
    "diggCount": 32,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142057683,
    "title": "案例分析：并行计算让代码“飞”起来2",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057683",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 956,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057683",
    "postTime": "2024-09-09 14:13:34",
    "diggCount": 29,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142057417,
    "title": "案例分析：并行计算让代码“飞”起来1",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142057417",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 796,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142057417",
    "postTime": "2024-09-09 14:06:38",
    "diggCount": 27,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/911f467a7ab14a9d82eb34c769006364.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142025499,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025499",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 915,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025499",
    "postTime": "2024-09-08 13:27:10",
    "diggCount": 13,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142025490,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025490",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 847,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025490",
    "postTime": "2024-09-08 13:26:26",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142025471,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025471",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 904,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025471",
    "postTime": "2024-09-08 13:25:14",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142025214,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025214",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1039,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025214",
    "postTime": "2024-09-08 13:25:05",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142025190,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025190",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 939,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025190",
    "postTime": "2024-09-08 13:25:01",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142025200,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1041,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025200",
    "postTime": "2024-09-08 13:00:54",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142025174,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025174",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 749,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025174",
    "postTime": "2024-09-08 13:00:41",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142025171,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025171",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025171",
    "postTime": "2024-09-08 12:59:48",
    "diggCount": 20,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142025159,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025159",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 663,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025159",
    "postTime": "2024-09-08 12:59:41",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142025135,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025135",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 906,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025135",
    "postTime": "2024-09-08 12:55:38",
    "diggCount": 7,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142025128,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025128",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 955,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025128",
    "postTime": "2024-09-08 12:54:01",
    "diggCount": 9,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142025117,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025117",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 961,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025117",
    "postTime": "2024-09-08 12:52:45",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142025102,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025102",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 763,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025102",
    "postTime": "2024-09-08 12:51:21",
    "diggCount": 11,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142025090,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025090",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 948,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025090",
    "postTime": "2024-09-08 12:50:10",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142025061,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/142025061",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1174,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025061",
    "postTime": "2024-09-08 12:49:41",
    "diggCount": 18,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/dcd04363878a4815b2aeac00734a8d46.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 141956496,
    "title": "超越常规：斐波那契数列的极速计算技术15",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956496",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 505,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956496",
    "postTime": "2024-09-06 12:15:44",
    "diggCount": 6,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141956488,
    "title": "超越常规：斐波那契数列的极速计算技术14",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956488",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 758,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956488",
    "postTime": "2024-09-06 12:15:09",
    "diggCount": 12,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141956479,
    "title": "超越常规：斐波那契数列的极速计算技术13",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956479",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 814,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956479",
    "postTime": "2024-09-06 12:14:37",
    "diggCount": 6,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141956472,
    "title": "超越常规：斐波那契数列的极速计算技术12",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956472",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956472",
    "postTime": "2024-09-06 12:14:06",
    "diggCount": 13,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141956462,
    "title": "超越常规：斐波那契数列的极速计算技术11",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956462",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 848,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956462",
    "postTime": "2024-09-06 12:13:32",
    "diggCount": 12,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141956456,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956456",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 652,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956456",
    "postTime": "2024-09-06 12:13:01",
    "diggCount": 18,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141956449,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 789,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956449",
    "postTime": "2024-09-06 12:12:24",
    "diggCount": 25,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141956441,
    "title": "超越常规：斐波那契数列的极速计算技术8",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956441",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 762,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956441",
    "postTime": "2024-09-06 12:11:52",
    "diggCount": 23,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141956429,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956429",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 521,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956429",
    "postTime": "2024-09-06 12:11:18",
    "diggCount": 18,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141956420,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956420",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 679,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956420",
    "postTime": "2024-09-06 12:10:41",
    "diggCount": 14,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141956385,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956385",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 521,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956385",
    "postTime": "2024-09-06 12:08:32",
    "diggCount": 9,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141956373,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956373",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 769,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956373",
    "postTime": "2024-09-06 12:07:27",
    "diggCount": 21,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141956363,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956363",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 681,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956363",
    "postTime": "2024-09-06 12:06:19",
    "diggCount": 9,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141956356,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956356",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 611,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956356",
    "postTime": "2024-09-06 12:05:46",
    "diggCount": 14,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141956344,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141956344",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 659,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956344",
    "postTime": "2024-09-06 12:04:24",
    "diggCount": 12,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141929082,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory30",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141929082",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 970,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929082",
    "postTime": "2024-09-05 13:52:31",
    "diggCount": 28,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141929069,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory29",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141929069",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 922,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929069",
    "postTime": "2024-09-05 13:52:00",
    "diggCount": 22,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141929049,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory28",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141929049",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 581,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929049",
    "postTime": "2024-09-05 13:51:22",
    "diggCount": 24,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141929029,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory27",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141929029",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 464,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929029",
    "postTime": "2024-09-05 13:50:36",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141929018,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory26",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141929018",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 970,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929018",
    "postTime": "2024-09-05 13:49:57",
    "diggCount": 21,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141929000,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory25",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141929000",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 835,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929000",
    "postTime": "2024-09-05 13:49:14",
    "diggCount": 17,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141928982,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory24",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928982",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 340,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928982",
    "postTime": "2024-09-05 13:48:43",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141928966,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory23",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928966",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 810,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928966",
    "postTime": "2024-09-05 13:48:10",
    "diggCount": 20,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141928944,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory22",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928944",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 791,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928944",
    "postTime": "2024-09-05 13:47:35",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141928929,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory21",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928929",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 562,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928929",
    "postTime": "2024-09-05 13:47:01",
    "diggCount": 12,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141928915,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory20",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928915",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 764,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928915",
    "postTime": "2024-09-05 13:46:24",
    "diggCount": 9,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141928906,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory19",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928906",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 581,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928906",
    "postTime": "2024-09-05 13:45:49",
    "diggCount": 21,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141928892,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory18",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928892",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 371,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928892",
    "postTime": "2024-09-05 13:45:14",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141928875,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory17",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 522,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928875",
    "postTime": "2024-09-05 13:44:38",
    "diggCount": 15,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141928857,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory16",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141928857",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1015,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141928857",
    "postTime": "2024-09-05 13:44:04",
    "diggCount": 18,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141833464,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory15",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 998,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833464",
    "postTime": "2024-09-03 00:26:11",
    "diggCount": 23,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141833463,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory13",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833463",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 567,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833463",
    "postTime": "2024-09-03 00:25:38",
    "diggCount": 21,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141833460,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory14",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833460",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 539,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833460",
    "postTime": "2024-09-03 00:24:47",
    "diggCount": 15,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141833453,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory12",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833453",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1008,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833453",
    "postTime": "2024-09-03 00:24:13",
    "diggCount": 25,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141833449,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory11",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 676,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833449",
    "postTime": "2024-09-03 00:23:39",
    "diggCount": 12,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141833445,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory10",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833445",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 842,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833445",
    "postTime": "2024-09-03 00:23:07",
    "diggCount": 11,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141833437,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory9",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833437",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 965,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833437",
    "postTime": "2024-09-03 00:22:37",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141833434,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory8",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833434",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 575,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833434",
    "postTime": "2024-09-03 00:22:03",
    "diggCount": 16,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141833428,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory7",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833428",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 962,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833428",
    "postTime": "2024-09-03 00:21:32",
    "diggCount": 6,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141833426,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory6",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833426",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833426",
    "postTime": "2024-09-03 00:20:57",
    "diggCount": 19,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141833423,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory5",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833423",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 743,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833423",
    "postTime": "2024-09-03 00:20:27",
    "diggCount": 6,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141833417,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory4",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833417",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 751,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833417",
    "postTime": "2024-09-03 00:19:52",
    "diggCount": 14,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141833413,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory3",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833413",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 581,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833413",
    "postTime": "2024-09-03 00:19:12",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141833408,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory2",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833408",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 606,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833408",
    "postTime": "2024-09-03 00:18:35",
    "diggCount": 25,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141833401,
    "title": "初始化BeanFactory专项：obtainFreshBeanFactory1",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141833401",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 741,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833401",
    "postTime": "2024-09-03 00:17:49",
    "diggCount": 25,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141819461,
    "title": "超越常规：斐波那契数列的极速计算技术12",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141819461",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 720,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819461",
    "postTime": "2024-09-02 14:41:50",
    "diggCount": 9,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141819446,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141819446",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 609,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819446",
    "postTime": "2024-09-02 14:41:19",
    "diggCount": 8,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141819415,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141819415",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 730,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819415",
    "postTime": "2024-09-02 14:40:22",
    "diggCount": 10,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141819385,
    "title": "超越常规：斐波那契数列的极速计算技术14",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141819385",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 850,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819385",
    "postTime": "2024-09-02 14:39:20",
    "diggCount": 22,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141819365,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141819365",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 853,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819365",
    "postTime": "2024-09-02 14:38:47",
    "diggCount": 21,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141819266,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141819266",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 983,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819266",
    "postTime": "2024-09-02 14:35:27",
    "diggCount": 22,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141819231,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141819231",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 617,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819231",
    "postTime": "2024-09-02 14:34:25",
    "diggCount": 19,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141819213,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141819213",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 318,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819213",
    "postTime": "2024-09-02 14:33:52",
    "diggCount": 3,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141819189,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141819189",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 811,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819189",
    "postTime": "2024-09-02 14:33:02",
    "diggCount": 19,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141819176,
    "title": "超越常规：斐波那契数列的极速计算技术11",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141819176",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 659,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819176",
    "postTime": "2024-09-02 14:32:28",
    "diggCount": 13,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141818923,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141818923",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 525,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818923",
    "postTime": "2024-09-02 14:24:47",
    "diggCount": 10,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141818884,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141818884",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1052,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818884",
    "postTime": "2024-09-02 14:23:24",
    "diggCount": 21,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141818826,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141818826",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1257,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818826",
    "postTime": "2024-09-02 14:23:06",
    "diggCount": 33,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141818864,
    "title": "超越常规：斐波那契数列的极速计算技术13",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141818864",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 942,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818864",
    "postTime": "2024-09-02 14:22:52",
    "diggCount": 27,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141818848,
    "title": "超越常规：斐波那契数列的极速计算技术15",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/141818848",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141818848",
    "postTime": "2024-09-02 14:22:43",
    "diggCount": 30,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140906698,
    "title": "瞬间完成：斐波那契数列高效计算背后的科学",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906698",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1042,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906698",
    "postTime": "2024-08-04 15:27:27",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd9b924443e24a799fcea73fa1c0d72f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140906681,
    "title": "超越常规：斐波那契数列的极速计算技术",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906681",
    "postTime": "2024-08-04 15:26:34",
    "diggCount": 23,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140906547,
    "title": "探秘斐波那契数列：如何在0.02毫秒内计算21亿",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906547",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 912,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906547",
    "postTime": "2024-08-04 15:26:08",
    "diggCount": 19,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5cdc602d7d1f4d978df45f6ec95f0d1b.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140906534,
    "title": "秒懂斐波那契：算法优化实现21亿级速度突破",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906534",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 994,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906534",
    "postTime": "2024-08-04 15:25:34",
    "diggCount": 17,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8362df828ff04f0da1ab371fc89315b6.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140906659,
    "title": "斐波那契数列的惊人速度：算法优化实战分享",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906659",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 911,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906659",
    "postTime": "2024-08-04 15:25:07",
    "diggCount": 25,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b78200db214141e495f3ef8e45375a3a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140906517,
    "title": "斐波那契数列的极速计算：背后的算法魔法",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906517",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 677,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906517",
    "postTime": "2024-08-04 15:25:00",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/057f9d4eeef843a69a75c97502efdafc.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140906462,
    "title": "极致优化：斐波那契数列的高效算法揭秘",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906462",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 708,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906462",
    "postTime": "2024-08-04 15:24:34",
    "diggCount": 20,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1c1ac94bba7d4103b96c27d2d07aee11.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140906608,
    "title": "从慢到快：斐波那契数列高效计算的奥秘",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906608",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 747,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906608",
    "postTime": "2024-08-04 15:24:04",
    "diggCount": 16,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/cb559b31c6fc4e52be6f7636b45cef72.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140906630,
    "title": "从基础到高效：斐波那契数列计算的算法之旅",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906630",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 500,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906630",
    "postTime": "2024-08-04 15:23:24",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/df4542ac1df9499fbef6b045d9c29d27.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140906588,
    "title": "算法的魔力：斐波那契数列的极速计算揭秘",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906588",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 924,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906588",
    "postTime": "2024-08-04 15:23:05",
    "diggCount": 15,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c020e6a282c4fe1b75c2675e7231117.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140906599,
    "title": "探究斐波那契：从基础算法到高效实现",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906599",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 519,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906599",
    "postTime": "2024-08-04 15:22:12",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7eaf7ba453a54c74a93ff28ef736fd38.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140906525,
    "title": "斐波那契数列的速度革命：高效算法实现之路",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906525",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 698,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906525",
    "postTime": "2024-08-04 15:21:45",
    "diggCount": 9,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ff5943e5562f4da8b83570e866b6e04e.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 140906593,
    "title": "极限性能：21亿斐波那契数列在0.02毫秒内计算完成",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906593",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 696,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906593",
    "postTime": "2024-08-04 15:21:13",
    "diggCount": 21,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b78200db214141e495f3ef8e45375a3a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140906580,
    "title": "斐波那契数列的算法优化：实现超高速计算",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140906580",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 564,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906580",
    "postTime": "2024-08-04 15:20:05",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/28057dbe2cd14de7800a18f236bd608a.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140887854,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "一、IOC容器的刷新环节快速回顾public abstract class AbstractApplicationContext implements ApplicationContext {     @Override    public void refresh() throws BeansException, IllegalStateException {        synchronized (this.startupShutdownMonitor) {            ",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887854",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 934,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887854",
    "postTime": "2024-08-03 11:34:51",
    "diggCount": 23,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140887837,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887837",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 921,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887837",
    "postTime": "2024-08-03 11:33:57",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140887813,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887813",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 885,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887813",
    "postTime": "2024-08-03 11:33:40",
    "diggCount": 6,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140887832,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887832",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 710,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887832",
    "postTime": "2024-08-03 11:33:24",
    "diggCount": 18,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140887799,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887799",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 720,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887799",
    "postTime": "2024-08-03 11:31:22",
    "diggCount": 22,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140887790,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887790",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 610,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887790",
    "postTime": "2024-08-03 11:30:49",
    "diggCount": 8,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140887778,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887778",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1003,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887778",
    "postTime": "2024-08-03 11:30:15",
    "diggCount": 14,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140887762,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887762",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 911,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887762",
    "postTime": "2024-08-03 11:29:22",
    "diggCount": 20,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140887745,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887745",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 580,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887745",
    "postTime": "2024-08-03 11:29:11",
    "diggCount": 22,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140887625,
    "title": "聚焦IOC容器刷新环节obtainFreshBeanFactory初始化BeanFactory专项",
    "description": "在这个过程中，旧的 BeanFactory 实例将被销毁，新的 BeanFactory 实例将被创建和初始化，确保了每次获取 BeanFactory 时都可以获取到最新的实例，从而保持应用程序的状态和配置的一致性。返回 BeanFactory：最后，方法将获取到的 BeanFactory 实例返回给调用者，以便它可以在应用程序中使用，BeanFactory 是整个 Spring 应用程序的核心，它负责管理应用程序中的所有 Bean 实例。@Bean:声明一个Bean，由Spring容器管。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140887625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1065,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887625",
    "postTime": "2024-08-03 11:28:04",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9248808db8554f74965fec4cf9b870a6.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140742475,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742475",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 351,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742475",
    "postTime": "2024-07-27 22:36:46",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742484,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742484",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 380,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742484",
    "postTime": "2024-07-27 22:36:33",
    "diggCount": 7,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742523,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742523",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 279,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742523",
    "postTime": "2024-07-27 22:36:18",
    "diggCount": 1,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742536,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742536",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742536",
    "postTime": "2024-07-27 22:35:59",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742612,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742612",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 479,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742612",
    "postTime": "2024-07-27 22:35:36",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742559,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742559",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 453,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742559",
    "postTime": "2024-07-27 22:31:29",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742545,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742545",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 409,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742545",
    "postTime": "2024-07-27 22:30:44",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140742509,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 498,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742509",
    "postTime": "2024-07-27 22:27:48",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140742503,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742503",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742503",
    "postTime": "2024-07-27 22:27:13",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742493,
    "title": "对锁的优化手段和技术原理的解析",
    "description": "的性能分析与优化之路，从使用同步锁和不使用同步锁的性能对比入手，逐步展开对锁的优化手段和技术原理的解析，帮助读者更好地理解和应用Java中的锁机制。在多线程编程中，锁是保证线程安全的重要手段之一，但如何选择合适的锁并进行优化，一直是我们面临的挑战。本博客探讨Java中。",
    "url": "https://blog.csdn.net/m0_74022416/article/details/140742493",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742493",
    "postTime": "2024-07-27 22:26:38",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142059079,
    "title": "案例分析：并行计算让代码“飞”起来15",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142059079",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 944,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142059079",
    "postTime": "2024-09-09 14:54:11",
    "diggCount": 28,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142059019,
    "title": "案例分析：并行计算让代码“飞”起来14",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142059019",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 781,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142059019",
    "postTime": "2024-09-09 14:52:41",
    "diggCount": 23,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142058979,
    "title": "案例分析：并行计算让代码“飞”起来13",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058979",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 601,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058979",
    "postTime": "2024-09-09 14:51:23",
    "diggCount": 15,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142058906,
    "title": "案例分析：并行计算让代码“飞”起来12",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058906",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1093,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058906",
    "postTime": "2024-09-09 14:49:06",
    "diggCount": 24,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142058860,
    "title": "案例分析：并行计算让代码“飞”起来11",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058860",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1082,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058860",
    "postTime": "2024-09-09 14:47:36",
    "diggCount": 30,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142058842,
    "title": "案例分析：并行计算让代码“飞”起来10",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058842",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 802,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058842",
    "postTime": "2024-09-09 14:47:07",
    "diggCount": 26,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142058758,
    "title": "案例分析：并行计算让代码“飞”起来9",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058758",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 877,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058758",
    "postTime": "2024-09-09 14:44:12",
    "diggCount": 7,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142058727,
    "title": "案例分析：并行计算让代码“飞”起来8",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058727",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 685,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058727",
    "postTime": "2024-09-09 14:43:34",
    "diggCount": 19,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142058708,
    "title": "案例分析：并行计算让代码“飞”起来7",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058708",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 790,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058708",
    "postTime": "2024-09-09 14:42:59",
    "diggCount": 12,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142058681,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 721,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058681",
    "postTime": "2024-09-09 14:41:46",
    "diggCount": 8,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142058668,
    "title": "案例分析：并行计算让代码“飞”起来5",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058668",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 878,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058668",
    "postTime": "2024-09-09 14:41:13",
    "diggCount": 23,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142058652,
    "title": "案例分析：并行计算让代码“飞”起来4",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058652",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 825,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058652",
    "postTime": "2024-09-09 14:40:41",
    "diggCount": 14,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142058596,
    "title": "案例分析：并行计算让代码“飞”起来3",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058596",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 780,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058596",
    "postTime": "2024-09-09 14:39:13",
    "diggCount": 24,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142058519,
    "title": "案例分析：并行计算让代码“飞”起来2",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058519",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 826,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058519",
    "postTime": "2024-09-09 14:36:52",
    "diggCount": 19,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142058479,
    "title": "案例分析：并行计算让代码“飞”起来1",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142058479",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 782,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142058479",
    "postTime": "2024-09-09 14:35:40",
    "diggCount": 8,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142025529,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025529",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 769,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025529",
    "postTime": "2024-09-08 14:04:55",
    "diggCount": 34,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142025547,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025547",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 644,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025547",
    "postTime": "2024-09-08 14:04:51",
    "diggCount": 27,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142025564,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025564",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 776,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025564",
    "postTime": "2024-09-08 14:04:47",
    "diggCount": 21,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142025618,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025618",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 851,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025618",
    "postTime": "2024-09-08 14:04:43",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142025665,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025665",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 840,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025665",
    "postTime": "2024-09-08 14:04:39",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142025635,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025635",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1016,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025635",
    "postTime": "2024-09-08 14:04:35",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142025650,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025650",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 861,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025650",
    "postTime": "2024-09-08 14:04:30",
    "diggCount": 13,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142025581,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025581",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 775,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025581",
    "postTime": "2024-09-08 14:04:26",
    "diggCount": 18,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142026097,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142026097",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 984,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026097",
    "postTime": "2024-09-08 14:04:22",
    "diggCount": 26,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142025625,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 701,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025625",
    "postTime": "2024-09-08 13:36:35",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142025613,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025613",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 640,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025613",
    "postTime": "2024-09-08 13:35:25",
    "diggCount": 11,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142025602,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025602",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 817,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025602",
    "postTime": "2024-09-08 13:34:48",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142025599,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025599",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 752,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025599",
    "postTime": "2024-09-08 13:34:33",
    "diggCount": 23,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142025591,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025591",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 541,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025591",
    "postTime": "2024-09-08 13:33:46",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142025573,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/142025573",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 535,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142025573",
    "postTime": "2024-09-08 13:32:39",
    "diggCount": 7,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141956720,
    "title": "超越常规：斐波那契数列的极速计算技术15",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956720",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 915,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956720",
    "postTime": "2024-09-06 12:33:48",
    "diggCount": 6,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141956712,
    "title": "超越常规：斐波那契数列的极速计算技术14",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956712",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 537,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956712",
    "postTime": "2024-09-06 12:33:15",
    "diggCount": 20,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141956706,
    "title": "超越常规：斐波那契数列的极速计算技术13",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956706",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 509,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956706",
    "postTime": "2024-09-06 12:32:44",
    "diggCount": 7,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141956695,
    "title": "超越常规：斐波那契数列的极速计算技术12",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956695",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 676,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956695",
    "postTime": "2024-09-06 12:31:47",
    "diggCount": 13,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141956661,
    "title": "超越常规：斐波那契数列的极速计算技术11",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956661",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 746,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956661",
    "postTime": "2024-09-06 12:29:21",
    "diggCount": 13,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141956646,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956646",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 673,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956646",
    "postTime": "2024-09-06 12:28:20",
    "diggCount": 22,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141956639,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956639",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 842,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956639",
    "postTime": "2024-09-06 12:27:45",
    "diggCount": 10,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141956621,
    "title": "超越常规：斐波那契数列的极速计算技术8",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956621",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 619,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956621",
    "postTime": "2024-09-06 12:26:13",
    "diggCount": 6,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141956612,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956612",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 613,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956612",
    "postTime": "2024-09-06 12:25:29",
    "diggCount": 10,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141956593,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956593",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 786,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956593",
    "postTime": "2024-09-06 12:24:09",
    "diggCount": 20,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141956568,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956568",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 453,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956568",
    "postTime": "2024-09-06 12:22:11",
    "diggCount": 11,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141956557,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956557",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 695,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956557",
    "postTime": "2024-09-06 12:21:36",
    "diggCount": 12,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141956547,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956547",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 442,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956547",
    "postTime": "2024-09-06 12:21:06",
    "diggCount": 14,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141956532,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956532",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 635,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956532",
    "postTime": "2024-09-06 12:19:48",
    "diggCount": 24,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141956519,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141956519",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 426,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956519",
    "postTime": "2024-09-06 12:18:22",
    "diggCount": 17,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141929853,
    "title": "案例分析：Redis 如何助力秒杀业务12",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929853",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 782,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929853",
    "postTime": "2024-09-05 14:19:12",
    "diggCount": 11,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8beb0d8b7805408b9b8b7502c4acf0ca.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141929835,
    "title": "案例分析：Redis 如何助力秒杀业务11",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929835",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1067,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929835",
    "postTime": "2024-09-05 14:18:41",
    "diggCount": 16,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8beb0d8b7805408b9b8b7502c4acf0ca.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141929515,
    "title": "案例分析：Redis 如何助力秒杀业务10",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929515",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 751,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929515",
    "postTime": "2024-09-05 14:07:50",
    "diggCount": 29,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8beb0d8b7805408b9b8b7502c4acf0ca.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141929479,
    "title": "案例分析：Redis 如何助力秒杀业务9",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929479",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 843,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929479",
    "postTime": "2024-09-05 14:06:31",
    "diggCount": 12,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/eb24b6b7428c45398af76d83a9edc3c1.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141929464,
    "title": "案例分析：Redis 如何助力秒杀业务8",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929464",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 366,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929464",
    "postTime": "2024-09-05 14:05:56",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac016538c49548989f77d883a8cf601f.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141929410,
    "title": "案例分析：Redis 如何助力秒杀业务7",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929410",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 332,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929410",
    "postTime": "2024-09-05 14:04:01",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/dcece649e06f43ffa67cf72142b261f3.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141929388,
    "title": "案例分析：Redis 如何助力秒杀业务6",
    "description": "那什么叫分布式缓存呢？它其实是一种集中管理的思想。如果我们的服务有多个节点，堆内缓存在每个节点上都会有一份；而分布式缓存，所有的节点，共用一份缓存，既节约了空间，又减少了管理成本。在分布式缓存领域，使用最多的就是 Redis。Redis支持非常丰富的数据类型，包括字符串（string）、列表（list）、集合（set）、有序集合（zset）、哈希表（hash）等常用的数据结构。当然，它也支持一些其他的比如位图（bitmap）一类的数据结构。说到 Redis，就不得不提一下另外一个分布式缓存Mem",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929388",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 732,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929388",
    "postTime": "2024-09-05 14:03:23",
    "diggCount": 15,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6081c1132e8445f4a768bb630047ec06.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141929369,
    "title": "案例分析：Redis 如何助力秒杀业务5",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929369",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 2059,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929369",
    "postTime": "2024-09-05 14:02:48",
    "diggCount": 39,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2a0efeddd52d4fa993069498695ad92a.png"
    ],
    "collectCount": 34
  },
  {
    "articleId": 141929352,
    "title": "案例分析：Redis 如何助力秒杀业务4",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929352",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 719,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929352",
    "postTime": "2024-09-05 14:02:17",
    "diggCount": 21,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/eb24b6b7428c45398af76d83a9edc3c1.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141929332,
    "title": "案例分析：Redis 如何助力秒杀业务3",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929332",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1827,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929332",
    "postTime": "2024-09-05 14:01:42",
    "diggCount": 61,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac016538c49548989f77d883a8cf601f.png"
    ],
    "collectCount": 35
  },
  {
    "articleId": 141929297,
    "title": "案例分析：Redis 如何助力秒杀业务3",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929297",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 843,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929297",
    "postTime": "2024-09-05 14:00:00",
    "diggCount": 23,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8beb0d8b7805408b9b8b7502c4acf0ca.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141929284,
    "title": "案例分析：Redis 如何助力秒杀业务2",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929284",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 821,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929284",
    "postTime": "2024-09-05 13:59:24",
    "diggCount": 9,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8beb0d8b7805408b9b8b7502c4acf0ca.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141929254,
    "title": "案例分析：Redis 如何助力秒杀业务1",
    "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929254",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1071,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929254",
    "postTime": "2024-09-05 13:58:54",
    "diggCount": 27,
    "formatTime": "2024.09.05",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/4dc3fec7c71e43aab0ee1ad5ae54cd80.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141929207,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件12",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929207",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 216,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929207",
    "postTime": "2024-09-05 13:56:32",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141929190,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件11",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141929190",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 181,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141929190",
    "postTime": "2024-09-05 13:55:57",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141833529,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件10",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141833529",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 110,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833529",
    "postTime": "2024-09-03 00:36:57",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141833528,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件9",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141833528",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 293,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833528",
    "postTime": "2024-09-03 00:36:27",
    "diggCount": 7,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141833525,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件8",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141833525",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 322,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833525",
    "postTime": "2024-09-03 00:35:54",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141833523,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件7",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141833523",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 187,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833523",
    "postTime": "2024-09-03 00:35:17",
    "diggCount": 1,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141833514,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件6",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。实现一个高效的上下文管理组件。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141833514",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 167,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833514",
    "postTime": "2024-09-03 00:33:47",
    "diggCount": 2,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141833506,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件5",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141833506",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 121,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833506",
    "postTime": "2024-09-03 00:33:15",
    "diggCount": 2,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141833500,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件4",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141833500",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 163,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833500",
    "postTime": "2024-09-03 00:31:49",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141833499,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件3",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141833499",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 137,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833499",
    "postTime": "2024-09-03 00:31:19",
    "diggCount": 1,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141833488,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件2",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141833488",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 356,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833488",
    "postTime": "2024-09-03 00:30:04",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141833485,
    "title": "基于 ThreadLocal 实现一个高效的上下文管理组件1",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141833485",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 194,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833485",
    "postTime": "2024-09-03 00:29:34",
    "diggCount": 2,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141820018,
    "title": "用 Feign 优化微服务：Spring Cloud 的高效通信实战",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141820018",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 830,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820018",
    "postTime": "2024-09-02 14:56:43",
    "diggCount": 8,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141819957,
    "title": "精通 Spring Cloud Feign：从理论到实战的通信优化之路",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819957",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1828,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819957",
    "postTime": "2024-09-02 14:55:11",
    "diggCount": 46,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 32
  },
  {
    "articleId": 141819937,
    "title": "用 Feign 打造高效微服务通信的最佳实践",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819937",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 837,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819937",
    "postTime": "2024-09-02 14:54:39",
    "diggCount": 5,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141819870,
    "title": "全面掌握 Spring Cloud Feign：微服务通信效率的终极指南",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819870",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1121,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819870",
    "postTime": "2024-09-02 14:52:48",
    "diggCount": 9,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141819848,
    "title": "优化微服务架构：Spring Cloud Feign 的高效通信策略",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819848",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1019,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819848",
    "postTime": "2024-09-02 14:52:17",
    "diggCount": 10,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 141819832,
    "title": "Spring Cloud Feign 完全指南：让微服务通信效率翻倍",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819832",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 708,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819832",
    "postTime": "2024-09-02 14:51:45",
    "diggCount": 14,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141819812,
    "title": "提升微服务通信性能：Spring Cloud Feign 的实战秘笈",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819812",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 931,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819812",
    "postTime": "2024-09-02 14:51:06",
    "diggCount": 23,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141819794,
    "title": "Spring Cloud Feign 实践：让微服务通信快人一步",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819794",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 686,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819794",
    "postTime": "2024-09-02 14:50:35",
    "diggCount": 19,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141819757,
    "title": "Spring Cloud Feign 应用指南：微服务通信效率的全新高度",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1129,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819757",
    "postTime": "2024-09-02 14:49:45",
    "diggCount": 27,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 141819744,
    "title": "Spring Cloud Feign 实战技巧：高效微服务通信的必修课",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819744",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 941,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819744",
    "postTime": "2024-09-02 14:48:57",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141819715,
    "title": "Spring Cloud Feign 深度解析：提升微服务通信效率的关键",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819715",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 873,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819715",
    "postTime": "2024-09-02 14:48:40",
    "diggCount": 35,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141819697,
    "title": "微服务通信提速：Spring Cloud Feign 的实战技巧",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819697",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1073,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819697",
    "postTime": "2024-09-02 14:47:53",
    "diggCount": 12,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141819681,
    "title": "Spring Cloud Feign 实战攻略：让微服务通信更高效",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 981,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819681",
    "postTime": "2024-09-02 14:47:35",
    "diggCount": 36,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 141819592,
    "title": "Spring Cloud Feign 入门到精通：微服务通信效率提升指南",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/141819592",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 948,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141819592",
    "postTime": "2024-09-02 14:47:03",
    "diggCount": 34,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140906325,
    "title": "Spring Cloud Feign揭秘：高效、简洁的微服务通信方式",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906325",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 748,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906325",
    "postTime": "2024-08-04 15:01:56",
    "diggCount": 20,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a03429dd7f7140e9be711b656550babf.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 140906317,
    "title": "Spring Cloud Feign实战指南：提升微服务通信效率的秘籍",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906317",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1014,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906317",
    "postTime": "2024-08-04 15:01:13",
    "diggCount": 16,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/755bf4ccf79049fe9617a729d27d306a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140906290,
    "title": "Spring Cloud Feign核心解析：声明式HTTP客户端的力量",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906290",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 847,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906290",
    "postTime": "2024-08-04 15:00:52",
    "diggCount": 29,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/676fe15910c74b4a8790dd4d7cdcca5d.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 140906178,
    "title": "深入探索Spring Cloud Feign：微服务通信的利器",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906178",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1044,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906178",
    "postTime": "2024-08-04 15:00:32",
    "diggCount": 28,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bfd77446817343f8a600119818f77ace.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 140906304,
    "title": "Spring Cloud Feign详解：优化你的微服务调用",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 652,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906304",
    "postTime": "2024-08-04 15:00:13",
    "diggCount": 26,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140906295,
    "title": "Spring Cloud Feign实战：简化微服务之间的通信",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906295",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 680,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906295",
    "postTime": "2024-08-04 14:59:36",
    "diggCount": 17,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e8d38f4b7c72469b98c65ebe699ac184.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140906217,
    "title": "理解Spring Cloud Feign：构建高效微服务架构的核心组件",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906217",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1057,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906217",
    "postTime": "2024-08-04 14:59:31",
    "diggCount": 17,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8f02e313332b44bbae1f7122a7986e69.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140906267,
    "title": "从基础到高级：Spring Cloud Feign的全面指南",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906267",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 467,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906267",
    "postTime": "2024-08-04 14:59:14",
    "diggCount": 6,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5bffec57e6b542c1bc2d12d6c501f37b.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140906284,
    "title": "构建可靠的微服务：Spring Cloud Feign的使用与优化",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906284",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 608,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906284",
    "postTime": "2024-08-04 14:58:33",
    "diggCount": 28,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8dab2bd99a36465ba6e0e9476db9e0cf.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140906231,
    "title": "Spring Cloud Feign详解：实现高效、可扩展的微服务通信",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906231",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1024,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906231",
    "postTime": "2024-08-04 14:57:10",
    "diggCount": 17,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e6ad0cd444654ce490ce53aa1ac1de40.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 140906249,
    "title": "Spring Cloud Feign深入剖析：声明式HTTP客户端的内部工作原理",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906249",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 782,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906249",
    "postTime": "2024-08-04 14:56:52",
    "diggCount": 29,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e966035d58234f2f80f8faeb69f7eccc.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140906206,
    "title": "从零开始掌握Spring Cloud Feign：概念、原理与实战",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906206",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 926,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906206",
    "postTime": "2024-08-04 14:56:32",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/463b377913b14099a9717d1cdf7a10f3.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 140906191,
    "title": "Spring Cloud Feign全解析：简化微服务调用的最佳实践",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906191",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 859,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906191",
    "postTime": "2024-08-04 14:56:15",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ed6665d629e44063967b28972fc218db.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140906169,
    "title": "Spring Cloud Feign揭秘：高效的声明式HTTP客户端",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906169",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 884,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906169",
    "postTime": "2024-08-04 14:55:44",
    "diggCount": 17,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1e500cf402c44cfb670d1735bf587a2.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 140906141,
    "title": "揭秘Spring Cloud Feign：高效微服务架构的构建利器",
    "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140906141",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 771,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906141",
    "postTime": "2024-08-04 14:55:15",
    "diggCount": 36,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5011f5cf2d9649edb348dc2ec689f6a0.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140888899,
    "title": "Spring AOP理解与研发使用：mock赋能干预举例",
    "description": "参考进行学习总结。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140888899",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 289,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888899",
    "postTime": "2024-08-03 12:51:54",
    "diggCount": 4,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0ee2d4931c3744c98c935a75451c5331.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140888887,
    "title": "Spring AOP理解与研发使用：mock赋能干预举例",
    "description": "参考进行学习总结。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140888887",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 702,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888887",
    "postTime": "2024-08-03 12:50:48",
    "diggCount": 14,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/acf807cd05104593a24ff2fcdf1ca23a.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 140888860,
    "title": "Spring AOP理解与研发使用：mock赋能干预举例",
    "description": "参考进行学习总结。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140888860",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 385,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888860",
    "postTime": "2024-08-03 12:49:50",
    "diggCount": 5,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/712a957fa4954907b473c23884317055.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140888851,
    "title": "Spring AOP理解与研发使用：mock赋能干预举例",
    "description": "参考进行学习总结。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140888851",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 959,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888851",
    "postTime": "2024-08-03 12:49:04",
    "diggCount": 12,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1ea411ef4d604251a0601aa26b407b51.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140888838,
    "title": "Spring AOP理解与研发使用：mock赋能干预举例",
    "description": "参考进行学习总结。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140888838",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 717,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888838",
    "postTime": "2024-08-03 12:48:20",
    "diggCount": 22,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0c481b5063d84e209e3ec87c678286c7.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 140888812,
    "title": "Spring AOP理解与研发使用：mock赋能干预举例",
    "description": "参考进行学习总结。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140888812",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 805,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888812",
    "postTime": "2024-08-03 12:47:27",
    "diggCount": 20,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9ed90ff512f44cb2a397e3c5cad23522.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 140888806,
    "title": "Spring AOP理解与研发使用：mock赋能干预举例",
    "description": "参考进行学习总结。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140888806",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 748,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888806",
    "postTime": "2024-08-03 12:46:42",
    "diggCount": 26,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1d56382868147d8b90eec723c46d381.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 140888798,
    "title": "Spring AOP理解与研发使用：mock赋能干预举例",
    "description": "参考进行学习总结。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140888798",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 921,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888798",
    "postTime": "2024-08-03 12:46:23",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/26bc7703b07742d58123a44f8de0c882.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 140888768,
    "title": "Spring AOP理解与研发使用：mock赋能干预举例",
    "description": "参考进行学习总结。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140888768",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 673,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888768",
    "postTime": "2024-08-03 12:45:50",
    "diggCount": 16,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/428b20b6cadd4a4092cb81d964968f47.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 140888746,
    "title": "Spring AOP理解与研发使用：mock赋能干预举例",
    "description": "参考进行学习总结。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140888746",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1082,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888746",
    "postTime": "2024-08-03 12:44:30",
    "diggCount": 17,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/db14eb99712c4e36980024890bd8d283.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140809926,
    "title": "快速掌握CompletableFuture回调机制的设计与实现",
    "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140809926",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 415,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809926",
    "postTime": "2024-07-31 00:01:35",
    "diggCount": 4,
    "formatTime": "2024.07.31",
    "picList": [],
    "collectCount": 5
  },
  {
    "articleId": 140809912,
    "title": "快速掌握CompletableFuture回调机制的设计与实现",
    "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140809912",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 820,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809912",
    "postTime": "2024-07-31 00:00:48",
    "diggCount": 18,
    "formatTime": "2024.07.31",
    "picList": [],
    "collectCount": 18
  },
  {
    "articleId": 140809919,
    "title": "快速掌握CompletableFuture回调机制的设计与实现",
    "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140809919",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 391,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809919",
    "postTime": "2024-07-31 00:00:37",
    "diggCount": 5,
    "formatTime": "2024.07.31",
    "picList": [],
    "collectCount": 9
  },
  {
    "articleId": 140809905,
    "title": "快速掌握CompletableFuture回调机制的设计与实现",
    "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140809905",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 414,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809905",
    "postTime": "2024-07-30 23:59:29",
    "diggCount": 5,
    "formatTime": "2024.07.30",
    "picList": [],
    "collectCount": 9
  },
  {
    "articleId": 140809902,
    "title": "快速掌握CompletableFuture回调机制的设计与实现",
    "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140809902",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 378,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809902",
    "postTime": "2024-07-30 23:58:55",
    "diggCount": 5,
    "formatTime": "2024.07.30",
    "picList": [],
    "collectCount": 7
  },
  {
    "articleId": 140809888,
    "title": "快速掌握CompletableFuture回调机制的设计与实现",
    "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140809888",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 827,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809888",
    "postTime": "2024-07-30 23:58:05",
    "diggCount": 22,
    "formatTime": "2024.07.30",
    "picList": [],
    "collectCount": 14
  },
  {
    "articleId": 140809881,
    "title": "快速掌握CompletableFuture回调机制的设计与实现",
    "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140809881",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 460,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809881",
    "postTime": "2024-07-30 23:57:49",
    "diggCount": 23,
    "formatTime": "2024.07.30",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/fad536e972e14ce4b37803185dc3b00c.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140742351,
    "title": "ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742351",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 355,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742351",
    "postTime": "2024-07-27 22:17:20",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/cd452feabfc24798a097d23de2e39f44.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140742330,
    "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742330",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 327,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742330",
    "postTime": "2024-07-27 22:15:42",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0e4f980a082446a49c4e885cc2de7bd6.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140742318,
    "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742318",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 244,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742318",
    "postTime": "2024-07-27 22:15:03",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/856be2df0e7f4ff1a02b045ff9353b63.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140742306,
    "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742306",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 282,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742306",
    "postTime": "2024-07-27 22:14:00",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e9ad99a1dc7141c5bbd40240e408d744.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140742298,
    "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742298",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742298",
    "postTime": "2024-07-27 22:13:16",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0735bfd7d1eb42d1ab87c6545d250575.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140742287,
    "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742287",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 346,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742287",
    "postTime": "2024-07-27 22:12:22",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/834d6bcbd99449528b8235b1cfdf0c2e.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140742281,
    "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742281",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742281",
    "postTime": "2024-07-27 22:11:36",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7febe00a05714deab71d5f07f8e5878a.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140742269,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742269",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 320,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742269",
    "postTime": "2024-07-27 22:10:52",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9bd81c19a6e14e58865ea6c53191fdae.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140742246,
    "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742246",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 402,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742246",
    "postTime": "2024-07-27 22:10:05",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1e43dd475a6e431bad459dbf347ef42f.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140742222,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742222",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 427,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742222",
    "postTime": "2024-07-27 22:09:19",
    "diggCount": 8,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742204,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742204",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 197,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742204",
    "postTime": "2024-07-27 22:08:47",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [],
    "collectCount": 0
  },
  {
    "articleId": 140742175,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742175",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 257,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742175",
    "postTime": "2024-07-27 22:07:52",
    "diggCount": 9,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/15a709ec2fbb4eaba548c7aea316d9f1.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742197,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742197",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 300,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742197",
    "postTime": "2024-07-27 22:07:09",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/45fbbe7fbd4948718d6bfa659e1d11d9.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742189,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742189",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 425,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742189",
    "postTime": "2024-07-27 22:06:35",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f8d0f44302e44ade9e339e87b06d5e72.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140742167,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/m0_74022498/article/details/140742167",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 521,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742167",
    "postTime": "2024-07-27 22:05:11",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/81ca6051d8f64ce7b6b6916fa7ac05a5.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142070064,
    "title": "案例分析：并行计算让代码“飞”起来12",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142070064",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 570,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070064",
    "postTime": "2024-09-09 21:41:07",
    "diggCount": 24,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142070036,
    "title": "案例分析：并行计算让代码“飞”起来11",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142070036",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 557,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070036",
    "postTime": "2024-09-09 21:40:18",
    "diggCount": 8,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142070008,
    "title": "案例分析：并行计算让代码“飞”起来10",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142070008",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 931,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070008",
    "postTime": "2024-09-09 21:38:52",
    "diggCount": 23,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142069977,
    "title": "案例分析：并行计算让代码“飞”起来9",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069977",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 953,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142069977",
    "postTime": "2024-09-09 21:37:21",
    "diggCount": 29,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142069962,
    "title": "案例分析：并行计算让代码“飞”起来8",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069962",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 718,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142069962",
    "postTime": "2024-09-09 21:36:41",
    "diggCount": 13,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142069939,
    "title": "案例分析：并行计算让代码“飞”起来7",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069939",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1017,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142069939",
    "postTime": "2024-09-09 21:35:29",
    "diggCount": 26,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142069917,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069917",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 811,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142069917",
    "postTime": "2024-09-09 21:34:15",
    "diggCount": 9,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142069882,
    "title": "案例分析：并行计算让代码“飞”起来5",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069882",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 679,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142069882",
    "postTime": "2024-09-09 21:32:57",
    "diggCount": 25,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142069856,
    "title": "案例分析：并行计算让代码“飞”起来4",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069856",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 580,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142069856",
    "postTime": "2024-09-09 21:31:46",
    "diggCount": 13,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142069825,
    "title": "案例分析：并行计算让代码“飞”起来3",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069825",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 831,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142069825",
    "postTime": "2024-09-09 21:30:20",
    "diggCount": 15,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142069789,
    "title": "案例分析：并行计算让代码“飞”起来2",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069789",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 826,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142069789",
    "postTime": "2024-09-09 21:28:49",
    "diggCount": 25,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142069751,
    "title": "案例分析：并行计算让代码“飞”起来1",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069751",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 867,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142069751",
    "postTime": "2024-09-09 21:27:21",
    "diggCount": 18,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142026511,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026511",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1013,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026511",
    "postTime": "2024-09-08 14:27:40",
    "diggCount": 21,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142026489,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026489",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 679,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026489",
    "postTime": "2024-09-08 14:26:26",
    "diggCount": 26,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142026471,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026471",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 815,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026471",
    "postTime": "2024-09-08 14:26:21",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142026393,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026393",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 570,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026393",
    "postTime": "2024-09-08 14:26:16",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142026470,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026470",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 764,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026470",
    "postTime": "2024-09-08 14:26:11",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142026446,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026446",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 914,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026446",
    "postTime": "2024-09-08 14:24:47",
    "diggCount": 18,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142026456,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026456",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 540,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026456",
    "postTime": "2024-09-08 14:24:40",
    "diggCount": 27,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142026428,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026428",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 866,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026428",
    "postTime": "2024-09-08 14:23:34",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142026379,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026379",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 790,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026379",
    "postTime": "2024-09-08 14:23:29",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142026360,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026360",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 817,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026360",
    "postTime": "2024-09-08 14:23:24",
    "diggCount": 24,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142026342,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026342",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1937,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026342",
    "postTime": "2024-09-08 14:23:20",
    "diggCount": 43,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 31
  },
  {
    "articleId": 142026321,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026321",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 732,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026321",
    "postTime": "2024-09-08 14:23:16",
    "diggCount": 7,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142026417,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026417",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 855,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026417",
    "postTime": "2024-09-08 14:22:47",
    "diggCount": 19,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142026402,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026402",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 909,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026402",
    "postTime": "2024-09-08 14:21:52",
    "diggCount": 7,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142026385,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142026385",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1945,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026385",
    "postTime": "2024-09-08 14:20:32",
    "diggCount": 45,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 59
  },
  {
    "articleId": 141957191,
    "title": "超越常规：斐波那契数列的极速计算技术15",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141957191",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 850,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957191",
    "postTime": "2024-09-06 13:14:23",
    "diggCount": 22,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141957180,
    "title": "超越常规：斐波那契数列的极速计算技术14",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141957180",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957180",
    "postTime": "2024-09-06 13:13:52",
    "diggCount": 19,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141957172,
    "title": "超越常规：斐波那契数列的极速计算技术13",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141957172",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 651,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957172",
    "postTime": "2024-09-06 13:13:20",
    "diggCount": 10,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141957161,
    "title": "超越常规：斐波那契数列的极速计算技术12",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141957161",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 856,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957161",
    "postTime": "2024-09-06 13:12:40",
    "diggCount": 24,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141957148,
    "title": "超越常规：斐波那契数列的极速计算技术11",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141957148",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 662,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957148",
    "postTime": "2024-09-06 13:11:51",
    "diggCount": 7,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141957126,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141957126",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 549,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957126",
    "postTime": "2024-09-06 13:10:43",
    "diggCount": 5,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141957115,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141957115",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 614,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957115",
    "postTime": "2024-09-06 13:09:55",
    "diggCount": 11,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141957097,
    "title": "超越常规：斐波那契数列的极速计算技术8",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141957097",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 675,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957097",
    "postTime": "2024-09-06 13:08:10",
    "diggCount": 10,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141957070,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141957070",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 894,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957070",
    "postTime": "2024-09-06 13:05:20",
    "diggCount": 6,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141957056,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141957056",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 452,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957056",
    "postTime": "2024-09-06 13:04:11",
    "diggCount": 21,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141956904,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141956904",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 607,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956904",
    "postTime": "2024-09-06 12:48:56",
    "diggCount": 15,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141956887,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141956887",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 762,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956887",
    "postTime": "2024-09-06 12:46:52",
    "diggCount": 16,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141956866,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141956866",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 495,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956866",
    "postTime": "2024-09-06 12:44:49",
    "diggCount": 11,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141956766,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141956766",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 504,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956766",
    "postTime": "2024-09-06 12:37:39",
    "diggCount": 14,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141956750,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141956750",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 573,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141956750",
    "postTime": "2024-09-06 12:36:20",
    "diggCount": 21,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141930529,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图15",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930529",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 603,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930529",
    "postTime": "2024-09-05 14:38:05",
    "diggCount": 29,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 141930504,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图14",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930504",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 629,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930504",
    "postTime": "2024-09-05 14:37:28",
    "diggCount": 7,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 141930475,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图13",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930475",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1061,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930475",
    "postTime": "2024-09-05 14:36:42",
    "diggCount": 27,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141930456,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图12",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930456",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 939,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930456",
    "postTime": "2024-09-05 14:36:08",
    "diggCount": 21,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 141930420,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图11",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930420",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 978,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930420",
    "postTime": "2024-09-05 14:34:57",
    "diggCount": 23,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141930406,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图10",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930406",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 985,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930406",
    "postTime": "2024-09-05 14:34:21",
    "diggCount": 20,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141930363,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图9",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930363",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 729,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930363",
    "postTime": "2024-09-05 14:33:05",
    "diggCount": 19,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141930319,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图8",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930319",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 565,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930319",
    "postTime": "2024-09-05 14:31:54",
    "diggCount": 8,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141930280,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图7",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930280",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 608,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930280",
    "postTime": "2024-09-05 14:30:40",
    "diggCount": 10,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141930228,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图6",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930228",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 923,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930228",
    "postTime": "2024-09-05 14:29:32",
    "diggCount": 20,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141930170,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图5",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930170",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 319,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930170",
    "postTime": "2024-09-05 14:28:01",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141930137,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图4",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930137",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 632,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930137",
    "postTime": "2024-09-05 14:26:57",
    "diggCount": 29,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141930086,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图3",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930086",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1028,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930086",
    "postTime": "2024-09-05 14:25:31",
    "diggCount": 9,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141930028,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图2",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930028",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1925,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930028",
    "postTime": "2024-09-05 14:24:22",
    "diggCount": 38,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 47
  },
  {
    "articleId": 141930014,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图1",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930014",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 962,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930014",
    "postTime": "2024-09-05 14:23:52",
    "diggCount": 24,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141833637,
    "title": "K 个一组翻转链表12",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833637",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 498,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833637",
    "postTime": "2024-09-03 00:57:06",
    "diggCount": 24,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141833629,
    "title": "K 个一组翻转链表11",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833629",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 765,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833629",
    "postTime": "2024-09-03 00:55:47",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141833621,
    "title": "K 个一组翻转链表10",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833621",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 781,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833621",
    "postTime": "2024-09-03 00:54:02",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141833619,
    "title": "K 个一组翻转链表9",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833619",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 875,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833619",
    "postTime": "2024-09-03 00:53:28",
    "diggCount": 6,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141833604,
    "title": "K 个一组翻转链表8",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833604",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 609,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833604",
    "postTime": "2024-09-03 00:49:53",
    "diggCount": 28,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141833600,
    "title": "K 个一组翻转链表7",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833600",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 728,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833600",
    "postTime": "2024-09-03 00:49:19",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141833591,
    "title": "K 个一组翻转链表6",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833591",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 783,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833591",
    "postTime": "2024-09-03 00:47:53",
    "diggCount": 13,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141833586,
    "title": "K 个一组翻转链表5",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833586",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 521,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833586",
    "postTime": "2024-09-03 00:47:19",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141833571,
    "title": "K 个一组翻转链表4",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833571",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 522,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833571",
    "postTime": "2024-09-03 00:44:37",
    "diggCount": 15,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141833568,
    "title": "K 个一组翻转链表3",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833568",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 978,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833568",
    "postTime": "2024-09-03 00:44:00",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141833562,
    "title": "K 个一组翻转链表2",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833562",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 740,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833562",
    "postTime": "2024-09-03 00:42:47",
    "diggCount": 11,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141833549,
    "title": "K 个一组翻转链表1",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833549",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 898,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141833549",
    "postTime": "2024-09-03 00:41:22",
    "diggCount": 16,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e069c759fa10413ba69d48ab70dc549b.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141820561,
    "title": "探索 Spring BeanFactory 的高级配置与扩展：从入门到精通",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820561",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 900,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820561",
    "postTime": "2024-09-02 15:11:57",
    "diggCount": 23,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141820537,
    "title": "揭示 Spring BeanFactory 的高级配置技巧与扩展能力",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820537",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 612,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820537",
    "postTime": "2024-09-02 15:11:17",
    "diggCount": 24,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141820507,
    "title": "Spring BeanFactory 高级特性：配置与扩展能力的深度探索",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820507",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 652,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820507",
    "postTime": "2024-09-02 15:10:29",
    "diggCount": 10,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141820489,
    "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820489",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 732,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820489",
    "postTime": "2024-09-02 15:09:52",
    "diggCount": 26,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 141820471,
    "title": "提升 Spring 组件管理能力：BeanFactory 高级配置与扩展技巧",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820471",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 713,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820471",
    "postTime": "2024-09-02 15:09:10",
    "diggCount": 16,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141820454,
    "title": "ConfigurableBeanFactory（可配置的 Bean 工厂）",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820454",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 864,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820454",
    "postTime": "2024-09-02 15:08:38",
    "diggCount": 19,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141820424,
    "title": "Spring BeanFactory 高级配置与扩展的最佳实践与技巧",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820424",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 500,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820424",
    "postTime": "2024-09-02 15:07:57",
    "diggCount": 11,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141820356,
    "title": "深度剖析 Spring BeanFactory：高级配置与扩展的全面指南",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820356",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 989,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820356",
    "postTime": "2024-09-02 15:06:13",
    "diggCount": 24,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 141820327,
    "title": "Spring BeanFactory 进阶指南：高级配置与扩展能力的完美实现",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820327",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 765,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820327",
    "postTime": "2024-09-02 15:05:10",
    "diggCount": 12,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141820307,
    "title": "如何使用 Spring BeanFactory 进行高级配置与扩展：专家视角",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820307",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 653,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820307",
    "postTime": "2024-09-02 15:04:39",
    "diggCount": 23,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141820288,
    "title": "Spring BeanFactory 完全指南：高级配置与扩展的实战方法",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820288",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 772,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820288",
    "postTime": "2024-09-02 15:04:05",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141820260,
    "title": "优化 Spring 应用：BeanFactory 的高级配置与扩展能力解析",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820260",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1055,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820260",
    "postTime": "2024-09-02 15:03:27",
    "diggCount": 14,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141820241,
    "title": "从基础到进阶：探索 Spring BeanFactory 的高级配置与扩展",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820241",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 540,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820241",
    "postTime": "2024-09-02 15:02:52",
    "diggCount": 10,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141820172,
    "title": "掌握 Spring BeanFactory：高级配置技巧与扩展能力探索",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820172",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 734,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820172",
    "postTime": "2024-09-02 15:02:41",
    "diggCount": 8,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 141820200,
    "title": "Spring BeanFactory 实战：如何进行高级配置和扩展",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820200",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 747,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820200",
    "postTime": "2024-09-02 15:02:34",
    "diggCount": 24,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 141789948,
    "title": "合并k个排序链表",
    "description": "具体来说，我们可以将所有链表的头节点放入一个优先队列中，每次取出队列中值最小的节点，并将它的下一个节点插入队列中。具体来说，我们可以将所有链表两两合并，直到所有链表都被合并为止。如果有奇数个链表，我们可以将最后一个链表和前面合并后得到的链表再次合并。空间复杂度：每次合并产生一个新链表，所以需要O(k)的额外空间。时间复杂度：假设所有链表的平均长度是n，那么分治的层数是O(logk)，每层合并的时间复杂度是O(n)，所以总时间复杂度是O(nlogk)。合并k个排序链表，返回合并后的排序链表。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789948",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 356,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789948",
    "postTime": "2024-09-01 21:14:17",
    "diggCount": 1,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141789928,
    "title": "奇偶链表奇偶链表奇偶链表",
    "description": "具体而言，可以维护两个指针odd和even，分别指向奇数节点和偶数节点链表的末尾。遍历原始链表，对于每个节点，如果其为奇数节点，则将其插入到odd链表的末尾；最后，将odd链表的末尾指向even链表的开头即可。输入: 2->1->3->5->6->4->7->NULL       输出: 2->3->6->7->1->5->4->NULL。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。最优解法是创建两个链表，分别存储原始链表的奇数节点和偶数节点，然后将这两个链表连接起来。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789928",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 533,
    "commentCount": 2,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789928",
    "postTime": "2024-09-01 21:13:33",
    "diggCount": 15,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141790050,
    "title": "分隔链表分隔链表分隔链表",
    "description": "遍历原始链表，对于每个节点，如果节点的值小于x，则将其插入到smaller链表的末尾；最后，将smaller链表的末尾指向larger链表的开头即可。示例：输入：head = 1->4->3->2->5->2, x = 3.         输出：1->2->2->4->3->5。给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。具体而言，可以维护两个指针smaller和larger，它们分别指向分隔后链表中值小于x和不小于x的节点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141790050",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141790050",
    "postTime": "2024-09-01 21:12:37",
    "diggCount": 4,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141789912,
    "title": "旋转链表旋转链表",
    "description": "首先，需要找到倒数第k个节点，然后将其作为新的头结点。因为k有可能大于链表长度，所以需要先统计链表长度，并对k做一些处理。示例 1：输入：head = [1,2,3,4,5], k = 2      输出：[4,5,1,2,3]示例 2：输入：head = [0,1,2], k = 4            输出：[2,0,1]给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。旋转链表的最优解法的时间复杂度是O(n)，其中n是链表的长度。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789912",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 579,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789912",
    "postTime": "2024-09-01 21:11:48",
    "diggCount": 16,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141789887,
    "title": "K 个一组翻转链表",
    "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789887",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 775,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789887",
    "postTime": "2024-09-01 21:11:06",
    "diggCount": 23,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141790021,
    "title": "删除链表中的重复元素II",
    "description": "示例 3:输入:1->2 ->2 ->2 ->5 ->2 ->3 ->3 ->9,输出1 ->5 ->2 ->9。给定一个排序链表（默认正整数），删除所有含有重复数字的节点，只保留原始链表中没有重复出现的数字。一个指针用于表示当前已处理的部分，另一个指针用于遍历链表。最优解法是使用迭代的方法，在一次遍历中删除连续重复的元素，同时保持空间复杂度为 O(1)。示例 2:输入: 1->1->2->3->3.          输出:  2。示例 1:输入:1->1->2->2->3->4->4 输出：3。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141790021",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 415,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141790021",
    "postTime": "2024-09-01 21:10:16",
    "diggCount": 4,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141790001,
    "title": "排序链表排序链表",
    "description": "最优解法是使用归并排序（Merge Sort），将链表分成两个子链表进行排序，然后合并两个已排序的子链表。示例 2：输入：head = [-1,5,3,4,0].     输出：[-1,0,3,4,5]示例 1：输入：head = [4,2,1,3].         输出：[1,2,3,4]示例 3：输入：head = [].                    输出：[]进阶：你可以在 O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141790001",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 481,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141790001",
    "postTime": "2024-09-01 21:10:12",
    "diggCount": 13,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141789984,
    "title": "删除链表中的重复元素I",
    "description": "需要注意的是，因为头节点可能会被删除，因此可以添加一个哨兵节点作为头节点，这样就不用单独考虑头节点的情况。示例 2:输入: 1->1->2->3->3.          输出: 1->2->3。最优的解法是使用双指针，遍历整个链表，如果发现有相邻节点的值相同，就将其中一个节点删除。示例 1:输入: 1->1->2.       输出: 1->2。给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。时间复杂度为O(n)，空间复杂度为O(1)。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789984",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 275,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789984",
    "postTime": "2024-09-01 21:08:33",
    "diggCount": 10,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141789970,
    "title": "两个链表的第一个公共节点",
    "description": "给定两个单链表，判断两个链表是否相交。若相交，返回相交的起始节点。若不相交，返回 null。可以假定整个链表结构中没有循环。时间复杂度为 O(m+n)，其中m和n分别为两个链表的长度。注意，函数返回结果后，链表必须保持其原始结构。from：两个链表的第一个公共节点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789970",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 299,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789970",
    "postTime": "2024-09-01 21:07:52",
    "diggCount": 1,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141789957,
    "title": "合并两个有序链表",
    "description": "首先，我们定义一个新的链表作为合并后的链表，然后设置两个指针分别指向两个原始链表的头节点。我们每次比较两个指针指向节点的值，将较小的节点加入新的链表中，并将指针后移一位。重复这个过程，直到某一个指针为空，此时我们将另一个链表剩下的部分全部加入新链表中即可。示例:输入：1->2->4, 1->3->4.      输出：1->1->2->3->4->4。合并两个有序链表，返回一个新的链表，新链表是这两个链表中的所有节点按照从小到大的顺序排列而成。from：合并两个有序链表。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789957",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 582,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789957",
    "postTime": "2024-09-01 21:07:46",
    "diggCount": 19,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141789937,
    "title": "链表的中间节点",
    "description": "使用两个指针，一个快指针和一个慢指针，快指针每次移动两个节点，慢指针每次移动一个节点，当快指针到达链表末尾时，慢指针就指向链表的中间节点。这个算法的时间复杂度为O(n)，其中n为链表的长度，空间复杂度为O(1)，只需要两个指针的空间。的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。提示：给定链表的结点数介于。最优的解法是快慢指针法。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789937",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 337,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789937",
    "postTime": "2024-09-01 21:06:54",
    "diggCount": 7,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141789921,
    "title": "删除链表中倒数第K个节点",
    "description": "最优的解法是使用快慢指针，快指针先走n步，然后快慢指针一起走，当快指针到达链表末尾时，慢指针就是要删除的节点的前一个节点。接着，通过改变指针的指向，将慢指针指向的节点删除即可。示例：输入：head = [1,2,3,4,5], n = 2.       输出：[1,2,3,5]你一个链表，删除链表中倒数第 n 个节点，并且返回链表的头结点。需要注意的是，如果要删除的是头节点，需要特殊处理。时间复杂度为O(n)，空间复杂度为O(1)。from：删除链表中倒数第K个节点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789921",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789921",
    "postTime": "2024-09-01 21:05:21",
    "diggCount": 4,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141789896,
    "title": "链表中环的入口点",
    "description": "当快指针第一次到达相遇点时，快指针走过的距离为 a + nb + x，慢指针走过的距离为 a + x，由于快指针走过的距离是慢指针的两倍，因此有2(a+x)=a+nb+x，化简得到 a=(n-1)b+c。当快指针回到链表头部时，慢指针距离环的入口节点的距离为a，因此快慢指针分别从链表头部和相遇点开始移动，相遇的节点即为环的入口节点。链表中环的入口节点是指一个有环链表中，环的入口节点。例如，在如下图所示的链表中，环的入口节点是3（注意，这里环的入口节点不是算链表的第3个节点）。from：链表中环的入口点。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789896",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 522,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789896",
    "postTime": "2024-09-01 21:04:29",
    "diggCount": 8,
    "formatTime": "2024.09.01",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/7c53ce0617ebad3a0ea4ab62dfbc4027.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141789875,
    "title": "链表中环的检测",
    "description": "在这个算法中，时间复杂度是 O(n)，空间复杂度是 O(1)，因为只使用了两个指针来遍历链表，没有使用额外的数据结构来存储中间结果。判断链表中是否有环的高效最优解法是使用快慢指针，也称为龟兔赛跑算法。进阶：你能否不使用额外空间解决此题？给定一个链表，判断链表中是否有环。from：链表中环的检测。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789875",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 343,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789875",
    "postTime": "2024-09-01 21:03:25",
    "diggCount": 15,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141789840,
    "title": "反转链表（Reverse Linked List）",
    "description": "该算法的时间复杂度为 O(n)，其中 n 是链表的长度，空间复杂度为 O(1)。输出: 5->4->3->2->1->NULL。对于反转链表这道题目，其高效最优解法是使用迭代实现。进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？示例：输入: 1->2->3->4->5->NULL。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789840",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 303,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141789840",
    "postTime": "2024-09-01 21:01:24",
    "diggCount": 3,
    "formatTime": "2024.09.01",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5d4f40ce94c04342aca5d3efcf2e67f4.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140906011,
    "title": "深入Spring BeanFactory：构建健壮的Spring应用架构",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140906011",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 3,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906011",
    "postTime": "2024-08-04 14:40:25",
    "diggCount": 14,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 140906002,
    "title": "探索Spring BeanFactory：高级配置与扩展能力",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140906002",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 710,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906002",
    "postTime": "2024-08-04 14:39:44",
    "diggCount": 22,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/979e46784dd84273b26add8cb0d8ee4d.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140905994,
    "title": "理解Spring BeanFactory：从实例创建到依赖注入",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905994",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 755,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905994",
    "postTime": "2024-08-04 14:38:57",
    "diggCount": 23,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e0d59f35ca2242eeb3ed71ef4a4e9fac.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140905837,
    "title": "深入解析Spring BeanFactory：核心概念与最佳实践",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905837",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 571,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905837",
    "postTime": "2024-08-04 14:37:48",
    "diggCount": 16,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e414f443afb747049bb95942b76ecc54.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140905983,
    "title": "Spring BeanFactory内幕：深入探讨其架构与设计模式",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905983",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 659,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905983",
    "postTime": "2024-08-04 14:37:35",
    "diggCount": 22,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/dbf7817060a8450eaeb8699803b79e03.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140905881,
    "title": "掌握Spring BeanFactory：从基础到高级应用",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905881",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 730,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905881",
    "postTime": "2024-08-04 14:37:20",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d23006cc55b248778e02da546bbf34d2.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140905889,
    "title": "揭秘Spring BeanFactory：理解其工作原理与使用技巧",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905889",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 621,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905889",
    "postTime": "2024-08-04 14:36:54",
    "diggCount": 30,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8efdb489d8ca47cd85e49ab62b2f5835.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 140905901,
    "title": "Spring框架核心：BeanFactory的深度剖析与实战指南",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905901",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 843,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905901",
    "postTime": "2024-08-04 14:36:29",
    "diggCount": 14,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8751d6f3d47143ef83f2605ffe0764c4.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 140905965,
    "title": "Spring BeanFactory全解析：如何优化你的Spring应用",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905965",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 797,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905965",
    "postTime": "2024-08-04 14:36:00",
    "diggCount": 28,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b4327c5a6b574f4488696ea1feeb03e4.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 140905958,
    "title": "从零开始学Spring BeanFactory：快速上手与高效应用",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905958",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 745,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905958",
    "postTime": "2024-08-04 14:35:07",
    "diggCount": 28,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a7b0051914ca46f8a136769ccfd90799.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 140905943,
    "title": "揭秘Spring BeanFactory：深入理解依赖注入与生命周期管理",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905943",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 533,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905943",
    "postTime": "2024-08-04 14:34:22",
    "diggCount": 26,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b6a0842b8b0c4e0784530ffa40b0679f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 140905923,
    "title": "Spring BeanFactory详解：实现高效的Spring容器管理",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905923",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 962,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905923",
    "postTime": "2024-08-04 14:34:04",
    "diggCount": 29,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7303ebfd0b744c7e9b3ef036506e0cb5.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 140905932,
    "title": "Spring BeanFactory完全指南：性能优化与调试技巧",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905932",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1012,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905932",
    "postTime": "2024-08-04 14:33:24",
    "diggCount": 23,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16fa08a6ce7242388dca7b0a88fb647e.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140905912,
    "title": "Spring BeanFactory的实战应用：最佳实践与常见问题解决",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905912",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 587,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905912",
    "postTime": "2024-08-04 14:32:10",
    "diggCount": 15,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7502473c74044dd7a92a8db55017c266.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140905883,
    "title": "理解Spring BeanFactory：如何高效管理Bean的生命周期",
    "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905883",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 714,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905883",
    "postTime": "2024-08-04 14:31:43",
    "diggCount": 15,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8864b338aad74146882ea7de91876652.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 140888422,
    "title": "AOP开发应用与分析：方法自动打印出入参举例",
    "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/*** 方法以 @PrintLogInfo 注解作为切面入口*//*** 方法入参前打印对应的入参信息内容。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888422",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1039,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888422",
    "postTime": "2024-08-03 12:11:48",
    "diggCount": 15,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 140888409,
    "title": "AOP开发应用与分析：方法自动打印出入参举例",
    "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/*** 方法以 @PrintLogInfo 注解作为切面入口*//*** 方法入参前打印对应的入参信息内容。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888409",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 865,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888409",
    "postTime": "2024-08-03 12:10:43",
    "diggCount": 17,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140888395,
    "title": "AOP开发应用与分析：方法自动打印出入参举例",
    "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/*** 方法以 @PrintLogInfo 注解作为切面入口*//*** 方法入参前打印对应的入参信息内容。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888395",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 689,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888395",
    "postTime": "2024-08-03 12:10:37",
    "diggCount": 13,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140888388,
    "title": "AOP开发应用与分析：方法自动打印出入参举例",
    "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/*** 方法以 @PrintLogInfo 注解作为切面入口*//*** 方法入参前打印对应的入参信息内容。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888388",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1044,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888388",
    "postTime": "2024-08-03 12:09:05",
    "diggCount": 28,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 140888381,
    "title": "AOP开发应用与分析：方法自动打印出入参举例",
    "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/*** 方法以 @PrintLogInfo 注解作为切面入口*//*** 方法入参前打印对应的入参信息内容。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888381",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 768,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888381",
    "postTime": "2024-08-03 12:08:27",
    "diggCount": 21,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140888363,
    "title": "AOP开发应用与分析：方法自动打印出入参举例",
    "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/*** 方法以 @PrintLogInfo 注解作为切面入口*//*** 方法入参前打印对应的入参信息内容。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888363",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 840,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888363",
    "postTime": "2024-08-03 12:08:15",
    "diggCount": 13,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 140888347,
    "title": "AOP开发应用与分析：方法自动打印出入参举例",
    "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/*** 方法以 @PrintLogInfo 注解作为切面入口*//*** 方法入参前打印对应的入参信息内容。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888347",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 836,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888347",
    "postTime": "2024-08-03 12:08:04",
    "diggCount": 11,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 140888331,
    "title": "AOP开发应用与分析：方法自动打印出入参举例",
    "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/*** 方法以 @PrintLogInfo 注解作为切面入口*//*** 方法入参前打印对应的入参信息内容。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888331",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 699,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888331",
    "postTime": "2024-08-03 12:07:52",
    "diggCount": 28,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140888316,
    "title": "AOP开发应用与分析：方法自动打印出入参举例",
    "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/*** 方法以 @PrintLogInfo 注解作为切面入口*//*** 方法入参前打印对应的入参信息内容。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888316",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 770,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888316",
    "postTime": "2024-08-03 12:06:58",
    "diggCount": 23,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 140888264,
    "title": "AOP开发应用与分析：方法自动打印出入参举例",
    "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/*** 方法以 @PrintLogInfo 注解作为切面入口*//*** 方法入参前打印对应的入参信息内容。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888264",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 776,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140888264",
    "postTime": "2024-08-03 12:06:46",
    "diggCount": 33,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140862403,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862403",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 14,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862403",
    "postTime": "2024-08-02 08:18:14",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862493,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862493",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 14,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862493",
    "postTime": "2024-08-02 08:18:06",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862470,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862470",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 12,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862470",
    "postTime": "2024-08-02 08:17:58",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862484,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862484",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 10,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862484",
    "postTime": "2024-08-02 08:17:50",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862460,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862460",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 13,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862460",
    "postTime": "2024-08-02 08:17:17",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862456,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862456",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 12,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862456",
    "postTime": "2024-08-02 08:17:08",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862451,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862451",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 11,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862451",
    "postTime": "2024-08-02 08:17:01",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862447,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862447",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 10,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862447",
    "postTime": "2024-08-02 08:16:53",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862438,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862438",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 14,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862438",
    "postTime": "2024-08-02 08:16:46",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862429,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862429",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 15,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862429",
    "postTime": "2024-08-02 08:16:38",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862422,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862422",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 10,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862422",
    "postTime": "2024-08-02 08:16:30",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862400,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862400",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 14,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862400",
    "postTime": "2024-08-02 08:16:12",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862475,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862475",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 16,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862475",
    "postTime": "2024-08-02 08:15:58",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862393,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862393",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 14,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862393",
    "postTime": "2024-08-02 08:11:11",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862389,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862389",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 13,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862389",
    "postTime": "2024-08-02 08:11:04",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140859861,
    "title": "“八股文”在实际工作中是助力、阻力还是空谈？",
    "description": "提示：可以探讨在团队协作环境中，“八股文”知识如何帮助成员之间进行有效沟提示：可以探讨在团队协作环境中，“八股文”知识如何帮助成员之间进行有效沟通提示：可以探讨在团队协作环境中，“八股文”知识如何帮助成员之间进行有效提示：可以探讨在团队协作环境中，“八股文”知识如何帮助成员之间进行有效沟通，尤其是在解释复杂概念时的作用。提示：可以探讨在团队协作环境中，“八股文”知识如何帮助成员之间进行有效沟通，尤其是在解释复杂概念时的作用。提示：讨论如何将“八股文”学习与实际代码能力的锻炼相结合，以培养更全面的技术人才。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140859861",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 278,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140859861",
    "postTime": "2024-08-01 23:35:44",
    "diggCount": 3,
    "formatTime": "2024.08.01",
    "picList": [],
    "collectCount": 6
  },
  {
    "articleId": 140812634,
    "title": "深入互联网配置中心核心原理本质",
    "description": "Spring Cloud Config是Spring Cloud微服务体系中的配置中心，是一个集中化外部配置的分布式系统，由服务端和客户端组成，其不依赖于注册中心，是一个独立的配置中心，支持多种存储配置信息形式，目前主要有jdbc、value、native、svn、git，其中默认是git。重点讨论功能有如下两个方面：将程序中配置的各种功能开关、参数配置、服务器地址------>修改后实时生效灰度发布、分环境、分集群管理配置--------->全面集中化管理。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140812634",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 25,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140812634",
    "postTime": "2024-07-31 08:27:34",
    "diggCount": 0,
    "formatTime": "2024.07.31",
    "picList": [],
    "collectCount": 0
  },
  {
    "articleId": 140809493,
    "title": "学以致用Mybatis-TypeHandler",
    "description": "现在，当使用 MyBatis 进行数据库查询时，会自动将数据库中的列值转换为对应的 List<String> 对象，使我们能够方便地在 Java 代码中使用 List<String> 类型。总的来说，MyBatis 的核心原理是基于配置文件和接口定义的，通过解析配置文件、创建工厂、会话管理和数据库操作等步骤来实现与数据库的交互。TypeHandler 的作用是在 MyBatis 执行 SQL 查询或更新操作时，将数据库中的列值转换为 Java 对象，并在将 Java 对象写入数据库时执行相反的转换。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140809493",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 536,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809493",
    "postTime": "2024-07-30 23:34:59",
    "diggCount": 19,
    "formatTime": "2024.07.30",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56e7e776a0344508b5a5b43fd3ba4196.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 140809514,
    "title": "学以致用Mybatis-TypeHandler",
    "description": "现在，当使用 MyBatis 进行数据库查询时，会自动将数据库中的列值转换为对应的 List<String> 对象，使我们能够方便地在 Java 代码中使用 List<String> 类型。总的来说，MyBatis 的核心原理是基于配置文件和接口定义的，通过解析配置文件、创建工厂、会话管理和数据库操作等步骤来实现与数据库的交互。TypeHandler 的作用是在 MyBatis 执行 SQL 查询或更新操作时，将数据库中的列值转换为 Java 对象，并在将 Java 对象写入数据库时执行相反的转换。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140809514",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 336,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809514",
    "postTime": "2024-07-30 23:34:33",
    "diggCount": 4,
    "formatTime": "2024.07.30",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56e7e776a0344508b5a5b43fd3ba4196.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140809482,
    "title": "学以致用Mybatis-TypeHandler",
    "description": "现在，当使用 MyBatis 进行数据库查询时，会自动将数据库中的列值转换为对应的 List<String> 对象，使我们能够方便地在 Java 代码中使用 List<String> 类型。总的来说，MyBatis 的核心原理是基于配置文件和接口定义的，通过解析配置文件、创建工厂、会话管理和数据库操作等步骤来实现与数据库的交互。TypeHandler 的作用是在 MyBatis 执行 SQL 查询或更新操作时，将数据库中的列值转换为 Java 对象，并在将 Java 对象写入数据库时执行相反的转换。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140809482",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 223,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809482",
    "postTime": "2024-07-30 23:33:23",
    "diggCount": 3,
    "formatTime": "2024.07.30",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56e7e776a0344508b5a5b43fd3ba4196.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140809477,
    "title": "学以致用Mybatis-TypeHandler",
    "description": "现在，当使用 MyBatis 进行数据库查询时，会自动将数据库中的列值转换为对应的 List<String> 对象，使我们能够方便地在 Java 代码中使用 List<String> 类型。总的来说，MyBatis 的核心原理是基于配置文件和接口定义的，通过解析配置文件、创建工厂、会话管理和数据库操作等步骤来实现与数据库的交互。TypeHandler 的作用是在 MyBatis 执行 SQL 查询或更新操作时，将数据库中的列值转换为 Java 对象，并在将 Java 对象写入数据库时执行相反的转换。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140809477",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 775,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809477",
    "postTime": "2024-07-30 23:33:14",
    "diggCount": 26,
    "formatTime": "2024.07.30",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56e7e776a0344508b5a5b43fd3ba4196.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140809474,
    "title": "学以致用Mybatis-TypeHandler",
    "description": "现在，当使用 MyBatis 进行数据库查询时，会自动将数据库中的列值转换为对应的 List<String> 对象，使我们能够方便地在 Java 代码中使用 List<String> 类型。总的来说，MyBatis 的核心原理是基于配置文件和接口定义的，通过解析配置文件、创建工厂、会话管理和数据库操作等步骤来实现与数据库的交互。TypeHandler 的作用是在 MyBatis 执行 SQL 查询或更新操作时，将数据库中的列值转换为 Java 对象，并在将 Java 对象写入数据库时执行相反的转换。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140809474",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 973,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809474",
    "postTime": "2024-07-30 23:33:00",
    "diggCount": 34,
    "formatTime": "2024.07.30",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/56e7e776a0344508b5a5b43fd3ba4196.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140742765,
    "title": "深入理解分析多线程概念、同步与无锁机制",
    "description": "线程是计算机程序执行的最小单位，它是进程内的一个独立执行序列。在多线程编程中，程序可以同时执行多个线程，这些线程可以独立运行，执行不同的任务，或者协同工作以完成一个复杂的任务。每个线程都有自己的执行上下文，包括程序计数器、寄存器、栈等，以便它们能够独立执行，并且可以共享进程的资源，例如全局变量、堆内存等。线程和进程的主要区别在于，进程是独立的执行环境，拥有自己的内存空间，而线程共享同一进程的内存空间。总之，线程是程序执行的基本单位，多线程编程已经成为编程领域的标准，有助于提高程序的性能、并发性和响应能力。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140742765",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742765",
    "postTime": "2024-07-27 22:47:32",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/dc9b052f77e84c87969698a44c70ba1f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140742751,
    "title": "深入理解分析多线程概念、同步与无锁机制",
    "description": "线程是计算机程序执行的最小单位，它是进程内的一个独立执行序列。在多线程编程中，程序可以同时执行多个线程，这些线程可以独立运行，执行不同的任务，或者协同工作以完成一个复杂的任务。每个线程都有自己的执行上下文，包括程序计数器、寄存器、栈等，以便它们能够独立执行，并且可以共享进程的资源，例如全局变量、堆内存等。线程和进程的主要区别在于，进程是独立的执行环境，拥有自己的内存空间，而线程共享同一进程的内存空间。总之，线程是程序执行的基本单位，多线程编程已经成为编程领域的标准，有助于提高程序的性能、并发性和响应能力。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140742751",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 232,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742751",
    "postTime": "2024-07-27 22:46:32",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140742743,
    "title": "深入理解分析多线程概念、同步与无锁机制",
    "description": "线程是计算机程序执行的最小单位，它是进程内的一个独立执行序列。在多线程编程中，程序可以同时执行多个线程，这些线程可以独立运行，执行不同的任务，或者协同工作以完成一个复杂的任务。每个线程都有自己的执行上下文，包括程序计数器、寄存器、栈等，以便它们能够独立执行，并且可以共享进程的资源，例如全局变量、堆内存等。线程和进程的主要区别在于，进程是独立的执行环境，拥有自己的内存空间，而线程共享同一进程的内存空间。总之，线程是程序执行的基本单位，多线程编程已经成为编程领域的标准，有助于提高程序的性能、并发性和响应能力。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140742743",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 413,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742743",
    "postTime": "2024-07-27 22:45:48",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140742738,
    "title": "深入理解分析多线程概念、同步与无锁机制",
    "description": "线程是计算机程序执行的最小单位，它是进程内的一个独立执行序列。在多线程编程中，程序可以同时执行多个线程，这些线程可以独立运行，执行不同的任务，或者协同工作以完成一个复杂的任务。每个线程都有自己的执行上下文，包括程序计数器、寄存器、栈等，以便它们能够独立执行，并且可以共享进程的资源，例如全局变量、堆内存等。线程和进程的主要区别在于，进程是独立的执行环境，拥有自己的内存空间，而线程共享同一进程的内存空间。总之，线程是程序执行的基本单位，多线程编程已经成为编程领域的标准，有助于提高程序的性能、并发性和响应能力。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140742738",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742738",
    "postTime": "2024-07-27 22:45:10",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140742723,
    "title": "深入理解分析多线程概念、同步与无锁机制",
    "description": "线程是计算机程序执行的最小单位，它是进程内的一个独立执行序列。在多线程编程中，程序可以同时执行多个线程，这些线程可以独立运行，执行不同的任务，或者协同工作以完成一个复杂的任务。每个线程都有自己的执行上下文，包括程序计数器、寄存器、栈等，以便它们能够独立执行，并且可以共享进程的资源，例如全局变量、堆内存等。线程和进程的主要区别在于，进程是独立的执行环境，拥有自己的内存空间，而线程共享同一进程的内存空间。总之，线程是程序执行的基本单位，多线程编程已经成为编程领域的标准，有助于提高程序的性能、并发性和响应能力。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140742723",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742723",
    "postTime": "2024-07-27 22:44:29",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140742714,
    "title": "深入理解分析多线程概念、同步与无锁机制",
    "description": "线程是计算机程序执行的最小单位，它是进程内的一个独立执行序列。在多线程编程中，程序可以同时执行多个线程，这些线程可以独立运行，执行不同的任务，或者协同工作以完成一个复杂的任务。每个线程都有自己的执行上下文，包括程序计数器、寄存器、栈等，以便它们能够独立执行，并且可以共享进程的资源，例如全局变量、堆内存等。线程和进程的主要区别在于，进程是独立的执行环境，拥有自己的内存空间，而线程共享同一进程的内存空间。总之，线程是程序执行的基本单位，多线程编程已经成为编程领域的标准，有助于提高程序的性能、并发性和响应能力。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140742714",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 518,
    "commentCount": 2,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742714",
    "postTime": "2024-07-27 22:43:54",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140742711,
    "title": "深入理解分析多线程概念、同步与无锁机制",
    "description": "线程是计算机程序执行的最小单位，它是进程内的一个独立执行序列。在多线程编程中，程序可以同时执行多个线程，这些线程可以独立运行，执行不同的任务，或者协同工作以完成一个复杂的任务。每个线程都有自己的执行上下文，包括程序计数器、寄存器、栈等，以便它们能够独立执行，并且可以共享进程的资源，例如全局变量、堆内存等。线程和进程的主要区别在于，进程是独立的执行环境，拥有自己的内存空间，而线程共享同一进程的内存空间。总之，线程是程序执行的基本单位，多线程编程已经成为编程领域的标准，有助于提高程序的性能、并发性和响应能力。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140742711",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 336,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742711",
    "postTime": "2024-07-27 22:43:23",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140742697,
    "title": "深入理解分析多线程概念、同步与无锁机制",
    "description": "线程是计算机程序执行的最小单位，它是进程内的一个独立执行序列。在多线程编程中，程序可以同时执行多个线程，这些线程可以独立运行，执行不同的任务，或者协同工作以完成一个复杂的任务。每个线程都有自己的执行上下文，包括程序计数器、寄存器、栈等，以便它们能够独立执行，并且可以共享进程的资源，例如全局变量、堆内存等。线程和进程的主要区别在于，进程是独立的执行环境，拥有自己的内存空间，而线程共享同一进程的内存空间。总之，线程是程序执行的基本单位，多线程编程已经成为编程领域的标准，有助于提高程序的性能、并发性和响应能力。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140742697",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 528,
    "commentCount": 2,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742697",
    "postTime": "2024-07-27 22:43:16",
    "diggCount": 16,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 140084223,
    "title": "探究InnoDB Compact行格式背后",
    "description": "先分享一个真实的案例：某大型电商平台在一次促销活动中遭遇了数据库性能瓶颈，通过优化 InnoDB 的行格式，他们将查询性能提升了30%，存储成本降低了20%。这不仅帮助他们顺利度过了高峰期，还大大提升了用户体验。想象一下，你正在设计一个需要处理海量数据的应用，从用户信息到交易记录，每一行数据的存储方式都会直接影响到你的系统响应速度和存储成本。那么，如何选择最合适的行格式来最大化性能和效率呢？本次我们聚焦 InnoDB 行格式，理解它们是如何在幕后悄悄发挥作用的。",
    "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140084223",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 23,
    "commentCount": 2,
    "editUrl": "https://mp.csdn.net/console/editor/html/140084223",
    "postTime": "2024-06-30 18:20:11",
    "diggCount": 0,
    "formatTime": "2024.06.30",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/f333c89825ef43e29565520fc00b2813.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142070431,
    "title": "案例分析：并行计算让代码“飞”起来12",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070431",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 672,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070431",
    "postTime": "2024-09-09 21:56:39",
    "diggCount": 7,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142070397,
    "title": "案例分析：并行计算让代码“飞”起来11",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070397",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 583,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070397",
    "postTime": "2024-09-09 21:55:51",
    "diggCount": 20,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142070367,
    "title": "案例分析：并行计算让代码“飞”起来10",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070367",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 646,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070367",
    "postTime": "2024-09-09 21:54:04",
    "diggCount": 26,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142070326,
    "title": "案例分析：并行计算让代码“飞”起来9",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070326",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 752,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070326",
    "postTime": "2024-09-09 21:52:43",
    "diggCount": 9,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142070280,
    "title": "案例分析：并行计算让代码“飞”起来8",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070280",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 712,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070280",
    "postTime": "2024-09-09 21:51:01",
    "diggCount": 22,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142070267,
    "title": "案例分析：并行计算让代码“飞”起来7",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070267",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 743,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070267",
    "postTime": "2024-09-09 21:50:35",
    "diggCount": 26,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142070241,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070241",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1649,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070241",
    "postTime": "2024-09-09 21:49:12",
    "diggCount": 47,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 40
  },
  {
    "articleId": 142070212,
    "title": "案例分析：并行计算让代码“飞”起来5",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070212",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 900,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070212",
    "postTime": "2024-09-09 21:47:49",
    "diggCount": 13,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142070186,
    "title": "案例分析：并行计算让代码“飞”起来4",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070186",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 712,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070186",
    "postTime": "2024-09-09 21:46:24",
    "diggCount": 28,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142070151,
    "title": "案例分析：并行计算让代码“飞”起来3",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070151",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 896,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070151",
    "postTime": "2024-09-09 21:45:04",
    "diggCount": 13,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142070126,
    "title": "案例分析：并行计算让代码“飞”起来2",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070126",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 757,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070126",
    "postTime": "2024-09-09 21:43:56",
    "diggCount": 11,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142070104,
    "title": "案例分析：并行计算让代码“飞”起来1",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142070104",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 890,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070104",
    "postTime": "2024-09-09 21:42:50",
    "diggCount": 12,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142027078,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142027078",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 893,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027078",
    "postTime": "2024-09-08 14:58:25",
    "diggCount": 23,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142027057,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142027057",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 548,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027057",
    "postTime": "2024-09-08 14:57:10",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142027036,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142027036",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 631,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027036",
    "postTime": "2024-09-08 14:56:19",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142027025,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142027025",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 768,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027025",
    "postTime": "2024-09-08 14:56:13",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142026988,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142026988",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 901,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026988",
    "postTime": "2024-09-08 14:56:10",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142027012,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142027012",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 839,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027012",
    "postTime": "2024-09-08 14:54:51",
    "diggCount": 29,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142026968,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142026968",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 885,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026968",
    "postTime": "2024-09-08 14:54:47",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142026905,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142026905",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 670,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026905",
    "postTime": "2024-09-08 14:54:43",
    "diggCount": 13,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142026999,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142026999",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 941,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026999",
    "postTime": "2024-09-08 14:54:39",
    "diggCount": 23,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142026944,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142026944",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 683,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026944",
    "postTime": "2024-09-08 14:54:35",
    "diggCount": 26,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142026921,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142026921",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 502,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026921",
    "postTime": "2024-09-08 14:54:31",
    "diggCount": 24,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142026881,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142026881",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 856,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026881",
    "postTime": "2024-09-08 14:54:27",
    "diggCount": 24,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142026979,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142026979",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 827,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026979",
    "postTime": "2024-09-08 14:52:31",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142026957,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142026957",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 841,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026957",
    "postTime": "2024-09-08 14:51:22",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142026894,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/142026894",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1001,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142026894",
    "postTime": "2024-09-08 14:48:23",
    "diggCount": 34,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 141957449,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141957449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 864,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957449",
    "postTime": "2024-09-06 13:30:52",
    "diggCount": 5,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141957440,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141957440",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957440",
    "postTime": "2024-09-06 13:30:18",
    "diggCount": 4,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141957412,
    "title": "超越常规：斐波那契数列的极速计算技术8",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141957412",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 562,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957412",
    "postTime": "2024-09-06 13:28:40",
    "diggCount": 20,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141957395,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141957395",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 821,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957395",
    "postTime": "2024-09-06 13:27:15",
    "diggCount": 16,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141957367,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141957367",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 436,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957367",
    "postTime": "2024-09-06 13:25:32",
    "diggCount": 10,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141957324,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141957324",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 496,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957324",
    "postTime": "2024-09-06 13:22:52",
    "diggCount": 10,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141957296,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141957296",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 795,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957296",
    "postTime": "2024-09-06 13:21:34",
    "diggCount": 13,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141957274,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141957274",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 792,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957274",
    "postTime": "2024-09-06 13:20:09",
    "diggCount": 18,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141957254,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141957254",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 462,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957254",
    "postTime": "2024-09-06 13:18:51",
    "diggCount": 10,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141957232,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141957232",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 544,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957232",
    "postTime": "2024-09-06 13:17:37",
    "diggCount": 7,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141931313,
    "title": "案例分析：池化对象的应用场景15",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141931313",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 955,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931313",
    "postTime": "2024-09-05 14:59:09",
    "diggCount": 27,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8343c5e980f04d9e9441256c909fe57e.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141931289,
    "title": "案例分析：池化对象的应用场景14",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141931289",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 664,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931289",
    "postTime": "2024-09-05 14:58:22",
    "diggCount": 11,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/86623bee89fa40d186a5b3d5fa98722b.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141931255,
    "title": "案例分析：池化对象的应用场景13",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141931255",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 2050,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931255",
    "postTime": "2024-09-05 14:57:17",
    "diggCount": 51,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e94db4ebbb464383bccea8d5e620a602.png"
    ],
    "collectCount": 56
  },
  {
    "articleId": 141931190,
    "title": "案例分析：池化对象的应用场景12",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141931190",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 749,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931190",
    "postTime": "2024-09-05 14:56:48",
    "diggCount": 30,
    "formatTime": "2024.09.05",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/d565a15d07dd2ad2a4884cdc4e98f12f.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141931147,
    "title": "案例分析：池化对象的应用场景11",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141931147",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 888,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931147",
    "postTime": "2024-09-05 14:54:16",
    "diggCount": 22,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/86623bee89fa40d186a5b3d5fa98722b.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141931128,
    "title": "案例分析：池化对象的应用场景10",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141931128",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 993,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931128",
    "postTime": "2024-09-05 14:53:43",
    "diggCount": 18,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a73b81ff0eb42c89f226db2f362811f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141931078,
    "title": "案例分析：池化对象的应用场景9",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141931078",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 590,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931078",
    "postTime": "2024-09-05 14:52:39",
    "diggCount": 25,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8343c5e980f04d9e9441256c909fe57e.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 141931028,
    "title": "案例分析：池化对象的应用场景8",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141931028",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1019,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931028",
    "postTime": "2024-09-05 14:51:23",
    "diggCount": 17,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/86623bee89fa40d186a5b3d5fa98722b.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141930990,
    "title": "案例分析：池化对象的应用场景7",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141930990",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 315,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930990",
    "postTime": "2024-09-05 14:50:11",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/86623bee89fa40d186a5b3d5fa98722b.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141930965,
    "title": "案例分析：池化对象的应用场景6",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141930965",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 995,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930965",
    "postTime": "2024-09-05 14:49:44",
    "diggCount": 14,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/86623bee89fa40d186a5b3d5fa98722b.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141930932,
    "title": "案例分析：池化对象的应用场景5",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141930932",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 734,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930932",
    "postTime": "2024-09-05 14:48:30",
    "diggCount": 25,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6f1fcbb588b04a1882b554762e47c490.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141930912,
    "title": "案例分析：池化对象的应用场景4",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141930912",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 609,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930912",
    "postTime": "2024-09-05 14:47:53",
    "diggCount": 9,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a73b81ff0eb42c89f226db2f362811f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 141930888,
    "title": "案例分析：池化对象的应用场景3",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141930888",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 986,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930888",
    "postTime": "2024-09-05 14:47:20",
    "diggCount": 17,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8343c5e980f04d9e9441256c909fe57e.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141930820,
    "title": "案例分析：池化对象的应用场景2",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141930820",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 295,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930820",
    "postTime": "2024-09-05 14:45:59",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/86623bee89fa40d186a5b3d5fa98722b.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141930792,
    "title": "案例分析：池化对象的应用场景1",
    "description": "在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。这个时候，我们就可以。在 Java 中，应用非常广泛，常见的就有数据库连接池、线程池等，本节课主讲连接池，线程池我们将在 12 课时进行介绍。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141930792",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 785,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141930792",
    "postTime": "2024-09-05 14:45:32",
    "diggCount": 24,
    "formatTime": "2024.09.05",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141890780,
    "title": "缓冲区的奥秘：解析数据交错的魔法15",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890780",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 619,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890780",
    "postTime": "2024-09-04 13:06:37",
    "diggCount": 13,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 14
  },
  {
    "articleId": 141890764,
    "title": "缓冲区的奥秘：解析数据交错的魔法14",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890764",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1016,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890764",
    "postTime": "2024-09-04 13:03:31",
    "diggCount": 28,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 17
  },
  {
    "articleId": 141890733,
    "title": "缓冲区的奥秘：解析数据交错的魔法13",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890733",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 657,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890733",
    "postTime": "2024-09-04 13:03:10",
    "diggCount": 17,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 15
  },
  {
    "articleId": 141890711,
    "title": "缓冲区的奥秘：解析数据交错的魔法12",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890711",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 748,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890711",
    "postTime": "2024-09-04 13:01:03",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 12
  },
  {
    "articleId": 141890701,
    "title": "缓冲区的奥秘：解析数据交错的魔法11",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890701",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 872,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890701",
    "postTime": "2024-09-04 13:00:26",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 18
  },
  {
    "articleId": 141890691,
    "title": "缓冲区的奥秘：解析数据交错的魔法10",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890691",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 962,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890691",
    "postTime": "2024-09-04 12:59:55",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 8
  },
  {
    "articleId": 141890651,
    "title": "缓冲区的奥秘：解析数据交错的魔法9",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890651",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 676,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890651",
    "postTime": "2024-09-04 12:58:27",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 15
  },
  {
    "articleId": 141890638,
    "title": "缓冲区的奥秘：解析数据交错的魔法8",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890638",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 491,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890638",
    "postTime": "2024-09-04 12:57:55",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 16
  },
  {
    "articleId": 141890617,
    "title": "缓冲区的奥秘：解析数据交错的魔法7",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890617",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 437,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890617",
    "postTime": "2024-09-04 12:56:05",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 15
  },
  {
    "articleId": 141890584,
    "title": "缓冲区的奥秘：解析数据交错的魔法6",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890584",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 836,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890584",
    "postTime": "2024-09-04 12:54:56",
    "diggCount": 13,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 5
  },
  {
    "articleId": 141890577,
    "title": "缓冲区的奥秘：解析数据交错的魔法5",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890577",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 806,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890577",
    "postTime": "2024-09-04 12:54:23",
    "diggCount": 15,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 10
  },
  {
    "articleId": 141890564,
    "title": "缓冲区的奥秘：解析数据交错的魔法4",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890564",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 753,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890564",
    "postTime": "2024-09-04 12:53:07",
    "diggCount": 15,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 9
  },
  {
    "articleId": 141890516,
    "title": "缓冲区的奥秘：解析数据交错的魔法3",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890516",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 748,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890516",
    "postTime": "2024-09-04 12:52:42",
    "diggCount": 7,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 17
  },
  {
    "articleId": 141890502,
    "title": "缓冲区的奥秘：解析数据交错的魔法2",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890502",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 806,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890502",
    "postTime": "2024-09-04 12:50:09",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 14
  },
  {
    "articleId": 141890497,
    "title": "缓冲区的奥秘：解析数据交错的魔法1",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141890497",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 569,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890497",
    "postTime": "2024-09-04 12:49:35",
    "diggCount": 11,
    "formatTime": "2024.09.04",
    "picList": [],
    "collectCount": 8
  },
  {
    "articleId": 141848841,
    "title": "MySQL索引性能优化分析6",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141848841",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 816,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141848841",
    "postTime": "2024-09-03 09:25:01",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [],
    "collectCount": 3
  },
  {
    "articleId": 141848347,
    "title": "MySQL索引性能优化分析5",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141848347",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 935,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141848347",
    "postTime": "2024-09-03 09:20:06",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [],
    "collectCount": 6
  },
  {
    "articleId": 141848212,
    "title": "MySQL索引性能优化分析4",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141848212",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 819,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141848212",
    "postTime": "2024-09-03 09:18:46",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [],
    "collectCount": 9
  },
  {
    "articleId": 141847996,
    "title": "MySQL索引性能优化分析3",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141847996",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 719,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141847996",
    "postTime": "2024-09-03 09:16:32",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [],
    "collectCount": 4
  },
  {
    "articleId": 141847871,
    "title": "MySQL索引性能优化分析2",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141847871",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 803,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141847871",
    "postTime": "2024-09-03 09:15:17",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [],
    "collectCount": 5
  },
  {
    "articleId": 141847721,
    "title": "MySQL索引性能优化分析1",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141847721",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 835,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141847721",
    "postTime": "2024-09-03 09:13:46",
    "diggCount": 11,
    "formatTime": "2024.09.03",
    "picList": [],
    "collectCount": 8
  },
  {
    "articleId": 141821324,
    "title": "案例：乐观锁实现余额更新",
    "description": "根据测试结果，乐观锁的总耗时明显比悲观锁少，而且最终余额也保持了正确的值。这与乐观锁的特性相符合，因为乐观锁在读多写少的场景下性能通常会更好，而且不会导致线程阻塞，从而提高了并发性能。，我们希望使用乐观锁实现对余额的更新操作。，其中包含一个余额字段。假设我们有一个账户类。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141821324",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141821324",
    "postTime": "2024-09-02 15:34:55",
    "diggCount": 8,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141821298,
    "title": "悲观锁在读多写少的情况下也有冲突少的特点，为什么不适合呢？",
    "description": "尽管悲观锁在一些情况下也能够处理并发问题，但在读多写少的情况下，乐观锁更适合，因为它更符合读多写少的特点，可以更好地实现读操作的并发执行，提高系统的性能。尽管悲观锁在读多写少的情况下可能会有较少的冲突，但它的主要问题在于。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141821298",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 118,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141821298",
    "postTime": "2024-09-02 15:34:13",
    "diggCount": 2,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141820876,
    "title": "乐观锁适用于读多写少的情况的原因",
    "description": "乐观锁在读取数据时并不会进行加锁操作，而是先读取数据，然后在更新数据时检查是否被其他线程修改过。因此，即使有写操作正在进行，读操作也不会被阻塞，从而可以实现读操作的并发执行。：在读多写少的情况下，写操作的频率较低，因此冲突的概率也相对较低。乐观锁的重试操作是在发生冲突时进行的，因此在冲突较少的情况下，重试的概率也较低，从而可以更高效地处理并发冲突。：乐观锁的实现通常比较轻量级，不需要频繁地进行加锁和解锁操作，因此在读多写少的情况下，乐观锁的性能通常会更好。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141820876",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 160,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820876",
    "postTime": "2024-09-02 15:21:16",
    "diggCount": 1,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-home.csdnimg.cn/images/20230308042807.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141820858,
    "title": "悲观锁在读多写少的情况下也有冲突少的特点，为什么不适合呢？",
    "description": "尽管悲观锁在一些情况下也能够处理并发问题，但在读多写少的情况下，乐观锁更适合，因为它更符合读多写少的特点，可以更好地实现读操作的并发执行，提高系统的性能。尽管悲观锁在读多写少的情况下可能会有较少的冲突，但它的主要问题在于。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141820858",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820858",
    "postTime": "2024-09-02 15:20:45",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/95d5fb0ebb292879335c259693a17ec7.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141820832,
    "title": "CAS（Compare-And-Swap）可以被看作是乐观锁的一种实现方式。",
    "description": "乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。CAS（Compare-And-Swap）可以被看作是乐观锁的一种实现方式。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141820832",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 304,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820832",
    "postTime": "2024-09-02 15:20:00",
    "diggCount": 3,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/95d5fb0ebb292879335c259693a17ec7.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141820815,
    "title": "使用 AtomicInteger（CAS 实现）和 synchronized 关键字来实现一个计数器",
    "description": "关键字来实现一个计数器，并进行多线程并发访问，最后比较它们的性能。为了验证原子类的性能优势，可以编写一个简单的测试程序，分别使用。类的方式具有更好的性能。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141820815",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 552,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820815",
    "postTime": "2024-09-02 15:19:29",
    "diggCount": 21,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141820786,
    "title": "synchronized 是 Java 内置的同步机制",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141820786",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 725,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820786",
    "postTime": "2024-09-02 15:18:56",
    "diggCount": 9,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 141820730,
    "title": "日志缓冲（Logging Buffering）",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141820730",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 508,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820730",
    "postTime": "2024-09-02 15:17:18",
    "diggCount": 24,
    "formatTime": "2024.09.02",
    "picList": [],
    "collectCount": 11
  },
  {
    "articleId": 141820650,
    "title": "Kafka缓存区优化思考",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141820650",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 827,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820650",
    "postTime": "2024-09-02 15:14:30",
    "diggCount": 15,
    "formatTime": "2024.09.02",
    "picList": [],
    "collectCount": 9
  },
  {
    "articleId": 141820617,
    "title": "MySQL B+树索引回顾",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/141820617",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1858,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141820617",
    "postTime": "2024-09-02 15:13:39",
    "diggCount": 36,
    "formatTime": "2024.09.02",
    "picList": [],
    "collectCount": 23
  },
  {
    "articleId": 140905435,
    "title": "利用表态投票机制实现技术文章的真实读者反馈",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905435",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 418,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905435",
    "postTime": "2024-08-04 13:56:12",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d04eb847e7844e6dba85545bc440628e.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140905426,
    "title": "揭秘表态投票：如何通过实时反馈提升技术文章的准确性",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905426",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 458,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905426",
    "postTime": "2024-08-04 13:55:53",
    "diggCount": 11,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ca56f9386ce8498a972ffc81eece8e1a.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140905471,
    "title": "从反馈到改进：表态投票在技术文章中的创新应用",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905471",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 463,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905471",
    "postTime": "2024-08-04 13:55:34",
    "diggCount": 13,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/632ec26b11774f80a58aec72cccec310.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140905491,
    "title": "技术文章新风向：表态投票带来的反馈革命",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905491",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 374,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905491",
    "postTime": "2024-08-04 13:55:15",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/621b2f50c0c944c28598ec74fc5c48d9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140905454,
    "title": "实现技术文章的真实读者反馈的表态投票机制",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905454",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 418,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905454",
    "postTime": "2024-08-04 13:55:01",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/868fa15e595e4f20b694e4a443210212.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140905485,
    "title": "优化技术内容：表态投票如何塑造更具影响力的文章",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905485",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 319,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905485",
    "postTime": "2024-08-04 13:54:36",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3b9e36dc254740a9a897a3b40d8b8d6f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140905478,
    "title": "获得精确读者反馈的技术路径的表态投票实现",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905478",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 230,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905478",
    "postTime": "2024-08-04 13:54:07",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/23957940b8ea4d4997893b9b6c869c45.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140905430,
    "title": "表态投票如何塑造更具影响力的文章来优化技术内容",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905430",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 357,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905430",
    "postTime": "2024-08-04 13:54:02",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b27d306ec0764cc5969ac7ff777db588.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140905445,
    "title": "通过表态投票获得精确读者反馈的技术路径",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905445",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905445",
    "postTime": "2024-08-04 13:53:36",
    "diggCount": 4,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/44ca862ba66f4d58b4fa559e46b820ef.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140905463,
    "title": "深入解析表态投票机制在技术写作中的应用潜力",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905463",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 192,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905463",
    "postTime": "2024-08-04 13:52:34",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4f3120059b3f4691b4b3f8cebdb4366e.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140905458,
    "title": "从数据到决策：表态投票如何改变技术文章的评估方式",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140905458",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 341,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140905458",
    "postTime": "2024-08-04 13:52:01",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bbb1bfde1be54d05a18eefdc14e9fc88.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140899558,
    "title": "如何通过表态投票机制提高技术文章的质量与相关性",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140899558",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 303,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899558",
    "postTime": "2024-08-04 00:37:04",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6aa5ea77057a408e920c82f696ddf6ac.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140899545,
    "title": "构建更具互动性的技术文章：表态投票的应用实例",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140899545",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 422,
    "commentCount": 40,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899545",
    "postTime": "2024-08-04 00:35:53",
    "diggCount": 10,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/35905c81c6244880bbe9f56235299dfd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140887011,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140887011",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 660,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887011",
    "postTime": "2024-08-03 10:51:26",
    "diggCount": 24,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 18
  },
  {
    "articleId": 140887074,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140887074",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 689,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887074",
    "postTime": "2024-08-03 10:51:02",
    "diggCount": 21,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 13
  },
  {
    "articleId": 140887067,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140887067",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 783,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887067",
    "postTime": "2024-08-03 10:50:45",
    "diggCount": 25,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 16
  },
  {
    "articleId": 140887028,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140887028",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 891,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887028",
    "postTime": "2024-08-03 10:49:41",
    "diggCount": 14,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 6
  },
  {
    "articleId": 140887039,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140887039",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 750,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887039",
    "postTime": "2024-08-03 10:49:14",
    "diggCount": 9,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 19
  },
  {
    "articleId": 140887005,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140887005",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 758,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140887005",
    "postTime": "2024-08-03 10:47:02",
    "diggCount": 21,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 16
  },
  {
    "articleId": 140886968,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140886968",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 726,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140886968",
    "postTime": "2024-08-03 10:44:38",
    "diggCount": 18,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 14
  },
  {
    "articleId": 140886950,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140886950",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140886950",
    "postTime": "2024-08-03 10:43:44",
    "diggCount": 9,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 17
  },
  {
    "articleId": 140886876,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140886876",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 720,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140886876",
    "postTime": "2024-08-03 10:43:03",
    "diggCount": 30,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 10
  },
  {
    "articleId": 140886938,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140886938",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 736,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140886938",
    "postTime": "2024-08-03 10:42:54",
    "diggCount": 14,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 20
  },
  {
    "articleId": 140886927,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140886927",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 499,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140886927",
    "postTime": "2024-08-03 10:42:18",
    "diggCount": 14,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 19
  },
  {
    "articleId": 140886920,
    "title": "缓冲区的奥秘：解析数据交错的魔法",
    "description": "在计算机科学的广袤世界里，有一项看似简单却又深奥无比的技术，那就是缓冲。缓冲，像是隐藏在代码背后的魔法，它默默地改变着数据的流动，使得看似杂乱无章的操作变得井然有序。然而，它的本质并非只是简单的数据暂存，而是一种艺术，一门科学。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140886920",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 828,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140886920",
    "postTime": "2024-08-03 10:41:35",
    "diggCount": 11,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 10
  },
  {
    "articleId": 140862640,
    "title": "超越并发瓶颈：CAS与乐观锁的智慧应用",
    "description": "超越并发瓶颈：CAS与乐观锁的智慧应用。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140862640",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 344,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862640",
    "postTime": "2024-08-02 08:36:02",
    "diggCount": 4,
    "formatTime": "2024.08.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140862589,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140862589",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 14,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862589",
    "postTime": "2024-08-02 08:28:31",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862562,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140862562",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 12,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862562",
    "postTime": "2024-08-02 08:25:33",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862557,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140862557",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 13,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862557",
    "postTime": "2024-08-02 08:24:59",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862541,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140862541",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 10,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862541",
    "postTime": "2024-08-02 08:22:56",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862532,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140862532",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 11,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862532",
    "postTime": "2024-08-02 08:22:07",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140862523,
    "title": "决战超越并发瓶颈---解决并发难题",
    "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140862523",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 12,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140862523",
    "postTime": "2024-08-02 08:21:28",
    "diggCount": 0,
    "formatTime": "2024.08.02",
    "picList": [
      "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140809710,
    "title": "MySQL索引性能优化分析扩展和深入",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140809710",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 45,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809710",
    "postTime": "2024-07-30 23:47:12",
    "diggCount": 4,
    "formatTime": "2024.07.30",
    "picList": [],
    "collectCount": 4
  },
  {
    "articleId": 140809684,
    "title": "MySQL索引性能优化分析扩展和深入",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140809684",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809684",
    "postTime": "2024-07-30 23:45:47",
    "diggCount": 3,
    "formatTime": "2024.07.30",
    "picList": [],
    "collectCount": 9
  },
  {
    "articleId": 140809673,
    "title": "MySQL索引性能优化分析扩展和深入",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140809673",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 422,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809673",
    "postTime": "2024-07-30 23:45:14",
    "diggCount": 3,
    "formatTime": "2024.07.30",
    "picList": [],
    "collectCount": 5
  },
  {
    "articleId": 140809657,
    "title": "MySQL索引性能优化分析扩展和深入",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140809657",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809657",
    "postTime": "2024-07-30 23:44:28",
    "diggCount": 3,
    "formatTime": "2024.07.30",
    "picList": [],
    "collectCount": 7
  },
  {
    "articleId": 140809644,
    "title": "MySQL索引性能优化分析扩展和深入",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140809644",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 639,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809644",
    "postTime": "2024-07-30 23:44:15",
    "diggCount": 22,
    "formatTime": "2024.07.30",
    "picList": [],
    "collectCount": 5
  },
  {
    "articleId": 140809629,
    "title": "MySQL索引性能优化分析扩展和深入",
    "description": "其中，UNIQUE 表示创建唯一索引，FULLTEXT 表示创建全文索引，SPATIAL 表示创建空间索引，index_name 是索引的名称，table_name 是要创建索引的表名，(column1, column2, ...) 是要创建索引的列名。但是，使用联合查询分页的缺点是，需要进行两次查询，增加了查询的时间。正确使用索引可以避免因过多的无效索引造成的额外的存储空间和内存消耗，避免在大数据量和高并发的情况下出现慢查询和数据库性能下降的问题，同时也可以提高系统的安全性，减少数据损失的风险。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140809629",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 862,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140809629",
    "postTime": "2024-07-30 23:43:55",
    "diggCount": 29,
    "formatTime": "2024.07.30",
    "picList": [],
    "collectCount": 15
  },
  {
    "articleId": 140741952,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140741952",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 158,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140741952",
    "postTime": "2024-07-27 22:03:29",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6bfb3f5e970f4ba5b09e91dda9c5a5c7.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140741938,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140741938",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 268,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140741938",
    "postTime": "2024-07-27 22:02:41",
    "diggCount": 10,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01e3fe786e574ad198667dafccc4d5ef.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742104,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140742104",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 153,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742104",
    "postTime": "2024-07-27 22:02:21",
    "diggCount": 1,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1f2c61ffbd94cecba90005699bd69b3.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742088,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140742088",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 94,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742088",
    "postTime": "2024-07-27 22:01:41",
    "diggCount": 2,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/90e48ff33e1b4e75b559240e54564646.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742071,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140742071",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 271,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742071",
    "postTime": "2024-07-27 22:00:26",
    "diggCount": 6,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ae4c1250eaf241dcacaec8c2c912b09a.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742043,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140742043",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 219,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742043",
    "postTime": "2024-07-27 21:59:07",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e08443398f444a9c90929daaa043161e.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742030,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140742030",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 140,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742030",
    "postTime": "2024-07-27 21:58:53",
    "diggCount": 1,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ab5d7a174bf54609b32098481517a3de.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742017,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140742017",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 128,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742017",
    "postTime": "2024-07-27 21:58:43",
    "diggCount": 1,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/dd2e3489bec04ecbbffbcac4137519e2.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742002,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140742002",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 209,
    "commentCount": 26,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742002",
    "postTime": "2024-07-27 21:58:23",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c980471c622f4d6293fcb3d300ddc7ba.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140741981,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140741981",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 119,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140741981",
    "postTime": "2024-07-27 21:58:10",
    "diggCount": 3,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d9b309955b2f40aba5ec6a7a434c103b.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140741966,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140741966",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 298,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140741966",
    "postTime": "2024-07-27 21:57:54",
    "diggCount": 5,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140742025,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140742025",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140742025",
    "postTime": "2024-07-27 21:57:19",
    "diggCount": 4,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a409ed454a234fd28b37f8e713ba810c.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140741947,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140741947",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 108,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140741947",
    "postTime": "2024-07-27 21:57:13",
    "diggCount": 2,
    "formatTime": "2024.07.27",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d1abb12edd5841baadb88f01776a88f1.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140741926,
    "title": "转载实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140741926",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 96,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140741926",
    "postTime": "2024-07-27 21:52:11",
    "diggCount": 1,
    "formatTime": "2024.07.27",
    "picList": [],
    "collectCount": 0
  },
  {
    "articleId": 140741841,
    "title": "实战指南：理解 ThreadLocal 原理并用于Java 多线程上下文管理",
    "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
    "url": "https://blog.csdn.net/xiaoxu2022xiaoxu/article/details/140741841",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 403,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140741841",
    "postTime": "2024-07-27 21:46:00",
    "diggCount": 9,
    "formatTime": "2024.07.27",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142070772,
    "title": "案例分析：并行计算让代码“飞”起来10",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142070772",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1032,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070772",
    "postTime": "2024-09-09 22:12:13",
    "diggCount": 29,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142070725,
    "title": "案例分析：并行计算让代码“飞”起来9",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142070725",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 983,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070725",
    "postTime": "2024-09-09 22:10:27",
    "diggCount": 28,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142070690,
    "title": "案例分析：并行计算让代码“飞”起来8",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142070690",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 912,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070690",
    "postTime": "2024-09-09 22:09:01",
    "diggCount": 32,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142070658,
    "title": "案例分析：并行计算让代码“飞”起来7",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142070658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1005,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070658",
    "postTime": "2024-09-09 22:07:29",
    "diggCount": 16,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142070644,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142070644",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 819,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070644",
    "postTime": "2024-09-09 22:06:58",
    "diggCount": 18,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142070634,
    "title": "案例分析：并行计算让代码“飞”起来5",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142070634",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 642,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070634",
    "postTime": "2024-09-09 22:06:27",
    "diggCount": 28,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142070611,
    "title": "案例分析：并行计算让代码“飞”起来4",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142070611",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 756,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070611",
    "postTime": "2024-09-09 22:05:07",
    "diggCount": 27,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142070533,
    "title": "案例分析：并行计算让代码“飞”起来3",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142070533",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 632,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070533",
    "postTime": "2024-09-09 22:01:35",
    "diggCount": 7,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142070510,
    "title": "案例分析：并行计算让代码“飞”起来2",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142070510",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 915,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070510",
    "postTime": "2024-09-09 22:00:19",
    "diggCount": 8,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142070482,
    "title": "案例分析：并行计算让代码“飞”起来1",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142070482",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1230,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070482",
    "postTime": "2024-09-09 21:59:02",
    "diggCount": 29,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142027289,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027289",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 867,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027289",
    "postTime": "2024-09-08 15:26:03",
    "diggCount": 24,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142027609,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027609",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 778,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027609",
    "postTime": "2024-09-08 15:25:57",
    "diggCount": 18,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142027565,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027565",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1006,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027565",
    "postTime": "2024-09-08 15:24:01",
    "diggCount": 27,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142027555,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027555",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 723,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027555",
    "postTime": "2024-09-08 15:23:55",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142027490,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027490",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 800,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027490",
    "postTime": "2024-09-08 15:22:36",
    "diggCount": 9,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142027407,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027407",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 545,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027407",
    "postTime": "2024-09-08 15:22:30",
    "diggCount": 11,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142027376,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027376",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 930,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027376",
    "postTime": "2024-09-08 15:22:26",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 142027341,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027341",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 893,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027341",
    "postTime": "2024-09-08 15:22:22",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142027322,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027322",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 530,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027322",
    "postTime": "2024-09-08 15:22:18",
    "diggCount": 26,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142027528,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027528",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 925,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027528",
    "postTime": "2024-09-08 15:22:08",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142027431,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027431",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 931,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027431",
    "postTime": "2024-09-08 15:21:13",
    "diggCount": 29,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142027500,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027500",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 871,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027500",
    "postTime": "2024-09-08 15:21:07",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142027460,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027460",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 915,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027460",
    "postTime": "2024-09-08 15:19:22",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142027446,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027446",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 824,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027446",
    "postTime": "2024-09-08 15:18:28",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142027417,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/142027417",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 939,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027417",
    "postTime": "2024-09-08 15:17:10",
    "diggCount": 13,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 141965159,
    "title": "超越常规：斐波那契数列的极速计算技术12",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141965159",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965159",
    "postTime": "2024-09-06 17:27:15",
    "diggCount": 3,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141965142,
    "title": "超越常规：斐波那契数列的极速计算技术11",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141965142",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965142",
    "postTime": "2024-09-06 17:26:40",
    "diggCount": 3,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141965121,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141965121",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 244,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965121",
    "postTime": "2024-09-06 17:25:58",
    "diggCount": 5,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141965099,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141965099",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 392,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965099",
    "postTime": "2024-09-06 17:25:23",
    "diggCount": 5,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141964844,
    "title": "超越常规：斐波那契数列的极速计算技术8",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141964844",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 902,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141964844",
    "postTime": "2024-09-06 17:16:48",
    "diggCount": 22,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141964823,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141964823",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 606,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141964823",
    "postTime": "2024-09-06 17:16:18",
    "diggCount": 16,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141958124,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141958124",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 704,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141958124",
    "postTime": "2024-09-06 13:58:08",
    "diggCount": 6,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141957625,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141957625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 443,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957625",
    "postTime": "2024-09-06 13:38:31",
    "diggCount": 5,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141957596,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141957596",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 747,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957596",
    "postTime": "2024-09-06 13:37:11",
    "diggCount": 17,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141957560,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141957560",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 988,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957560",
    "postTime": "2024-09-06 13:35:57",
    "diggCount": 15,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141957531,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141957531",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 464,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957531",
    "postTime": "2024-09-06 13:34:42",
    "diggCount": 10,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141957506,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141957506",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 460,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141957506",
    "postTime": "2024-09-06 13:33:31",
    "diggCount": 16,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141931881,
    "title": "案例分析：大对象复用的目标和注意点15",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931881",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 284,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931881",
    "postTime": "2024-09-05 15:15:52",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141931854,
    "title": "案例分析：大对象复用的目标和注意点14",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931854",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1028,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931854",
    "postTime": "2024-09-05 15:15:15",
    "diggCount": 12,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141931833,
    "title": "案例分析：大对象复用的目标和注意点13",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931833",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 770,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931833",
    "postTime": "2024-09-05 15:14:43",
    "diggCount": 28,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141931815,
    "title": "案例分析：大对象复用的目标和注意点12",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931815",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 223,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931815",
    "postTime": "2024-09-05 15:14:10",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141931794,
    "title": "案例分析：大对象复用的目标和注意点11",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931794",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 383,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931794",
    "postTime": "2024-09-05 15:13:31",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141931767,
    "title": "案例分析：大对象复用的目标和注意点10",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931767",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 394,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931767",
    "postTime": "2024-09-05 15:12:57",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141931752,
    "title": "案例分析：大对象复用的目标和注意点9",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931752",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1044,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931752",
    "postTime": "2024-09-05 15:12:25",
    "diggCount": 22,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 141931724,
    "title": "案例分析：大对象复用的目标和注意点8",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931724",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 823,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931724",
    "postTime": "2024-09-05 15:11:46",
    "diggCount": 24,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 141931710,
    "title": "案例分析：大对象复用的目标和注意点7",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931710",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 853,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931710",
    "postTime": "2024-09-05 15:11:14",
    "diggCount": 24,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141931613,
    "title": "案例分析：大对象复用的目标和注意点6",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931613",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 973,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931613",
    "postTime": "2024-09-05 15:08:05",
    "diggCount": 7,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 141931585,
    "title": "案例分析：大对象复用的目标和注意点5",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931585",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 847,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931585",
    "postTime": "2024-09-05 15:07:25",
    "diggCount": 12,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141931564,
    "title": "案例分析：大对象复用的目标和注意点4",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931564",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 953,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931564",
    "postTime": "2024-09-05 15:06:35",
    "diggCount": 16,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141931548,
    "title": "案例分析：大对象复用的目标和注意点3",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931548",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 575,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931548",
    "postTime": "2024-09-05 15:06:01",
    "diggCount": 19,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141931466,
    "title": "案例分析：大对象复用的目标和注意点2",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931466",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 801,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931466",
    "postTime": "2024-09-05 15:03:36",
    "diggCount": 12,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 141931438,
    "title": "案例分析：大对象复用的目标和注意点1",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141931438",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 989,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141931438",
    "postTime": "2024-09-05 15:03:06",
    "diggCount": 16,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 141890420,
    "title": "使用同步锁的代码示例43",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890420",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 230,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890420",
    "postTime": "2024-09-04 12:45:17",
    "diggCount": 3,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141890404,
    "title": "使用同步锁的代码示例44",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890404",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 189,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890404",
    "postTime": "2024-09-04 12:44:28",
    "diggCount": 3,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141890182,
    "title": "使用同步锁的代码示例41",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890182",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 236,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890182",
    "postTime": "2024-09-04 12:30:57",
    "diggCount": 4,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141890165,
    "title": "使用同步锁的代码示例40",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890165",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 224,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890165",
    "postTime": "2024-09-04 12:30:52",
    "diggCount": 5,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141890204,
    "title": "使用同步锁的代码示例39",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890204",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 134,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890204",
    "postTime": "2024-09-04 12:30:45",
    "diggCount": 5,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141890187,
    "title": "【无标题】使用同步锁的代码示例42",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890187",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 290,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890187",
    "postTime": "2024-09-04 12:29:18",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141890155,
    "title": "使用同步锁的代码示例45",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890155",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 309,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890155",
    "postTime": "2024-09-04 12:27:13",
    "diggCount": 3,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141890149,
    "title": "使用同步锁的代码示例38",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890149",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890149",
    "postTime": "2024-09-04 12:27:00",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141890133,
    "title": "使用同步锁的代码示例37",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890133",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 207,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890133",
    "postTime": "2024-09-04 12:26:31",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141890124,
    "title": "使用同步锁的代码示例36",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890124",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 257,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890124",
    "postTime": "2024-09-04 12:26:23",
    "diggCount": 3,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141890109,
    "title": "使用同步锁的代码示例35",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890109",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 320,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890109",
    "postTime": "2024-09-04 12:26:18",
    "diggCount": 5,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141890095,
    "title": "使用同步锁的代码示例34",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890095",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 205,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890095",
    "postTime": "2024-09-04 12:24:29",
    "diggCount": 4,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141890082,
    "title": "使用同步锁的代码示例33",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890082",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 305,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890082",
    "postTime": "2024-09-04 12:24:24",
    "diggCount": 1,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141890070,
    "title": "使用同步锁的代码示例32",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890070",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 430,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890070",
    "postTime": "2024-09-04 12:24:19",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141890056,
    "title": "使用同步锁的代码示例31",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141890056",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890056",
    "postTime": "2024-09-04 12:20:02",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141858658,
    "title": "使用同步锁的代码示例30",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 447,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858658",
    "postTime": "2024-09-03 12:53:46",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141858647,
    "title": "使用同步锁的代码示例29",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858647",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 151,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858647",
    "postTime": "2024-09-03 12:53:12",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141858619,
    "title": "使用同步锁的代码示例28",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858619",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 148,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858619",
    "postTime": "2024-09-03 12:52:11",
    "diggCount": 2,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141858612,
    "title": "使用同步锁的代码示例27",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858612",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 326,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858612",
    "postTime": "2024-09-03 12:51:41",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141858595,
    "title": "使用同步锁的代码示例26",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858595",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 310,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858595",
    "postTime": "2024-09-03 12:50:52",
    "diggCount": 15,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141858591,
    "title": "使用同步锁的代码示例25",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858591",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 224,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858591",
    "postTime": "2024-09-03 12:50:16",
    "diggCount": 2,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141858568,
    "title": "使用同步锁的代码示例23",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858568",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 283,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858568",
    "postTime": "2024-09-03 12:49:40",
    "diggCount": 1,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141858561,
    "title": "使用同步锁的代码示例22",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858561",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 224,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858561",
    "postTime": "2024-09-03 12:49:03",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141858555,
    "title": "使用同步锁的代码示例21",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858555",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 351,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858555",
    "postTime": "2024-09-03 12:48:28",
    "diggCount": 14,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141858548,
    "title": "使用同步锁的代码示例20",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858548",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858548",
    "postTime": "2024-09-03 12:47:57",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141858517,
    "title": "使用同步锁的代码示例19",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858517",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 232,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858517",
    "postTime": "2024-09-03 12:46:11",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141858509,
    "title": "使用同步锁的代码示例18",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858509",
    "postTime": "2024-09-03 12:45:38",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141858466,
    "title": "使用同步锁的代码示例17",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858466",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 327,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858466",
    "postTime": "2024-09-03 12:43:22",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141858459,
    "title": "使用同步锁的代码示例16",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141858459",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 412,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858459",
    "postTime": "2024-09-03 12:42:52",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141828555,
    "title": "使用同步锁的代码示例4",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828555",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 135,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828555",
    "postTime": "2024-09-02 19:52:08",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141828544,
    "title": "使用同步锁的代码示例3",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828544",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828544",
    "postTime": "2024-09-02 19:51:27",
    "diggCount": 7,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141828528,
    "title": "使用同步锁的代码示例5",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828528",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 386,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828528",
    "postTime": "2024-09-02 19:50:53",
    "diggCount": 13,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141828504,
    "title": "使用同步锁的代码示例11",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828504",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828504",
    "postTime": "2024-09-02 19:49:46",
    "diggCount": 3,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141828487,
    "title": "使用同步锁的代码示例13",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828487",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 138,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828487",
    "postTime": "2024-09-02 19:49:07",
    "diggCount": 8,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141828471,
    "title": "使用同步锁的代码示例9",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828471",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 252,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828471",
    "postTime": "2024-09-02 19:48:34",
    "diggCount": 9,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141828460,
    "title": "使用同步锁的代码示例8",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828460",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 119,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828460",
    "postTime": "2024-09-02 19:47:58",
    "diggCount": 7,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141828444,
    "title": "使用同步锁的代码示例15",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828444",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 141,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828444",
    "postTime": "2024-09-02 19:47:26",
    "diggCount": 1,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141828409,
    "title": "使用同步锁的代码示例10",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828409",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 222,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828409",
    "postTime": "2024-09-02 19:47:06",
    "diggCount": 2,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141828343,
    "title": "使用同步锁的代码示例7",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828343",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 383,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828343",
    "postTime": "2024-09-02 19:46:54",
    "diggCount": 13,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141828427,
    "title": "使用同步锁的代码示例6",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828427",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 396,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828427",
    "postTime": "2024-09-02 19:46:50",
    "diggCount": 14,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141828391,
    "title": "使用同步锁的代码示例12",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828391",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 147,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828391",
    "postTime": "2024-09-02 19:46:25",
    "diggCount": 7,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141828380,
    "title": "使用同步锁的代码示例14",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828380",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 364,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828380",
    "postTime": "2024-09-02 19:44:35",
    "diggCount": 7,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141828363,
    "title": "使用同步锁的代码示例2",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828363",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 292,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828363",
    "postTime": "2024-09-02 19:44:04",
    "diggCount": 8,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141828331,
    "title": "使用同步锁的代码示例1",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/141828331",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 380,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828331",
    "postTime": "2024-09-02 19:42:50",
    "diggCount": 14,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140899532,
    "title": "如何通过表态投票机制提高技术文章的质量与相关性",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899532",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 247,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899532",
    "postTime": "2024-08-04 00:33:01",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/750d2fbfe4e64092873bf94359b0ea77.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140899413,
    "title": "利用表态投票机制实现技术文章的真实读者反馈",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899413",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 325,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899413",
    "postTime": "2024-08-04 00:32:55",
    "diggCount": 4,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/26708d18bdcb49fe8ec9b186c5714c61.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140899429,
    "title": "优化技术内容：表态投票如何塑造更具影响力的文章",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899429",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 400,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899429",
    "postTime": "2024-08-04 00:32:27",
    "diggCount": 4,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fab9aeac0bb54601accf50cc036b7d1e.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140899437,
    "title": "通过表态投票获得精确读者反馈的技术路径",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899437",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 412,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899437",
    "postTime": "2024-08-04 00:32:00",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/07d2833290104f8fa53bf53b35e85565.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140899517,
    "title": "深入解析表态投票机制在技术写作中的应用潜力",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899517",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 327,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899517",
    "postTime": "2024-08-04 00:31:41",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/51cd3c27d6b241eaa6484772ad1d03c4.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140899447,
    "title": "技术文章新风向：表态投票带来的反馈革命",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899447",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 288,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899447",
    "postTime": "2024-08-04 00:31:28",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/64f1378cdada4e1199e2836b7de5c817.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140899509,
    "title": "表态投票的力量：如何通过反馈改进你的技术文章",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899509",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 299,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899509",
    "postTime": "2024-08-04 00:30:37",
    "diggCount": 4,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1266acb6c2f5483a8fa8e7148f9e45ab.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140899497,
    "title": "从数据到决策：表态投票如何改变技术文章的评估方式",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899497",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 289,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899497",
    "postTime": "2024-08-04 00:30:22",
    "diggCount": 4,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3ed02238b7f344058c8b507f1f0fb9d7.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140899503,
    "title": "提升技术文章质量的秘密武器：表态投票机制",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899503",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 380,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899503",
    "postTime": "2024-08-04 00:29:57",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/85d2fe4856cd4aeeaccab69537d447f1.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140899461,
    "title": "探讨表态投票：如何用数据驱动技术文章的改进",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899461",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 379,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899461",
    "postTime": "2024-08-04 00:29:19",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/bd0dd7b814de4c52a6c07c37e032b92d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140899489,
    "title": "技术写作中的创新：表态投票如何提升读者参与度",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899489",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 250,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899489",
    "postTime": "2024-08-04 00:28:23",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b07d318aa33a4d87963a4455ec1a6bfe.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140899485,
    "title": "从技术文章到数据驱动决策：表态投票的实践指南",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899485",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899485",
    "postTime": "2024-08-04 00:27:48",
    "diggCount": 5,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9f15a5200d974736a6c29441710f5673.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140899474,
    "title": "构建更具互动性的技术文章：表态投票的应用实例",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899474",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 269,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899474",
    "postTime": "2024-08-04 00:26:49",
    "diggCount": 4,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/580860c98e384a19b156d79701dfa4e7.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140899466,
    "title": "让技术文章更具吸引力：表态投票如何优化读者反馈",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899466",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899466",
    "postTime": "2024-08-04 00:25:40",
    "diggCount": 3,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2690b54b8a9145b3bdecb63a8565ef6e.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140899455,
    "title": "从数据到决策：表态投票如何改变技术文章的评估方式",
    "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140899455",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 293,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140899455",
    "postTime": "2024-08-04 00:24:26",
    "diggCount": 4,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01b6a75544c0487dac2991ad785ebea4.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140896279,
    "title": "高并发下的同步锁魔法：破解性能瓶颈的实战技巧",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896279",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 293,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896279",
    "postTime": "2024-08-03 20:21:41",
    "diggCount": 5,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0b6318fd52e648618f0d2ac0ec5651b1.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140896269,
    "title": "Java 同步锁性能优化指南：从负担到高速的转变",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896269",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 354,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896269",
    "postTime": "2024-08-03 20:21:09",
    "diggCount": 12,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/710669e8d698440dba4caa4fa93487e7.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140896256,
    "title": "打破性能瓶颈：如何在 Java 中巧妙使用同步锁？",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896256",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 322,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896256",
    "postTime": "2024-08-03 20:20:29",
    "diggCount": 1,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f41acb7551344833a327266d1504c201.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140896243,
    "title": "Java 同步锁性能的黑科技：揭秘提升效率的隐藏技巧",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896243",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 129,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896243",
    "postTime": "2024-08-03 20:20:03",
    "diggCount": 5,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4b8c4eef89c94a7d8a95d53407cb1132.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140896189,
    "title": "从锁到无锁：提升 Java 性能的现代方法",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896189",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 125,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896189",
    "postTime": "2024-08-03 20:15:53",
    "diggCount": 8,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140896017,
    "title": "Java同步锁性能分析",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896017",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 134,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896017",
    "postTime": "2024-08-03 20:15:33",
    "diggCount": 7,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c0d2ec1e3ef54f30ba014d31ea359d93.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 140896170,
    "title": "Java 同步锁性能优化案例：如何应对高并发挑战？",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896170",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 275,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896170",
    "postTime": "2024-08-03 20:15:06",
    "diggCount": 5,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/de7bbff9d54c4926a0786f9a2c8c77ba.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 140896154,
    "title": "揭秘 Java 同步锁的性能陷阱：避免这些常见的优化错误",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896154",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 279,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896154",
    "postTime": "2024-08-03 20:14:45",
    "diggCount": 12,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/edb0a80a04c74f25bd987d623a2ea6b3.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140896134,
    "title": "掌握 Java 同步锁：如何通过性能分析提升应用效率？",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896134",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 268,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896134",
    "postTime": "2024-08-03 20:14:01",
    "diggCount": 7,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9abf43c3e13a49fe9556ecb9e2908a98.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140896119,
    "title": "Java 同步锁 vs. 并发性能：深入分析锁的开销与优化",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896119",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 412,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896119",
    "postTime": "2024-08-03 20:13:34",
    "diggCount": 24,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/81ef7052c59c4192ab5049ec8c428c61.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 140896104,
    "title": "破解 Java 同步锁性能难题：专家分享的优化经验",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896104",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 263,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896104",
    "postTime": "2024-08-03 20:12:58",
    "diggCount": 8,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7f174700cfab41eb81245d2767b97a47.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140896092,
    "title": "Java 同步锁性能的最佳实践：从理论到实践的完整指南",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896092",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 264,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896092",
    "postTime": "2024-08-03 20:11:54",
    "diggCount": 7,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d5d6434fa5844e56bf193d6577afcf14.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140896078,
    "title": "锁的代价：如何在 Java 中提高并发性能？",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896078",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 204,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896078",
    "postTime": "2024-08-03 20:11:20",
    "diggCount": 4,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/97d67cb284944e6cbf80fba4671f17b2.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 140896068,
    "title": "解密 Java 同步锁：性能影响与优化技巧全解析",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896068",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 211,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896068",
    "postTime": "2024-08-03 20:10:46",
    "diggCount": 7,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5c5d2d0f70784ac7a0625844f33e8e97.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 140896055,
    "title": "Java 同步锁性能的深度剖析：如何避免瓶颈？",
    "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
    "url": "https://blog.csdn.net/2401_86609655/article/details/140896055",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 224,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140896055",
    "postTime": "2024-08-03 20:09:52",
    "diggCount": 5,
    "formatTime": "2024.08.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0d26d4dc60614500a09902d2b2c4ce6b.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142933724,
    "title": "看看消息队列设计精要5",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933724",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 763,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933724",
    "postTime": "2024-10-15 08:24:52",
    "diggCount": 22,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142933645,
    "title": "看看消息队列设计精要12",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933645",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 950,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933645",
    "postTime": "2024-10-15 08:24:39",
    "diggCount": 17,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142933686,
    "title": "看看消息队列设计精要1",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933686",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 614,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933686",
    "postTime": "2024-10-15 08:24:33",
    "diggCount": 19,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142933725,
    "title": "看看消息队列设计精要2",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933725",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 947,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933725",
    "postTime": "2024-10-15 08:24:29",
    "diggCount": 20,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142933711,
    "title": "看看消息队列设计精要3",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933711",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 593,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933711",
    "postTime": "2024-10-15 08:24:26",
    "diggCount": 23,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142933698,
    "title": "看看消息队列设计精要4",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933698",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 887,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933698",
    "postTime": "2024-10-15 08:24:23",
    "diggCount": 13,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142933697,
    "title": "看看消息队列设计精要6",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933697",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 707,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933697",
    "postTime": "2024-10-15 08:24:16",
    "diggCount": 14,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142933680,
    "title": "看看消息队列设计精要7",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933680",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 774,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933680",
    "postTime": "2024-10-15 08:24:12",
    "diggCount": 17,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142933669,
    "title": "看看消息队列设计精要8",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933669",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 791,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933669",
    "postTime": "2024-10-15 08:24:09",
    "diggCount": 12,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142933658,
    "title": "看看消息队列设计精要9",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933658",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 821,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933658",
    "postTime": "2024-10-15 08:24:06",
    "diggCount": 12,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142933657,
    "title": "看看消息队列设计精要10",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933657",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 678,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933657",
    "postTime": "2024-10-15 08:24:02",
    "diggCount": 17,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142933652,
    "title": "看看消息队列设计精要11",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933652",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1000,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933652",
    "postTime": "2024-10-15 08:23:59",
    "diggCount": 25,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142933621,
    "title": "看看消息队列设计精要15",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933621",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 554,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933621",
    "postTime": "2024-10-15 08:16:53",
    "diggCount": 16,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142933644,
    "title": "看看消息队列设计精要13",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933644",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 569,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933644",
    "postTime": "2024-10-15 08:16:47",
    "diggCount": 20,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142933636,
    "title": "看看消息队列设计精要14",
    "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142933636",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 925,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142933636",
    "postTime": "2024-10-15 08:16:42",
    "diggCount": 15,
    "formatTime": "2024.10.15",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142931230,
    "title": "zookeeper 都有哪些使用场景？思考1",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931230",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 298,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931230",
    "postTime": "2024-10-14 23:11:32",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142931271,
    "title": "zookeeper 都有哪些使用场景？思考2",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931271",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 213,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931271",
    "postTime": "2024-10-14 23:11:29",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142931288,
    "title": "zookeeper 都有哪些使用场景？思考3",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931288",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 218,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931288",
    "postTime": "2024-10-14 23:11:25",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142931251,
    "title": "zookeeper 都有哪些使用场景？思考4",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931251",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 240,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931251",
    "postTime": "2024-10-14 23:11:22",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142931319,
    "title": "zookeeper 都有哪些使用场景？思考5",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931319",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 254,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931319",
    "postTime": "2024-10-14 23:11:19",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142931339,
    "title": "zookeeper 都有哪些使用场景？思考6",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931339",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 266,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931339",
    "postTime": "2024-10-14 23:11:15",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142931252,
    "title": "zookeeper 都有哪些使用场景？思考7",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931252",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 265,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931252",
    "postTime": "2024-10-14 23:11:12",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142931364,
    "title": "zookeeper 都有哪些使用场景？思考8",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931364",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931364",
    "postTime": "2024-10-14 23:11:08",
    "diggCount": 5,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142931287,
    "title": "zookeeper 都有哪些使用场景？思考9",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931287",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 296,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931287",
    "postTime": "2024-10-14 23:07:04",
    "diggCount": 3,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142931298,
    "title": "zookeeper 都有哪些使用场景？思考10",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931298",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 267,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931298",
    "postTime": "2024-10-14 23:07:00",
    "diggCount": 3,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142931189,
    "title": "zookeeper 都有哪些使用场景？思考15",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931189",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 287,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931189",
    "postTime": "2024-10-14 23:03:30",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142931208,
    "title": "zookeeper 都有哪些使用场景？思考11",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931208",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 259,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931208",
    "postTime": "2024-10-14 23:03:26",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142931171,
    "title": "zookeeper 都有哪些使用场景？思考12",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931171",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931171",
    "postTime": "2024-10-14 23:03:23",
    "diggCount": 3,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142931155,
    "title": "zookeeper 都有哪些使用场景？思考13",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931155",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 202,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931155",
    "postTime": "2024-10-14 23:03:19",
    "diggCount": 4,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142931138,
    "title": "zookeeper 都有哪些使用场景？思考14",
    "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142931138",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 344,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142931138",
    "postTime": "2024-10-14 23:03:15",
    "diggCount": 3,
    "formatTime": "2024.10.14",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/cc9ad41c46a54532ebfa91888045d96d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142896388,
    "title": "FairSync extends Sync 线程抢锁分析7",
    "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896388",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 101,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896388",
    "postTime": "2024-10-13 12:08:46",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896298,
    "title": "FairSync extends Sync 线程抢锁分析1",
    "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896298",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 165,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896298",
    "postTime": "2024-10-13 12:08:41",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896408,
    "title": "FairSync extends Sync 线程抢锁分析2",
    "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896408",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 149,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896408",
    "postTime": "2024-10-13 12:08:38",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896396,
    "title": "FairSync extends Sync 线程抢锁分析3",
    "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896396",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 204,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896396",
    "postTime": "2024-10-13 12:08:35",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896318,
    "title": "FairSync extends Sync 线程抢锁分析4",
    "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896318",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 173,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896318",
    "postTime": "2024-10-13 12:08:32",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896348,
    "title": "FairSync extends Sync 线程抢锁分析5",
    "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896348",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 163,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896348",
    "postTime": "2024-10-13 12:08:29",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896380,
    "title": "FairSync extends Sync 线程抢锁分析6",
    "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896380",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 88,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896380",
    "postTime": "2024-10-13 12:08:26",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896361,
    "title": "FairSync extends Sync 线程抢锁分析8",
    "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896361",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 154,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896361",
    "postTime": "2024-10-13 12:08:18",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896337,
    "title": "FairSync extends Sync 线程抢锁分析9",
    "description": "【代码】FairSync extends Sync 线程抢锁分析9。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896337",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 187,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896337",
    "postTime": "2024-10-13 12:08:15",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896278,
    "title": "FairSync extends Sync 线程抢锁分析10",
    "description": "【代码】FairSync extends Sync 线程抢锁分析10。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896278",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 165,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896278",
    "postTime": "2024-10-13 12:08:12",
    "diggCount": 3,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896256,
    "title": "FairSync extends Sync 线程抢锁分析11",
    "description": "【代码】FairSync extends Sync 线程抢锁分析11。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896256",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 148,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896256",
    "postTime": "2024-10-13 12:08:09",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896268,
    "title": "FairSync extends Sync 线程抢锁分析12",
    "description": "【代码】FairSync extends Sync 线程抢锁分析12。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896268",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 115,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896268",
    "postTime": "2024-10-13 12:08:06",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896245,
    "title": "FairSync extends Sync 线程抢锁分析13",
    "description": "【代码】FairSync extends Sync 线程抢锁分析13。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896245",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 148,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896245",
    "postTime": "2024-10-13 12:08:03",
    "diggCount": 1,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896232,
    "title": "FairSync extends Sync 线程抢锁分析14",
    "description": "【代码】FairSync extends Sync 线程抢锁分析14。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896232",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 134,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896232",
    "postTime": "2024-10-13 12:08:00",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142896222,
    "title": "FairSync extends Sync 线程抢锁分析15",
    "description": "【代码】FairSync extends Sync 线程抢锁分析15。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142896222",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 184,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142896222",
    "postTime": "2024-10-13 12:07:56",
    "diggCount": 2,
    "formatTime": "2024.10.13",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 142865745,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析2",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865745",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 885,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865745",
    "postTime": "2024-10-11 23:43:46",
    "diggCount": 18,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142865675,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析1",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865675",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 777,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865675",
    "postTime": "2024-10-11 23:42:56",
    "diggCount": 17,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142865650,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析3",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865650",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 841,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865650",
    "postTime": "2024-10-11 23:42:49",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142865724,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析4",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865724",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 370,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865724",
    "postTime": "2024-10-11 23:42:46",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142865730,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析5",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865730",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 850,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865730",
    "postTime": "2024-10-11 23:42:42",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142865699,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析6",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865699",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 384,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865699",
    "postTime": "2024-10-11 23:41:11",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142865709,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析7",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865709",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 485,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865709",
    "postTime": "2024-10-11 23:41:07",
    "diggCount": 21,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142865681,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析8",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 739,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865681",
    "postTime": "2024-10-11 23:38:54",
    "diggCount": 25,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142865661,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析9",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865661",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 454,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865661",
    "postTime": "2024-10-11 23:36:42",
    "diggCount": 19,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142865641,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析10",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865641",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 625,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865641",
    "postTime": "2024-10-11 23:35:25",
    "diggCount": 10,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142865631,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865631",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 700,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865631",
    "postTime": "2024-10-11 23:35:22",
    "diggCount": 5,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142865625,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析12",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865625",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 550,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865625",
    "postTime": "2024-10-11 23:33:27",
    "diggCount": 11,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142865614,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析13",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865614",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 561,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865614",
    "postTime": "2024-10-11 23:33:22",
    "diggCount": 7,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142865599,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析14",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865599",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 674,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865599",
    "postTime": "2024-10-11 23:33:18",
    "diggCount": 13,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142865589,
    "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
    "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142865589",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 578,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142865589",
    "postTime": "2024-10-11 23:32:03",
    "diggCount": 18,
    "formatTime": "2024.10.11",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142700355,
    "title": "天猫高频编程考题：​K 个一组翻转链表 （困难）​",
    "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700355",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 260,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700355",
    "postTime": "2024-10-04 10:11:57",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700352,
    "title": "天猫高频编程考题：随机链表的复制（中等）",
    "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700352",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 532,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700352",
    "postTime": "2024-10-04 10:11:19",
    "diggCount": 9,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142700347,
    "title": "天猫高频编程考题：排序链表（中等）",
    "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700347",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 339,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700347",
    "postTime": "2024-10-04 10:10:46",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142700342,
    "title": "天猫高频编程考题：合并 K 个升序链表 （困难）",
    "description": "对于每个节点的插入和删除操作，优先队列的时间复杂度为 O(log k)，其中 k 是链表的数量。总的时间复杂度为 O(N log k)，其中 N 是所有节点的总数。要将多个有序链表合并成一个有序链表，可以使用优先队列（最小堆）来实现，这样能够有效地将多个链表中的最小节点逐步合并，最终形成一个有序的链表。：空间复杂度主要取决于优先队列的存储空间，最坏情况下为 O(k)。请你将所有链表合并到一个升序链表中，返回合并后的链表。给你一个链表数组，每个链表都已经按升序排列。将它们合并到一个有序链表中得到。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700342",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 383,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700342",
    "postTime": "2024-10-04 10:10:09",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/751dafd55ff34389bdf5fe2439f17feb.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142700335,
    "title": "天猫高频编程考题：LRU 缓存（中等）",
    "description": "/ 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.put(4, 4);// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}// 缓存是 {1=1, 2=2}要实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，可以使用。// 返回 -1 (未找到)lRUCache.get(1);// 返回 -1 (未找到)lRUCache.put(1, 1);// 缓存是 {1=1}lRUCache.get(1);",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700335",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 507,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700335",
    "postTime": "2024-10-04 10:09:38",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c37c6a5ba9734596a43ad012b2d6b2ef.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 142700324,
    "title": "天猫高频编程考题：二叉树的中序遍历（简单）",
    "description": "要实现二叉树的中序遍历，最常见的方式是使用递归。递归算法很简单，你可以通过迭代算法完成吗？迭代方法使用栈来替代递归。给定一个二叉树的根节点。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700324",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 291,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700324",
    "postTime": "2024-10-04 10:08:49",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f3ef3b4a0148408e818b215f1792b710.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142700315,
    "title": "天猫高频编程考题：二叉树的最大深度（简单）",
    "description": "是指从根节点到最远叶子节点的最长路径上的节点数。递归方法较为简洁直观。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700315",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 223,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700315",
    "postTime": "2024-10-04 10:08:15",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/caef40e28a5e46a09db40b2d1e1b1cab.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142700311,
    "title": "天猫高频编程考题：翻转二叉树（简单）",
    "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700311",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 272,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700311",
    "postTime": "2024-10-04 10:07:42",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700301,
    "title": "天猫高频编程考题：对称二叉树（简单）",
    "description": "要检查一个二叉树是否是轴对称的，我们可以使用递归或迭代的方法。这里提供了两种方法的解题思路和复杂度分析。：可以使用队列来模拟递归检查过程，通过层次遍历来比较每层的节点对称性。：我们需要检查左右子树是否对称。你可以运用递归和迭代两种方法解决这个问题吗？给你一个二叉树的根节点。， 检查它是否轴对称。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700301",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 867,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700301",
    "postTime": "2024-10-04 10:07:01",
    "diggCount": 24,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f1d3ad76cc91463f8ff63d44ab93ecfa.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142700293,
    "title": "天猫高频编程考题：二叉树的直径（简单）",
    "description": "要找到二叉树的直径，我们需要找到树中任意两个节点之间的最长路径。：直径是树中两个节点之间最长的路径长度。这个路径可能会经过树的根节点，也可能不会。3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。因此，整体的空间复杂度主要由递归栈的深度决定，对于最坏情况下是。：通过递归计算每个节点的左右子树的深度，返回节点的最大深度。这条路径可能经过也可能不经过根节点。是指树中任意两个节点之间最长路径的。给你一棵二叉树的根节点，返回该树的。由它们之间边数表示。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700293",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 217,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700293",
    "postTime": "2024-10-04 10:06:21",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/82d34823cc444d24b5582f303808b59d.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700286,
    "title": "天猫高频编程考题：二叉树的层序遍历（中等）",
    "description": "层序遍历（二叉树的宽度优先遍历）可以使用队列（FIFO）来实现。我们逐层遍历树中的节点，每次处理一层的所有节点，并将它们的子节点加入队列中。（即逐层地，从左到右访问所有节点）。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700286",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 248,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700286",
    "postTime": "2024-10-04 10:05:50",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4a728c2c3636420b9248f8fe0400e427.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700276,
    "title": "天猫高频编程考题：将有序数组转换为二叉搜索树（简单）",
    "description": "要将一个升序排列的整数数组转换为一棵平衡二叉搜索树（BST），我们可以利用递归方法构建树。这是因为一个平衡的BST的中序遍历应该是升序排列的，因此我们可以通过递归的方式选择中间的元素作为根节点，递归构建左右子树，从而保持平衡。：由于数组已经是升序排列的，选择中间元素作为根节点可以保证树的高度平衡。[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。排列，请你将其转换为一棵 平衡 二叉搜索树。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700276",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 261,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700276",
    "postTime": "2024-10-04 10:05:11",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f674c50e28b4432a9ebe786a773e0764.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142700248,
    "title": "天猫高频编程考题：验证二叉搜索树（中等）",
    "description": "根节点的值是 5 ，但是右子节点的值是 4。，判断其是否是一个有效的二叉搜索树。给你一个二叉树的根节点。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700248",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700248",
    "postTime": "2024-10-04 10:03:07",
    "diggCount": 4,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/33d363efcf4c482ab02d62a67441d97d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142700241,
    "title": "天猫高频编程考题：二叉搜索树中第 K 小的元素（中等）",
    "description": "小元素，我们可以利用 BST 的中序遍历特性。中序遍历 BST 会以升序方式访问所有节点，因此第。：中序遍历 BST 的结果是一个升序排列的节点值列表。可以使用递归或迭代的方式进行中序遍历。：在遍历过程中，维护一个计数器来记录已经遍历的节点数量，当计数器等于。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第。要查找二叉搜索树（BST）中的第。小的元素就是中序遍历结果中的第。小的元素（从 1 开始计数）。给定一个二叉搜索树的根节点。小的值，你将如何优化算法？时，返回当前节点的值。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700241",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 312,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700241",
    "postTime": "2024-10-04 10:02:28",
    "diggCount": 3,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7be7b92a469348fe9165d76356a1a0fc.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142700236,
    "title": "天猫高频编程考题：二叉树的右视图（中等）",
    "description": "要从二叉树的右侧查看并返回节点值，我们可以使用层序遍历（广度优先遍历）来实现。具体来说，我们需要从右侧依次访问每一层的节点，并从每一层的最右侧节点开始返回结果。，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142700236",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 350,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142700236",
    "postTime": "2024-10-04 10:01:56",
    "diggCount": 5,
    "formatTime": "2024.10.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b6e4941ea10b490a8db4b67f420a3305.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142697354,
    "title": "天猫高频编程考题：两两交换链表中的节点（中等）",
    "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697354",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 120,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697354",
    "postTime": "2024-10-03 22:43:06",
    "diggCount": 6,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697349,
    "title": "天猫高频编程考题：删除链表的倒数第 N 个结点（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697349",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 270,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697349",
    "postTime": "2024-10-03 22:42:35",
    "diggCount": 6,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142697342,
    "title": "天猫高频编程考题：两数相加（中等）",
    "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697342",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697342",
    "postTime": "2024-10-03 22:42:00",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142697336,
    "title": "天猫高频编程考题：合并两个有序链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697336",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 199,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697336",
    "postTime": "2024-10-03 22:41:25",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 142697329,
    "title": "天猫高频编程考题：环形链表 II（中等）",
    "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697329",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 317,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697329",
    "postTime": "2024-10-03 22:40:53",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697324,
    "title": "天猫高频编程考题：环形链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697324",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 365,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697324",
    "postTime": "2024-10-03 22:40:19",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697321,
    "title": "天猫高频编程考题：回文链表（简单）",
    "description": "使用快慢指针方法，快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针正好处于链表的中间节点。: 从中间节点开始，反转链表的后半部分。这一步可以用来比较链表的前半部分和反转后的后半部分。: 为了保持链表的原始结构，可以在比较完成后再次反转链表的后半部分，恢复链表的结构。: 比较链表的前半部分和反转后的后半部分。如果它们相同，那么链表是回文的。，请你判断该链表是否为回文链表。给你一个单链表的头节点。空间复杂度解决此题？",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697321",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 203,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697321",
    "postTime": "2024-10-03 22:39:45",
    "diggCount": 1,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f63478fdab294b91a59506c9b29d14e2.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697314,
    "title": "天猫高频编程考题：反转链表（简单）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。反转单链表是一道经典的链表操作题目。可以使用两种主要的方法来实现：迭代和递归。链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？，请你反转链表，并返回反转后的链表。1. 迭代方法复杂度。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697314",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 364,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697314",
    "postTime": "2024-10-03 22:39:09",
    "diggCount": 4,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/afe1c4c5232a4adc96120c847740d8ca.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697307,
    "title": "天猫高频编程考题：相交链表（简单）",
    "description": "请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。，函数返回结果后，链表必须。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697307",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 937,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697307",
    "postTime": "2024-10-03 22:38:33",
    "diggCount": 22,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4d255796e31c467c8c8ed717ffed4208.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142697304,
    "title": "天猫高频编程考题：搜索二维矩阵 II（中等）",
    "description": "为了高效地搜索一个具有特定性质的矩阵中的目标值，我们可以利用矩阵的排序特性来设计一个时间复杂度为 O(m+n)O(m + n)O(m+n) 的算法：从矩阵的右上角或左下角开始搜索，并根据当前元素与目标值的比较结果决定搜索的方向。：由于每列的元素是升序的，目标值在当前列的上方，因此我们可以向左移动；：由于每行的元素是升序的，目标值在当前行的下方，因此我们可以向下移动；超出矩阵的边界时，说明目标值不在矩阵中，返回。为 0（矩阵的行数 - 1），为 0（矩阵的列数 - 1）。：从矩阵的右上角开始。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697304",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 428,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697304",
    "postTime": "2024-10-03 22:38:02",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e03d369fd6a4413b0eb9bbd12b768e5.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142697301,
    "title": "天猫高频编程考题：旋转图像（中等）",
    "description": "原矩阵中的 matrix[col][n−row−1] 就被覆盖了！当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置 (row,col) 进行上述的原地交换操作呢？题目中要求我们尝试在不使用额外内存空间的情况下进行矩阵的旋转，也就是说，我们需要「原地旋转」这个矩阵。那么 matrix[col][n−row−1] 经过旋转操作之后会到哪个位置呢？我们再重复一次之前的操作，matrix[n−row−1][n−col−1] 经过旋转操作之后会到哪个位置呢？使用另一个矩阵来旋转图像。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697301",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 637,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697301",
    "postTime": "2024-10-03 22:37:26",
    "diggCount": 16,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/765d07ab7623497a906f84e55f85891f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142697294,
    "title": "天猫高频编程考题：螺旋矩阵（中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。，它们分别代表当前矩阵的上下左右边界。初始值分别为矩阵的四个边界。：每完成一个方向的遍历后，更新相应的边界值，缩小螺旋矩阵的范围。，返回矩阵中的所有元素。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697294",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697294",
    "postTime": "2024-10-03 22:36:50",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/50b3f2f7428c4848a8961f35bd370a38.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142697289,
    "title": "天猫高频编程考题：矩阵置零 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：根据步骤 1 中记录的标志，处理第一行和第一列。如果第一行或第一列需要被置为。：遍历矩阵中除了第一行和第一列之外的所有元素。这两部分特殊处理，因为它们将用作标记其他行和列的状态。：首先检查矩阵的第一行和第一列是否包含。，则将其所在行和列的所有元素都设为。，则将其所在的行和列的首位置为。的行和列中的所有元素设置为。：遍历矩阵，将那些被标记为。的矩阵，如果一个元素为。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697289",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 406,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697289",
    "postTime": "2024-10-03 22:36:12",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ac3b3db605a64fb98ec92f52ecdf4dee.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142697280,
    "title": "天猫高频编程考题：缺失的第一个正数 （困难）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。：首先，遍历数组，将所有小于等于0或大于数组长度。，因为这些元素不影响我们寻找缺失的最小正整数。，请你找出其中没有出现的最小的正整数。并且只使用常数级别额外空间的解决方案。范围 [1,2] 中的数字都在数组中。1 在数组中，但 2 没有。给你一个未排序的整数数组。最小的正数 1 没有出现。请你实现时间复杂度为。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697280",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 247,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697280",
    "postTime": "2024-10-03 22:35:37",
    "diggCount": 5,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0373ab03ed48433b8c4573d7a168f80d.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142697272,
    "title": "天猫高频编程考题：除自身以外数组的乘积 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要解决这个问题并且避免使用除法，我们可以利用前缀乘积和后缀乘积来计算每个位置的结果。这种方法能够在 O(n) 时间复杂度内完成计算，且空间复杂度为 O(1)，不考虑输出数组的额外空间。的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组。之中任意元素的全部前缀元素和后缀的乘积都在。之外其余各元素的乘积。时间复杂度内完成此题。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142697272",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 382,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142697272",
    "postTime": "2024-10-03 22:35:02",
    "diggCount": 3,
    "formatTime": "2024.10.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9fb478b2866f4c19987e20b18360dd35.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142686124,
    "title": "天猫高频编程考题：两数之和",
    "description": "我们只需遍历数组一次，对于数组中的每个元素，哈希表的查找和插入操作的时间复杂度都是 O(1)，因此总的时间复杂度为 O(n)。在最坏的情况下（没有两个元素的和为目标值），我们需要在哈希表中存储数组中所有的元素及其下标，因此空间复杂度为 O(n)。我们可以通过一次遍历数组的方式解决该问题。因为 nums[0] + nums[1] == 9 ，返回 [0, 1]。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。整数，并返回它们的数组下标。你可以按任意顺序返回答案。，请你在该数组中找出。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686124",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 315,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686124",
    "postTime": "2024-10-02 22:22:54",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1bf6fdf160fb40339768aa1907c4b7bc.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142686113,
    "title": "天猫高频编程考题：字母异位词分组 （中等）",
    "description": "要将字母异位词组合在一起，我们可以利用哈希表（HashMap）的特性。：O(n * k)。需要使用额外的空间来存储排序后的字符串，以及存储结果的哈希表。哈希表最多需要 O(n * k) 的空间，其中。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。是由重新排列源单词的所有字母得到的一个新单词。是字符串数组的长度，是字符串的平均长度。是字符串数组的长度，是字符串的平均长度。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686113",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 356,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686113",
    "postTime": "2024-10-02 22:22:00",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ccf00fbb52de411881fe74e12da43927.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142686107,
    "title": "天猫高频编程考题：最长连续序列 （中等）",
    "description": "要在未排序的整数数组中找出最长的连续序列，并且时间复杂度要求为 O(n)，可以采用哈希集（HashSet）来进行优化。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。需要一个哈希集来存储数组中的所有元素，最坏情况下需要 O(n) 的额外空间。每个数字最多只会被访问一次，因此时间复杂度为 O(n)，其中。在哈希集中插入和查找的操作时间复杂度都是 O(1)。，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686107",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 285,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686107",
    "postTime": "2024-10-02 22:21:28",
    "diggCount": 9,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f9af3e6ae55b44948a10ed0d6e33ffaa.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142686093,
    "title": "天猫高频编程考题：移动零 （简单）",
    "description": "数组中的每个元素最多被遍历两次（一次在第一次遍历时移动非零元素，另一次在填充零时），因此时间复杂度为 O(n)。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。到数组末尾，同时保持非零元素的相对顺序，我们可以使用双指针技术来实现。移动到数组的末尾，同时保持非零元素的相对顺序。，必须在不复制数组的情况下原地对数组进行操作。只使用了常数级别的额外空间，即指针。为了在不复制数组的情况下原地移动所有。，因此空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686093",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 123,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686093",
    "postTime": "2024-10-02 22:20:43",
    "diggCount": 7,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/39a6348e3e69440ea95121d98a99534d.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 142686088,
    "title": "天猫高频编程考题：盛最多水的容器 （中等）",
    "description": "图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。这个问题可以通过使用双指针的方式来解决。在双指针法中，每一步只移动一个指针，一共需要遍历整个数组一次，因此时间复杂度为 O(n)。只使用了固定的额外空间来存储指针和最大面积，因此空间复杂度为 O(1)。轴共同构成的容器可以容纳最多的水。找出其中的两条线，使得它们与。返回容器可以储存的最大水量。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686088",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 402,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686088",
    "postTime": "2024-10-02 22:20:04",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c1c7b0fa1ea54733b2cd0bab53b9db5a.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142686085,
    "title": "天猫高频编程考题： 三数之和 （中等）",
    "description": "不同的三元组是 [-1,0,1] 和 [-1,-1,2]。注意，输出的顺序和三元组的顺序并不重要。要在数组中找出所有和为 0 且不重复的三元组，可以采用排序+双指针的方法。唯一可能的三元组和为 0。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686085",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 333,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686085",
    "postTime": "2024-10-02 22:19:32",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1d2e4ed874cb4b1bb5b63d8c5ff6035f.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 142686076,
    "title": "天猫高频编程考题：接雨水 （困难）",
    "description": "上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。只使用了固定的额外空间来存储指针和变量，因此空间复杂度为 O(1)。为了计算在柱子之间能够接住多少雨水，可以使用双指针的方法。的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。指针相遇时，遍历结束，所有的雨水量已经计算完毕。位置的柱子可能会接住雨水，接住的水量取决于。，以便在接下来的计算中使用。用于记录接住的总雨水量。，则能接住雨水，并将。位置能接住的雨水量。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686076",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 393,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686076",
    "postTime": "2024-10-02 22:18:54",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/711602a09031494cb1e29bff2ddbce15.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142686068,
    "title": "天猫高频编程考题：无重复字符的最长子串 （中等）",
    "description": "为了解决这个问题，可以使用滑动窗口的技术。滑动窗口可以动态地维护一个子串，并且当发现子串中有重复字符时，可以调整窗口的起始位置，从而找到不含重复字符的最长子串。使用了一个哈希集来存储当前窗口内的字符，最坏情况下需要存储所有字符，因此空间复杂度与字符集大小。：每次更新窗口后，记录当前窗口的长度，并与已知的最大长度进行比较，保留较大的值。指针右移，缩小窗口，直到窗口内没有重复字符为止。因此，总的时间复杂度为 O(n)，其中。中时，说明出现了重复字符，这时需要将。，请你找出其中不含有重复字符的。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686068",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 264,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686068",
    "postTime": "2024-10-02 22:18:19",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9d5ae81c57de48068439a833cc501706.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142686064,
    "title": "天猫高频编程考题：找到字符串中所有字母异位词 （中等）",
    "description": "起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。滑动窗口每次移动都需要比较两个频率表，这一步是 O(1) 的操作，因此整个算法的时间复杂度为 O(n)。，但它们的大小是固定的（26个字母），所以空间复杂度为 O(1)。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686064",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 419,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686064",
    "postTime": "2024-10-02 22:17:33",
    "diggCount": 3,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/c05b24b136c143feb52607f20aac9658.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142686056,
    "title": "天猫高频编程考题：和为 K 的子数组 （中等）",
    "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。我们只遍历一次数组，每次操作的时间复杂度是 O(1)，因此总的时间复杂度是 O(n)。前缀和的基本思想是通过累积数组元素的和，可以快速计算出任意子数组的和。要解决这个问题，我们可以使用前缀和（Prefix Sum）以及哈希表来优化查找和为。个不同的前缀和，因此空间复杂度是 O(n)。在最坏的情况下，哈希表。子数组是数组中元素的连续非空序列。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686056",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 348,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686056",
    "postTime": "2024-10-02 22:16:54",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/730edeb27e51493aaec44e345030e2aa.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 142686053,
    "title": "天猫高频编程考题：滑动窗口最大值 （困难）",
    "description": "要解决这个问题，我们可以使用**双端队列（Deque）**来高效地找到滑动窗口内的最大值。双端队列允许我们在 O(1) 的时间复杂度下在队列的两端进行插入和删除操作。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的。每个元素最多被插入和删除一次，因此总的时间复杂度是 O(n)。个元素的索引，因此空间复杂度是 O(k)。滑动窗口每次只向右移动一位。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686053",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 283,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686053",
    "postTime": "2024-10-02 22:16:23",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fd7a0415d1b840e29be78da4fe908a2a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142686044,
    "title": "天猫高频编程考题：最小覆盖子串 （困难）",
    "description": "中每个字符的计数，并且滑动窗口可能需要 O(∣S∣) 的空间来存储窗口中的字符计数。指针以缩小窗口，尽量找到最小的符合条件的子串；在缩小窗口的过程中，不断更新最小子串的长度和起始位置。t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。问题的核心是要用滑动窗口的技巧来找到最小的满足条件的子串。：当遍历完成后，返回找到的最小子串，如果没有符合条件的子串，则返回空字符串。中的增减操作是 O(1) 的，因此总时间复杂度为 O(m + n)。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686044",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 345,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686044",
    "postTime": "2024-10-02 22:15:52",
    "diggCount": 4,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a6e6e7228d7143a69bb642ba8f24af45.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 142686035,
    "title": "天猫高频编程考题：最大子数组和 （中等）",
    "description": "每次分割数组都需要 O(n) 时间来计算跨越中间的子数组和，并且总共有 O(log n) 层递归。，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。这种方法的时间复杂度为 O(n log n)，空间复杂度为 O(log n)。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。：O(log n)。递归调用栈的深度为 O(log n)。连续子数组 [4,-1,2,1] 的和最大，为 6。来记录当前子数组的最大和，然后更新全局最大和。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686035",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686035",
    "postTime": "2024-10-02 22:15:19",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4232b687f9a64ee8a7ca0082b5b8537d.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142686027,
    "title": "天猫高频编程考题：合并区间 （中等）",
    "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686027",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 398,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686027",
    "postTime": "2024-10-02 22:14:42",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142686017,
    "title": "天猫高频编程考题：轮转数组 （中等）",
    "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
    "url": "https://blog.csdn.net/macbookpro11/article/details/142686017",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 415,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142686017",
    "postTime": "2024-10-02 22:13:54",
    "diggCount": 5,
    "formatTime": "2024.10.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 142071098,
    "title": "案例分析：并行计算让代码“飞”起来11",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142071098",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 773,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071098",
    "postTime": "2024-09-09 22:30:04",
    "diggCount": 21,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142071077,
    "title": "案例分析：并行计算让代码“飞”起来10",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142071077",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 643,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071077",
    "postTime": "2024-09-09 22:29:08",
    "diggCount": 16,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142071064,
    "title": "案例分析：并行计算让代码“飞”起来9",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142071064",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 930,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071064",
    "postTime": "2024-09-09 22:28:09",
    "diggCount": 27,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142071052,
    "title": "案例分析：并行计算让代码“飞”起来8",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142071052",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 563,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071052",
    "postTime": "2024-09-09 22:27:27",
    "diggCount": 14,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142070968,
    "title": "案例分析：并行计算让代码“飞”起来7",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142070968",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1009,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070968",
    "postTime": "2024-09-09 22:23:07",
    "diggCount": 16,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142070944,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142070944",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 627,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070944",
    "postTime": "2024-09-09 22:21:39",
    "diggCount": 18,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142070936,
    "title": "案例分析：并行计算让代码“飞”起来5",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142070936",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 743,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070936",
    "postTime": "2024-09-09 22:21:04",
    "diggCount": 27,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142070874,
    "title": "案例分析：并行计算让代码“飞”起来4",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142070874",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 787,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070874",
    "postTime": "2024-09-09 22:17:32",
    "diggCount": 9,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142070855,
    "title": "案例分析：并行计算让代码“飞”起来3",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142070855",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 904,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070855",
    "postTime": "2024-09-09 22:16:21",
    "diggCount": 19,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142070832,
    "title": "案例分析：并行计算让代码“飞”起来2",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142070832",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 604,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070832",
    "postTime": "2024-09-09 22:15:10",
    "diggCount": 10,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142070817,
    "title": "案例分析：并行计算让代码“飞”起来1",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/u010861107/article/details/142070817",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 632,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142070817",
    "postTime": "2024-09-09 22:14:31",
    "diggCount": 27,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142027957,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027957",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 887,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027957",
    "postTime": "2024-09-08 15:46:09",
    "diggCount": 22,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142027919,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027919",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 890,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027919",
    "postTime": "2024-09-08 15:44:42",
    "diggCount": 25,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142027935,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027935",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 948,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027935",
    "postTime": "2024-09-08 15:43:46",
    "diggCount": 14,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142027907,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027907",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 933,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027907",
    "postTime": "2024-09-08 15:43:36",
    "diggCount": 20,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142027898,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027898",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 767,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027898",
    "postTime": "2024-09-08 15:43:33",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142027825,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027825",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 668,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027825",
    "postTime": "2024-09-08 15:43:28",
    "diggCount": 10,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142027915,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027915",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 875,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027915",
    "postTime": "2024-09-08 15:42:28",
    "diggCount": 8,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142027846,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027846",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 735,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027846",
    "postTime": "2024-09-08 15:40:50",
    "diggCount": 29,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142027877,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027877",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 603,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027877",
    "postTime": "2024-09-08 15:40:07",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142027863,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027863",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 616,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027863",
    "postTime": "2024-09-08 15:39:36",
    "diggCount": 12,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142027836,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027836",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 996,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027836",
    "postTime": "2024-09-08 15:38:31",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142027804,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027804",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 772,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027804",
    "postTime": "2024-09-08 15:38:16",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142027781,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027781",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1007,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027781",
    "postTime": "2024-09-08 15:38:12",
    "diggCount": 23,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142027769,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027769",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 730,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027769",
    "postTime": "2024-09-08 15:38:09",
    "diggCount": 23,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142027774,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/u010861107/article/details/142027774",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 634,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142027774",
    "postTime": "2024-09-08 15:38:01",
    "diggCount": 19,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141965705,
    "title": "超越常规：斐波那契数列的极速计算技术15",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965705",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 643,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965705",
    "postTime": "2024-09-06 17:44:43",
    "diggCount": 20,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141965682,
    "title": "超越常规：斐波那契数列的极速计算技术14",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965682",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 633,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965682",
    "postTime": "2024-09-06 17:44:06",
    "diggCount": 19,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141965669,
    "title": "超越常规：斐波那契数列的极速计算技术13",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965669",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 709,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965669",
    "postTime": "2024-09-06 17:43:36",
    "diggCount": 5,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/b78200db214141e495f3ef8e45375a3a.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141965645,
    "title": "超越常规：斐波那契数列的极速计算技术12",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965645",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 460,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965645",
    "postTime": "2024-09-06 17:43:04",
    "diggCount": 12,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141965635,
    "title": "超越常规：斐波那契数列的极速计算技术11",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965635",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 766,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965635",
    "postTime": "2024-09-06 17:42:31",
    "diggCount": 12,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141965619,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965619",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 901,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965619",
    "postTime": "2024-09-06 17:41:48",
    "diggCount": 9,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141965589,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965589",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 349,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965589",
    "postTime": "2024-09-06 17:40:35",
    "diggCount": 3,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141965560,
    "title": "超越常规：斐波那契数列的极速计算技术8",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965560",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 774,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965560",
    "postTime": "2024-09-06 17:39:31",
    "diggCount": 20,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141965520,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965520",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 868,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965520",
    "postTime": "2024-09-06 17:38:16",
    "diggCount": 15,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141965474,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965474",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 566,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965474",
    "postTime": "2024-09-06 17:37:03",
    "diggCount": 24,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141965440,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965440",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 641,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965440",
    "postTime": "2024-09-06 17:35:43",
    "diggCount": 10,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141965398,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965398",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 793,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965398",
    "postTime": "2024-09-06 17:34:23",
    "diggCount": 9,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141965346,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965346",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 863,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965346",
    "postTime": "2024-09-06 17:33:02",
    "diggCount": 15,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141965326,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965326",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 856,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965326",
    "postTime": "2024-09-06 17:32:30",
    "diggCount": 22,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141965246,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/u010861107/article/details/141965246",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 272,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965246",
    "postTime": "2024-09-06 17:30:02",
    "diggCount": 3,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141932525,
    "title": "案例分析：大对象复用的目标和注意点15",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932525",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1024,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932525",
    "postTime": "2024-09-05 15:33:27",
    "diggCount": 29,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3a525ebbc5df47dba603f9bc63935a3c.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141932505,
    "title": "案例分析：大对象复用的目标和注意点14",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932505",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 780,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932505",
    "postTime": "2024-09-05 15:32:52",
    "diggCount": 20,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 141932488,
    "title": "案例分析：大对象复用的目标和注意点13",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932488",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 768,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932488",
    "postTime": "2024-09-05 15:32:17",
    "diggCount": 20,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141932468,
    "title": "案例分析：大对象复用的目标和注意点12",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932468",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1080,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932468",
    "postTime": "2024-09-05 15:31:41",
    "diggCount": 26,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141932446,
    "title": "案例分析：大对象复用的目标和注意点11",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932446",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 748,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932446",
    "postTime": "2024-09-05 15:31:04",
    "diggCount": 29,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141932432,
    "title": "案例分析：大对象复用的目标和注意点10",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932432",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1885,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932432",
    "postTime": "2024-09-05 15:30:31",
    "diggCount": 32,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 54
  },
  {
    "articleId": 141932416,
    "title": "案例分析：大对象复用的目标和注意点9",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932416",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 368,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932416",
    "postTime": "2024-09-05 15:30:01",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141932394,
    "title": "案例分析：大对象复用的目标和注意点8",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932394",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1059,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932394",
    "postTime": "2024-09-05 15:29:30",
    "diggCount": 28,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 141932373,
    "title": "案例分析：大对象复用的目标和注意点7",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932373",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1893,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932373",
    "postTime": "2024-09-05 15:28:54",
    "diggCount": 49,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 57
  },
  {
    "articleId": 141932349,
    "title": "案例分析：大对象复用的目标和注意点6",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932349",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 909,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932349",
    "postTime": "2024-09-05 15:28:21",
    "diggCount": 8,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 141932298,
    "title": "案例分析：大对象复用的目标和注意点5",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932298",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 862,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932298",
    "postTime": "2024-09-05 15:27:24",
    "diggCount": 21,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141932264,
    "title": "案例分析：大对象复用的目标和注意点4",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932264",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 639,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932264",
    "postTime": "2024-09-05 15:26:41",
    "diggCount": 8,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 141932240,
    "title": "案例分析：大对象复用的目标和注意点3",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932240",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 303,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932240",
    "postTime": "2024-09-05 15:26:10",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141932198,
    "title": "案例分析：大对象复用的目标和注意点2",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932198",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 325,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932198",
    "postTime": "2024-09-05 15:25:15",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141932175,
    "title": "案例分析：大对象复用的目标和注意点1",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/u010861107/article/details/141932175",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 389,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932175",
    "postTime": "2024-09-05 15:24:39",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141890021,
    "title": "Spring开发必备：全面掌握Environment的使用与优化44",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141890021",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 502,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890021",
    "postTime": "2024-09-04 12:17:01",
    "diggCount": 17,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141890016,
    "title": "Spring开发必备：全面掌握Environment的使用与优化36",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141890016",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 573,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890016",
    "postTime": "2024-09-04 12:16:26",
    "diggCount": 24,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141889923,
    "title": "Spring开发必备：全面掌握Environment的使用与优化38",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889923",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 533,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889923",
    "postTime": "2024-09-04 12:16:18",
    "diggCount": 15,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141889941,
    "title": "Spring开发必备：全面掌握Environment的使用与优化39",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889941",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 461,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889941",
    "postTime": "2024-09-04 12:16:15",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141889953,
    "title": "Spring开发必备：全面掌握Environment的使用与优化40",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889953",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 522,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889953",
    "postTime": "2024-09-04 12:16:11",
    "diggCount": 23,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141889968,
    "title": "Spring开发必备：全面掌握Environment的使用与优化41",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889968",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 492,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889968",
    "postTime": "2024-09-04 12:16:06",
    "diggCount": 21,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141889988,
    "title": "Spring开发必备：全面掌握Environment的使用与优化42",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889988",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 776,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889988",
    "postTime": "2024-09-04 12:16:01",
    "diggCount": 15,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141890008,
    "title": "Spring开发必备：全面掌握Environment的使用与优化43",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141890008",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 814,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141890008",
    "postTime": "2024-09-04 12:15:56",
    "diggCount": 18,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141889914,
    "title": "Spring开发必备：全面掌握Environment的使用与优化37",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889914",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 577,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889914",
    "postTime": "2024-09-04 12:09:34",
    "diggCount": 12,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141889852,
    "title": "Spring开发必备：全面掌握Environment的使用与优化45",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889852",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 797,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889852",
    "postTime": "2024-09-04 12:09:15",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141889885,
    "title": "Spring开发必备：全面掌握Environment的使用与优化35",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889885",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 529,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889885",
    "postTime": "2024-09-04 12:09:04",
    "diggCount": 11,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141889900,
    "title": "Spring开发必备：全面掌握Environment的使用与优化34",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889900",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 703,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889900",
    "postTime": "2024-09-04 12:08:57",
    "diggCount": 5,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141889870,
    "title": "Spring开发必备：全面掌握Environment的使用与优化33",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889870",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 828,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889870",
    "postTime": "2024-09-04 12:07:18",
    "diggCount": 21,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141889857,
    "title": "Spring开发必备：全面掌握Environment的使用与优化32",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889857",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 777,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889857",
    "postTime": "2024-09-04 12:06:10",
    "diggCount": 18,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141889841,
    "title": "Spring开发必备：全面掌握Environment的使用与优化31",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141889841",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 525,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889841",
    "postTime": "2024-09-04 12:06:02",
    "diggCount": 14,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141858909,
    "title": "Spring开发必备：全面掌握Environment的使用与优化30",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858909",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 724,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858909",
    "postTime": "2024-09-03 13:06:53",
    "diggCount": 28,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141858902,
    "title": "Spring开发必备：全面掌握Environment的使用与优化29",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858902",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 658,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858902",
    "postTime": "2024-09-03 13:06:17",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141858890,
    "title": "Spring开发必备：全面掌握Environment的使用与优化28",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858890",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 879,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858890",
    "postTime": "2024-09-03 13:05:45",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141858870,
    "title": "Spring开发必备：全面掌握Environment的使用与优化27",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858870",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 883,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858870",
    "postTime": "2024-09-03 13:05:14",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141858858,
    "title": "Spring开发必备：全面掌握Environment的使用与优化26",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858858",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 699,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858858",
    "postTime": "2024-09-03 13:04:43",
    "diggCount": 14,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141858849,
    "title": "Spring开发必备：全面掌握Environment的使用与优化25",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858849",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 567,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858849",
    "postTime": "2024-09-03 13:04:10",
    "diggCount": 15,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141858841,
    "title": "Spring开发必备：全面掌握Environment的使用与优化24",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858841",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 253,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858841",
    "postTime": "2024-09-03 13:03:39",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141858834,
    "title": "Spring开发必备：全面掌握Environment的使用与优化23",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858834",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 680,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858834",
    "postTime": "2024-09-03 13:03:03",
    "diggCount": 18,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141858828,
    "title": "Spring开发必备：全面掌握Environment的使用与优化22",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858828",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 399,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858828",
    "postTime": "2024-09-03 13:02:31",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141858801,
    "title": "Spring开发必备：全面掌握Environment的使用与优化21",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858801",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 686,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858801",
    "postTime": "2024-09-03 13:01:26",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141858796,
    "title": "Spring开发必备：全面掌握Environment的使用与优化20",
    "description": "一、理解Environment的设计整体理解之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接",
    "url": "https://blog.csdn.net/u010861107/article/details/141858796",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 389,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858796",
    "postTime": "2024-09-03 13:00:49",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141858777,
    "title": "Spring开发必备：全面掌握Environment的使用与优化19",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858777",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 756,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858777",
    "postTime": "2024-09-03 12:59:22",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141858757,
    "title": "Spring开发必备：全面掌握Environment的使用与优化18",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858757",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 712,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858757",
    "postTime": "2024-09-03 12:58:49",
    "diggCount": 13,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141858732,
    "title": "Spring开发必备：全面掌握Environment的使用与优化17",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858732",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 591,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858732",
    "postTime": "2024-09-03 12:57:13",
    "diggCount": 14,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141858725,
    "title": "Spring开发必备：全面掌握Environment的使用与优化16",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141858725",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 226,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858725",
    "postTime": "2024-09-03 12:56:37",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141828983,
    "title": "Spring开发必备：全面掌握Environment的使用与优化6",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828983",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 599,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828983",
    "postTime": "2024-09-02 20:09:40",
    "diggCount": 8,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141828965,
    "title": "Spring开发必备：全面掌握Environment的使用与优化9",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828965",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 799,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828965",
    "postTime": "2024-09-02 20:08:50",
    "diggCount": 22,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141828950,
    "title": "Spring开发必备：全面掌握Environment的使用与优化7",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828950",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 486,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828950",
    "postTime": "2024-09-02 20:08:19",
    "diggCount": 18,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141828937,
    "title": "Spring开发必备：全面掌握Environment的使用与优化4",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828937",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 567,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828937",
    "postTime": "2024-09-02 20:07:48",
    "diggCount": 11,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141828801,
    "title": "Spring开发必备：全面掌握Environment的使用与优化11",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828801",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 536,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828801",
    "postTime": "2024-09-02 20:02:34",
    "diggCount": 25,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141828779,
    "title": "Spring开发必备：全面掌握Environment的使用与优化8",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828779",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 514,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828779",
    "postTime": "2024-09-02 20:01:42",
    "diggCount": 18,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141828664,
    "title": "Spring开发必备：全面掌握Environment的使用与优化5",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828664",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 948,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828664",
    "postTime": "2024-09-02 20:01:24",
    "diggCount": 25,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141828766,
    "title": "Spring开发必备：全面掌握Environment的使用与优化10",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828766",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 455,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828766",
    "postTime": "2024-09-02 20:01:12",
    "diggCount": 16,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141828751,
    "title": "Spring开发必备：全面掌握Environment的使用与优化2",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828751",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 901,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828751",
    "postTime": "2024-09-02 20:00:39",
    "diggCount": 24,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141828739,
    "title": "Spring开发必备：全面掌握Environment的使用与优化12",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828739",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 522,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828739",
    "postTime": "2024-09-02 20:00:06",
    "diggCount": 14,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141828715,
    "title": "Spring开发必备：全面掌握Environment的使用与优化13",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828715",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 620,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828715",
    "postTime": "2024-09-02 19:59:51",
    "diggCount": 22,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141828726,
    "title": "Spring开发必备：全面掌握Environment的使用与优化3",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828726",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 604,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828726",
    "postTime": "2024-09-02 19:59:32",
    "diggCount": 20,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141828699,
    "title": "Spring开发必备：全面掌握Environment的使用与优化15",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828699",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 895,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828699",
    "postTime": "2024-09-02 19:58:29",
    "diggCount": 25,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141828681,
    "title": "Spring开发必备：全面掌握Environment的使用与优化14",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828681",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 447,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828681",
    "postTime": "2024-09-02 19:57:43",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141828627,
    "title": "Spring开发必备：全面掌握Environment的使用与优化1",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/141828627",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1949,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141828627",
    "postTime": "2024-09-02 19:55:43",
    "diggCount": 37,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140907068,
    "title": "Spring开发必备：全面掌握Environment的使用与优化",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140907068",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 678,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907068",
    "postTime": "2024-08-04 15:51:10",
    "diggCount": 8,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a24904a14a1a4e4ba87ed290d57bcea3.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 140906887,
    "title": "深入Spring Environment：配置与管理的核心解析",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140906887",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 749,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906887",
    "postTime": "2024-08-04 15:51:03",
    "diggCount": 18,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/ff50bc02bda9460f8724b581401b7086.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140907059,
    "title": "优化配置管理：Spring Environment的实战应用",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140907059",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 722,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907059",
    "postTime": "2024-08-04 15:50:36",
    "diggCount": 10,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/08e4021c33554b91b079b50af199f6da.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140906907,
    "title": "揭秘Spring Environment：从基础到高级应用",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140906907",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 835,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906907",
    "postTime": "2024-08-04 15:50:31",
    "diggCount": 6,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/02ca36c85d6a4ec09303c3a04590eb24.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140906932,
    "title": "Spring Environment详解：实现动态配置的最佳实践",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140906932",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 829,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906932",
    "postTime": "2024-08-04 15:50:08",
    "diggCount": 22,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4b3e8e0537d446e181e6b9502424d7fe.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140907046,
    "title": "从零开始掌握Spring Environment：配置管理的强大工具",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140907046",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 918,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907046",
    "postTime": "2024-08-04 15:49:45",
    "diggCount": 16,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/03b1609308244f37bab4212354055be4.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140906997,
    "title": "探索Spring Environment：提升配置管理效率的技巧",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140906997",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 741,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906997",
    "postTime": "2024-08-04 15:49:38",
    "diggCount": 20,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/086813268fe9472b9537f3e86acd2052.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 140906966,
    "title": "Spring应用的环境配置秘诀：掌握Environment的魔力",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140906966",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 703,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906966",
    "postTime": "2024-08-04 15:49:20",
    "diggCount": 23,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/cffeb10bf55f461eb625bfe0ae005304.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140907030,
    "title": "重读Spring Environment：解密动态配置背后的原理",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140907030",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 583,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907030",
    "postTime": "2024-08-04 15:49:01",
    "diggCount": 23,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5b26d8f99276438abfdeabf3b87fac7b.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140907020,
    "title": "从入门到精通：Spring Environment的深入探讨与实践",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140907020",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 716,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907020",
    "postTime": "2024-08-04 15:48:06",
    "diggCount": 14,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/8c5a213826ce4193b43482bb27f4aaea.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140906950,
    "title": "环境变量与配置管理：全面剖析Spring Environment",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140906950",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 920,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906950",
    "postTime": "2024-08-04 15:47:58",
    "diggCount": 19,
    "formatTime": "2024.08.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/4623e588ca14457f867b5aa618627168.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140907014,
    "title": "Spring Environment深度剖析：打造灵活配置的应用",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140907014",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 492,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907014",
    "postTime": "2024-08-04 15:47:31",
    "diggCount": 10,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/f56188ca41ba44978fe4016458a84853.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140907006,
    "title": "现代应用的配置利器：Spring Environment完全指南",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140907006",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 902,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907006",
    "postTime": "2024-08-04 15:47:01",
    "diggCount": 19,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/69651001f84648d1a8d45b8b1e0fb69d.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 140906989,
    "title": "Spring Environment的奥秘：提升配置管理的艺术",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140906989",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 867,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906989",
    "postTime": "2024-08-04 15:46:38",
    "diggCount": 13,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7e16509b9e2d45dabd7a9ad317cf97b8.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140906982,
    "title": "环境变量配置之道：Spring Environment详尽解析",
    "description": "之前我们在分析分析SpringBoot启动配置原理_springboot启动机制-CSDN博客的时候对应Environment已经有一定的了解了，本次对其聚焦进行更加深层次的理解和分析：Environment模块在 Spring 中主要负责管理应用程序的配置和环境（定义为一组 profile配置文件）相关的信息，每个 profile 对应一个特定的应用程序部署环境，比如开发、测试、生产等。在这些 profile 中，可以包含各种属性，比如数据库连接信息、服务器端口、日志级别等。而。",
    "url": "https://blog.csdn.net/u010861107/article/details/140906982",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 868,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140906982",
    "postTime": "2024-08-04 15:44:55",
    "diggCount": 22,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9b3ea817c02b4e5085615d3ecce00b98.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 140889325,
    "title": "JMH—基准测试工具",
    "description": "我们在访问的时候，就需要创建相应的栈帧，访问到需要的字段后，再弹出栈帧，恢复原程序的执行。但如果设置成 0，程序依然会运行，不过是这样是在用户的 JVM 进程上运行的，可以看下下面的提示，但不推荐这么做。一般来说，基准测试都是针对比较小的、执行速度相对较快的代码块，这些代码有很大的可能性被 JIT 编译、内联，所以在编码时保持方法的精简，是一个好的习惯。如果能够把这些对象的访问和操作，纳入目标方法的调用范围之内，就少了一次方法调用，速度就能得到提升，这就是方法内联的概念。结合图表数据，更加直观。",
    "url": "https://blog.csdn.net/u010861107/article/details/140889325",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1098,
    "commentCount": 54,
    "editUrl": "https://mp.csdn.net/console/editor/html/140889325",
    "postTime": "2024-08-03 13:21:45",
    "diggCount": 21,
    "formatTime": "2024.08.03",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/5bbc102f2243430991aedee1be20b4f3.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140889307,
    "title": "Thread、ThreadLocalMap、ThreadLocal结构关系",
    "description": "ThreadLocal主要作用就是实现线程间变量隔离，对于一个变量，每个线程维护一个自己的实例，防止多线程环境下的资源竞争，那ThreadLocal是如何实现这一特性的呢？ThreadLocal主要作用就是实现线程间变量隔离，对于一个变量，每个线程维护一个自己的实例，防止多线程环境下的资源竞争，那ThreadLocal是如何实现这一特性的呢？该map对应的每个元素Entry对象中：key是ThreadLocal对象的弱引用，value是该threadlocal变量在当前线程中的对应的变量实体；",
    "url": "https://blog.csdn.net/u010861107/article/details/140889307",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 564,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140889307",
    "postTime": "2024-08-03 13:20:24",
    "diggCount": 13,
    "formatTime": "2024.08.03",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140889297,
    "title": "请求模拟请求",
    "description": "/ 替换为实际的 JSON 输入。// 添加身份验证令牌（假设令牌为 YourAccessToken）// 设置请求方法为 POST。// API 接口的 URL。// 设置 Cookie。",
    "url": "https://blog.csdn.net/u010861107/article/details/140889297",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 476,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140889297",
    "postTime": "2024-08-03 13:19:21",
    "diggCount": 3,
    "formatTime": "2024.08.03",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 128734938,
    "title": "函数式接口",
    "description": "函数式接口 案例使用",
    "url": "https://blog.csdn.net/u010861107/article/details/128734938",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 83,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/128734938",
    "postTime": "2023-01-19 14:40:57",
    "diggCount": 0,
    "formatTime": "2023.01.19",
    "picList": [],
    "collectCount": 0
  },
  {
    "articleId": 79556869,
    "title": "Spring Boot",
    "description": "restful参考:http://www.itmayun.com/it/files/226631678709806/article/445316192926631/1.html",
    "url": "https://blog.csdn.net/u010861107/article/details/79556869",
    "type": 2,
    "top": false,
    "forcePlan": false,
    "viewCount": 70,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/79556869",
    "postTime": "2018-03-14 16:45:36",
    "diggCount": 1,
    "formatTime": "2018.03.14",
    "picList": [],
    "collectCount": 0
  },
  {
    "articleId": 142071444,
    "title": "案例分析：并行计算让代码“飞”起来12",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071444",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 985,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071444",
    "postTime": "2024-09-09 22:51:16",
    "diggCount": 27,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142071435,
    "title": "案例分析：并行计算让代码“飞”起来11",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071435",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1041,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071435",
    "postTime": "2024-09-09 22:50:20",
    "diggCount": 11,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142071418,
    "title": "案例分析：并行计算让代码“飞”起来10",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071418",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 983,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071418",
    "postTime": "2024-09-09 22:49:03",
    "diggCount": 31,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142071393,
    "title": "案例分析：并行计算让代码“飞”起来9",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071393",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 850,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071393",
    "postTime": "2024-09-09 22:47:52",
    "diggCount": 22,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142071370,
    "title": "案例分析：并行计算让代码“飞”起来8",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071370",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1070,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071370",
    "postTime": "2024-09-09 22:46:41",
    "diggCount": 21,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142071347,
    "title": "案例分析：并行计算让代码“飞”起来7",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071347",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 818,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071347",
    "postTime": "2024-09-09 22:45:30",
    "diggCount": 14,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142071332,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071332",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 648,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071332",
    "postTime": "2024-09-09 22:44:26",
    "diggCount": 30,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142071308,
    "title": "案例分析：并行计算让代码“飞”起来5",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071308",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 987,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071308",
    "postTime": "2024-09-09 22:43:03",
    "diggCount": 30,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142071276,
    "title": "案例分析：并行计算让代码“飞”起来4",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071276",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 710,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071276",
    "postTime": "2024-09-09 22:41:17",
    "diggCount": 22,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142071250,
    "title": "案例分析：并行计算让代码“飞”起来3",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071250",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 729,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071250",
    "postTime": "2024-09-09 22:39:59",
    "diggCount": 27,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142071236,
    "title": "案例分析：并行计算让代码“飞”起来2",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071236",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 2079,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071236",
    "postTime": "2024-09-09 22:38:22",
    "diggCount": 29,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 51
  },
  {
    "articleId": 142071218,
    "title": "案例分析：并行计算让代码“飞”起来1",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142071218",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 845,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071218",
    "postTime": "2024-09-09 22:37:49",
    "diggCount": 20,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142028396,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028396",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 833,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028396",
    "postTime": "2024-09-08 16:04:29",
    "diggCount": 18,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142028345,
    "title": "案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028345",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 907,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028345",
    "postTime": "2024-09-08 16:04:24",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142028368,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028368",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 535,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028368",
    "postTime": "2024-09-08 16:04:19",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142028378,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028378",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 2028,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028378",
    "postTime": "2024-09-08 16:03:36",
    "diggCount": 32,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 44
  },
  {
    "articleId": 142028360,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028360",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1002,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028360",
    "postTime": "2024-09-08 16:02:29",
    "diggCount": 27,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142028327,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028327",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 772,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028327",
    "postTime": "2024-09-08 16:02:06",
    "diggCount": 30,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142028299,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028299",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1026,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028299",
    "postTime": "2024-09-08 16:01:09",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142028270,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028270",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 710,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028270",
    "postTime": "2024-09-08 16:00:57",
    "diggCount": 13,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142028248,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028248",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1726,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028248",
    "postTime": "2024-09-08 16:00:53",
    "diggCount": 41,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 35
  },
  {
    "articleId": 142028223,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028223",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 752,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028223",
    "postTime": "2024-09-08 16:00:49",
    "diggCount": 26,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 142028199,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028199",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 959,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028199",
    "postTime": "2024-09-08 16:00:45",
    "diggCount": 41,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142028163,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028163",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 939,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028163",
    "postTime": "2024-09-08 16:00:41",
    "diggCount": 9,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142028313,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028313",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 940,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028313",
    "postTime": "2024-09-08 16:00:36",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142028290,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028290",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 819,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028290",
    "postTime": "2024-09-08 15:59:32",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142028258,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/142028258",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 827,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028258",
    "postTime": "2024-09-08 15:58:25",
    "diggCount": 21,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 141966052,
    "title": "超越常规：斐波那契数列的极速计算技术12",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141966052",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 616,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966052",
    "postTime": "2024-09-06 17:55:51",
    "diggCount": 24,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141966031,
    "title": "超越常规：斐波那契数列的极速计算技术11",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141966031",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 775,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966031",
    "postTime": "2024-09-06 17:55:16",
    "diggCount": 23,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141966013,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141966013",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 529,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966013",
    "postTime": "2024-09-06 17:54:36",
    "diggCount": 7,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141965993,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141965993",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 497,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965993",
    "postTime": "2024-09-06 17:54:02",
    "diggCount": 22,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141965979,
    "title": "超越常规：斐波那契数列的极速计算技术8",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141965979",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 749,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965979",
    "postTime": "2024-09-06 17:53:28",
    "diggCount": 25,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141965967,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141965967",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 566,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965967",
    "postTime": "2024-09-06 17:52:57",
    "diggCount": 19,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141965946,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141965946",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 414,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965946",
    "postTime": "2024-09-06 17:52:16",
    "diggCount": 14,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141965911,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141965911",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 734,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965911",
    "postTime": "2024-09-06 17:51:07",
    "diggCount": 21,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141965893,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141965893",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 433,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965893",
    "postTime": "2024-09-06 17:50:36",
    "diggCount": 22,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141965870,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141965870",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 707,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965870",
    "postTime": "2024-09-06 17:50:18",
    "diggCount": 13,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141965812,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141965812",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 662,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965812",
    "postTime": "2024-09-06 17:47:51",
    "diggCount": 11,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141965774,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141965774",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 590,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141965774",
    "postTime": "2024-09-06 17:46:51",
    "diggCount": 10,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141933065,
    "title": "案例分析：大对象复用的目标和注意点15",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141933065",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 299,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933065",
    "postTime": "2024-09-05 15:47:10",
    "diggCount": 4,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141933035,
    "title": "案例分析：大对象复用的目标和注意点14",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141933035",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 216,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933035",
    "postTime": "2024-09-05 15:46:37",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141933012,
    "title": "案例分析：大对象复用的目标和注意点13",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141933012",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 246,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933012",
    "postTime": "2024-09-05 15:46:01",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141932989,
    "title": "案例分析：大对象复用的目标和注意点12",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932989",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 646,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932989",
    "postTime": "2024-09-05 15:45:25",
    "diggCount": 25,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141932962,
    "title": "案例分析：大对象复用的目标和注意点11",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932962",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 359,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932962",
    "postTime": "2024-09-05 15:44:49",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141932941,
    "title": "案例分析：大对象复用的目标和注意点10",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932941",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 359,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932941",
    "postTime": "2024-09-05 15:44:11",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141932904,
    "title": "案例分析：大对象复用的目标和注意点9",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932904",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 508,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932904",
    "postTime": "2024-09-05 15:43:26",
    "diggCount": 11,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141932862,
    "title": "案例分析：大对象复用的目标和注意点8",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932862",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 282,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932862",
    "postTime": "2024-09-05 15:42:24",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141932842,
    "title": "案例分析：大对象复用的目标和注意点7",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932842",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 664,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932842",
    "postTime": "2024-09-05 15:41:52",
    "diggCount": 15,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141932823,
    "title": "案例分析：大对象复用的目标和注意点6",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932823",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 528,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932823",
    "postTime": "2024-09-05 15:41:17",
    "diggCount": 18,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141932772,
    "title": "案例分析：大对象复用的目标和注意点5",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932772",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 315,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932772",
    "postTime": "2024-09-05 15:39:54",
    "diggCount": 3,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141932753,
    "title": "案例分析：大对象复用的目标和注意点4",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932753",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1065,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932753",
    "postTime": "2024-09-05 15:39:22",
    "diggCount": 29,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141932725,
    "title": "案例分析：大对象复用的目标和注意点3",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932725",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 761,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932725",
    "postTime": "2024-09-05 15:38:42",
    "diggCount": 20,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141932706,
    "title": "案例分析：大对象复用的目标和注意点2",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932706",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 993,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932706",
    "postTime": "2024-09-05 15:38:11",
    "diggCount": 9,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 141932679,
    "title": "案例分析：大对象复用的目标和注意点1",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141932679",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 662,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141932679",
    "postTime": "2024-09-05 15:37:41",
    "diggCount": 28,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fcecaf0af7bc4a93978bf92acef14f65.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 141889718,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法27",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889718",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 617,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889718",
    "postTime": "2024-09-04 11:58:26",
    "diggCount": 18,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 141889671,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法25",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889671",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 705,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889671",
    "postTime": "2024-09-04 11:55:59",
    "diggCount": 24,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141889655,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法24",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889655",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 631,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889655",
    "postTime": "2024-09-04 11:55:26",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141889632,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法26",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889632",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 605,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889632",
    "postTime": "2024-09-04 11:55:20",
    "diggCount": 5,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141889615,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法23",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889615",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 894,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889615",
    "postTime": "2024-09-04 11:53:59",
    "diggCount": 23,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141889554,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法22",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889554",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 609,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889554",
    "postTime": "2024-09-04 11:53:33",
    "diggCount": 24,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141889600,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法21",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889600",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 822,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889600",
    "postTime": "2024-09-04 11:53:26",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141889578,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法20",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889578",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 664,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889578",
    "postTime": "2024-09-04 11:52:25",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141889536,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法18",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889536",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 744,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889536",
    "postTime": "2024-09-04 11:51:21",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141889452,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法19",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889452",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 628,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889452",
    "postTime": "2024-09-04 11:51:16",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141889499,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法28",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889499",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 652,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889499",
    "postTime": "2024-09-04 11:51:01",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141889469,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法29",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889469",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 852,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889469",
    "postTime": "2024-09-04 11:50:58",
    "diggCount": 20,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141889417,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法30",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889417",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 923,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889417",
    "postTime": "2024-09-04 11:50:53",
    "diggCount": 25,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141889519,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法17",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889519",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 816,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889519",
    "postTime": "2024-09-04 11:50:41",
    "diggCount": 11,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141889443,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法16",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141889443",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 450,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889443",
    "postTime": "2024-09-04 11:47:27",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141864085,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法15",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141864085",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864085",
    "postTime": "2024-09-03 15:55:12",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141864067,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法14",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141864067",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 342,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864067",
    "postTime": "2024-09-03 15:54:42",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141863882,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法13",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141863882",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 530,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141863882",
    "postTime": "2024-09-03 15:54:04",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141863836,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法12",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141863836",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 684,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141863836",
    "postTime": "2024-09-03 15:48:07",
    "diggCount": 22,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141863811,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法11",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141863811",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 427,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141863811",
    "postTime": "2024-09-03 15:47:34",
    "diggCount": 19,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141863739,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法10",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141863739",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 377,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141863739",
    "postTime": "2024-09-03 15:46:01",
    "diggCount": 9,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141863710,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法9",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141863710",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 351,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141863710",
    "postTime": "2024-09-03 15:45:29",
    "diggCount": 3,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141863686,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法8",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141863686",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 490,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141863686",
    "postTime": "2024-09-03 15:44:57",
    "diggCount": 19,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141863670,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法7",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141863670",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 579,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141863670",
    "postTime": "2024-09-03 15:44:19",
    "diggCount": 8,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 141860708,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法6",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141860708",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 588,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141860708",
    "postTime": "2024-09-03 14:23:44",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141860684,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法5",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141860684",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 639,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141860684",
    "postTime": "2024-09-03 14:23:11",
    "diggCount": 20,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141859012,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法4",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141859012",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 294,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141859012",
    "postTime": "2024-09-03 13:12:44",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141858998,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法3",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141858998",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 671,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858998",
    "postTime": "2024-09-03 13:12:12",
    "diggCount": 12,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141858984,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法2",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141858984",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 774,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858984",
    "postTime": "2024-09-03 13:10:49",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141858973,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法1",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141858973",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 319,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141858973",
    "postTime": "2024-09-03 13:10:12",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141829182,
    "title": "重排策略算法",
    "description": "版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/138051035。重排策略算法用于重新排序搜索结果或推荐列表，以提高用户满意度或达到特定的优化目标。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141829182",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 183,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141829182",
    "postTime": "2024-09-02 20:18:10",
    "diggCount": 2,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-home.csdnimg.cn/images/20230308042815.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141829170,
    "title": "过滤策略算法",
    "description": "通过合理设计和实施基于用户行为的过滤策略，可以有效地过滤掉用户不感兴趣或不希望看到的内容，提高用户的满意度和搜索系统的效率。用户隐私保护：在收集和使用用户行为数据时，需遵循相关的隐私保护政策和法律法规，保护用户的隐私权益。灵活性和个性化：考虑用户的个性化需求和偏好，为用户提供灵活的过滤选项，以提高用户体验和满意度。过滤效果评估：定期评估过滤策略的效果，了解用户满意度和系统性能，根据评估结果进行调整和优化。比如针对过滤用户拉黑的内容和不感兴趣的内容，可以采用基于用户行为的过滤策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141829170",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 413,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141829170",
    "postTime": "2024-09-02 20:17:35",
    "diggCount": 11,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-home.csdnimg.cn/images/20230308042818.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141829152,
    "title": "召回策略算法-粗排算法-精排算法",
    "description": "提高搜索结果的相关性： 通过选择与用户查询相关性最高的文档进行召回，召回策略算法能够提高搜索结果的相关性，使用户更容易找到所需信息。基于文档相关性： 使用基于文本相似度的算法（如 TF-IDF、BM25）计算文档与查询的相关性，选取相关性较高的文档作为候选结果。提高检索效率： 召回策略算法能够快速过滤出与用户查询相关的文档，减少了后续排序和排除不相关文档的计算量，从而提高了检索效率。支持个性化搜索： 基于用户行为和兴趣建模的召回策略算法能够针对不同用户提供个性化的搜索结果，满足用户的个性化检索需求。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141829152",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 235,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141829152",
    "postTime": "2024-09-02 20:17:01",
    "diggCount": 10,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2320877cfa0b41a384781ece0154fffd.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141829133,
    "title": "召回策略算法-粗排算法",
    "description": "提高搜索结果的相关性： 通过选择与用户查询相关性最高的文档进行召回，召回策略算法能够提高搜索结果的相关性，使用户更容易找到所需信息。基于文档相关性： 使用基于文本相似度的算法（如 TF-IDF、BM25）计算文档与查询的相关性，选取相关性较高的文档作为候选结果。提高检索效率： 召回策略算法能够快速过滤出与用户查询相关的文档，减少了后续排序和排除不相关文档的计算量，从而提高了检索效率。支持个性化搜索： 基于用户行为和兴趣建模的召回策略算法能够针对不同用户提供个性化的搜索结果，满足用户的个性化检索需求。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141829133",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 297,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141829133",
    "postTime": "2024-09-02 20:16:22",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2320877cfa0b41a384781ece0154fffd.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141829120,
    "title": "召回策略算法",
    "description": "提高搜索结果的相关性： 通过选择与用户查询相关性最高的文档进行召回，召回策略算法能够提高搜索结果的相关性，使用户更容易找到所需信息。提高检索效率： 召回策略算法能够快速过滤出与用户查询相关的文档，减少了后续排序和排除不相关文档的计算量，从而提高了检索效率。支持个性化搜索： 基于用户行为和兴趣建模的召回策略算法能够针对不同用户提供个性化的搜索结果，满足用户的个性化检索需求。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141829120",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 132,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141829120",
    "postTime": "2024-09-02 20:15:49",
    "diggCount": 2,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/2320877cfa0b41a384781ece0154fffd.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141829103,
    "title": "QP策略",
    "description": "QP策略用于解析用户的查询请求，并将其转换为内部表示形式，以便搜索引擎能够理解和处理。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141829103",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 161,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141829103",
    "postTime": "2024-09-02 20:15:19",
    "diggCount": 3,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/dce831b1af7a4793aa00e711cbc864b1.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141829091,
    "title": "工程架构在构建检索系统中决定了系统的可扩展性、高可用性和性能",
    "description": "水平扩展：采用分布式架构，将检索任务分布到多个节点上，实现水平扩展。批量索引更新：对于大规模数据集的索引更新，可以设计批量索引更新机制，定期或按需对索引进行批量更新，以减少对系统性能的影响。实时索引更新：对于需要实时更新索引的场景，设计实时索引更新机制，将新增、修改和删除的文档变更快速地反映到索引中。监控系统：设计监控系统，监控系统各个节点的运行状态、负载情况、索引更新速度等指标，及时发现问题并进行调整。缓存机制：对于频繁查询的结果，可以设计缓存机制，在内存或分布式缓存中缓存查询结果，以提高查询响应速度。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141829091",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 407,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141829091",
    "postTime": "2024-09-02 20:14:38",
    "diggCount": 12,
    "formatTime": "2024.09.02",
    "picList": [],
    "collectCount": 0
  },
  {
    "articleId": 141829068,
    "title": "检索专业工程架构要点",
    "description": "水平扩展：采用分布式架构，将检索任务分布到多个节点上，实现水平扩展。批量索引更新：对于大规模数据集的索引更新，可以设计批量索引更新机制，定期或按需对索引进行批量更新，以减少对系统性能的影响。实时索引更新：对于需要实时更新索引的场景，设计实时索引更新机制，将新增、修改和删除的文档变更快速地反映到索引中。监控系统：设计监控系统，监控系统各个节点的运行状态、负载情况、索引更新速度等指标，及时发现问题并进行调整。缓存机制：对于频繁查询的结果，可以设计缓存机制，在内存或分布式缓存中缓存查询结果，以提高查询响应速度。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141829068",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 103,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141829068",
    "postTime": "2024-09-02 20:13:57",
    "diggCount": 3,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/f016401898cc4c2e9d9c2c0b29a69d0b.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141829054,
    "title": "检索专业工程架构要求",
    "description": "水平扩展：采用分布式架构，将检索任务分布到多个节点上，实现水平扩展。批量索引更新：对于大规模数据集的索引更新，可以设计批量索引更新机制，定期或按需对索引进行批量更新，以减少对系统性能的影响。实时索引更新：对于需要实时更新索引的场景，设计实时索引更新机制，将新增、修改和删除的文档变更快速地反映到索引中。监控系统：设计监控系统，监控系统各个节点的运行状态、负载情况、索引更新速度等指标，及时发现问题并进行调整。缓存机制：对于频繁查询的结果，可以设计缓存机制，在内存或分布式缓存中缓存查询结果，以提高查询响应速度。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141829054",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 426,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141829054",
    "postTime": "2024-09-02 20:13:25",
    "diggCount": 12,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/f016401898cc4c2e9d9c2c0b29a69d0b.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141829037,
    "title": "检索专业工程架构",
    "description": "水平扩展：采用分布式架构，将检索任务分布到多个节点上，实现水平扩展。批量索引更新：对于大规模数据集的索引更新，可以设计批量索引更新机制，定期或按需对索引进行批量更新，以减少对系统性能的影响。实时索引更新：对于需要实时更新索引的场景，设计实时索引更新机制，将新增、修改和删除的文档变更快速地反映到索引中。监控系统：设计监控系统，监控系统各个节点的运行状态、负载情况、索引更新速度等指标，及时发现问题并进行调整。缓存机制：对于频繁查询的结果，可以设计缓存机制，在内存或分布式缓存中缓存查询结果，以提高查询响应速度。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/141829037",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 255,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141829037",
    "postTime": "2024-09-02 20:12:44",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/f016401898cc4c2e9d9c2c0b29a69d0b.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 140907596,
    "title": "全面解析专业知识检索的高级架构与算法策略",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907596",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 786,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907596",
    "postTime": "2024-08-04 16:20:13",
    "diggCount": 10,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/14c64669185b43de8fad5c96e7a5921b.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 140907283,
    "title": "从算法到架构：深度探讨专业知识检索技术",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907283",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 489,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907283",
    "postTime": "2024-08-04 16:19:48",
    "diggCount": 17,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/55529fbcec1f4bc5b07d96cafc61df79.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 140907582,
    "title": "创新检索技术：专业知识检索的高级算法与架构设计",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907582",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 774,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907582",
    "postTime": "2024-08-04 16:19:25",
    "diggCount": 13,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d84ada1935ed454ca76c76f71365b239.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140907378,
    "title": "专业知识检索的高级策略与工程实现",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907378",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 498,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907378",
    "postTime": "2024-08-04 16:19:21",
    "diggCount": 10,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/29c8f49d7b4341ef979e5c73cf942880.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 140907566,
    "title": "提升检索性能：专业知识检索的工程架构与算法解析",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907566",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 786,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907566",
    "postTime": "2024-08-04 16:18:49",
    "diggCount": 18,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/e63685b8e3d34f19bb0dfdfddf5ee0e8.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140907398,
    "title": "掌握检索技术：构建高效知识检索系统的架构与算法",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907398",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 691,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907398",
    "postTime": "2024-08-04 16:18:42",
    "diggCount": 22,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 140907549,
    "title": "从理论到实践：高级知识检索的架构与算法",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907549",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 903,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907549",
    "postTime": "2024-08-04 16:18:08",
    "diggCount": 7,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/0344d675529b4f93a42814d17575ea66.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 140907461,
    "title": "专业知识检索优化：高级技术与工程实践",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907461",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 585,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907461",
    "postTime": "2024-08-04 16:18:01",
    "diggCount": 9,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/5bc7a0c1e91d4b16ae221be5d1acdc45.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 140907480,
    "title": "知识检索的前沿技术：算法与架构的深度融合",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907480",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 873,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907480",
    "postTime": "2024-08-04 16:17:29",
    "diggCount": 14,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/fb1a7a38d7ed457cae8ded1a459f0553.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 140907517,
    "title": "打造高效检索系统：专业知识检索的技术与架构",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907517",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 585,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907517",
    "postTime": "2024-08-04 16:16:34",
    "diggCount": 22,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a577918b226e4e278e01f857ea4a80c6.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 140907500,
    "title": "高级知识检索：算法策略与架构设计的完美结合",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907500",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 742,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907500",
    "postTime": "2024-08-04 16:15:45",
    "diggCount": 24,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/527bd5f611be4103bfcc759e8e9beb5a.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 140907491,
    "title": "专业知识检索技术详解：从工程架构到算法策略",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907491",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 532,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907491",
    "postTime": "2024-08-04 16:15:14",
    "diggCount": 25,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62026caa698c4255a0d8b43341333a07.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 140907451,
    "title": "知识检索新境界：高级技术与工程架构的应用",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907451",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 517,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907451",
    "postTime": "2024-08-04 16:13:06",
    "diggCount": 13,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d1a1b5bca54964b40d30d42d17ebfe.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 140907437,
    "title": "专业知识检索技术的未来：高级算法与工程架构解析",
    "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
    "url": "https://blog.csdn.net/2301_76981999/article/details/140907437",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 837,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/140907437",
    "postTime": "2024-08-04 16:12:24",
    "diggCount": 18,
    "formatTime": "2024.08.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d1a1b5bca54964b40d30d42d17ebfe.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142623380,
    "title": "SpringBoot 服务性能优化15",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623380",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 731,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623380",
    "postTime": "2024-09-28 22:50:41",
    "diggCount": 18,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142623389,
    "title": "SpringBoot 服务性能优化12",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623389",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1033,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623389",
    "postTime": "2024-09-28 22:50:35",
    "diggCount": 29,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142623350,
    "title": "SpringBoot 服务性能优化14",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623350",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 981,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623350",
    "postTime": "2024-09-28 22:49:03",
    "diggCount": 14,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142623364,
    "title": "SpringBoot 服务性能优化13",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623364",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 951,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623364",
    "postTime": "2024-09-28 22:48:59",
    "diggCount": 16,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 142623343,
    "title": "SpringBoot 服务性能优化10",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623343",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 884,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623343",
    "postTime": "2024-09-28 22:47:10",
    "diggCount": 20,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 142623331,
    "title": "SpringBoot 服务性能优化11",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623331",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 792,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623331",
    "postTime": "2024-09-28 22:46:59",
    "diggCount": 9,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142623324,
    "title": "SpringBoot 服务性能优化9",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623324",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 890,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623324",
    "postTime": "2024-09-28 22:46:04",
    "diggCount": 27,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142623316,
    "title": "SpringBoot 服务性能优化8",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623316",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1030,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623316",
    "postTime": "2024-09-28 22:45:31",
    "diggCount": 23,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142623296,
    "title": "SpringBoot 服务性能优化7",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623296",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 971,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623296",
    "postTime": "2024-09-28 22:45:04",
    "diggCount": 27,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142623309,
    "title": "SpringBoot 服务性能优化6",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623309",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1108,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623309",
    "postTime": "2024-09-28 22:44:59",
    "diggCount": 28,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142623278,
    "title": "SpringBoot 服务性能优化5",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623278",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 609,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623278",
    "postTime": "2024-09-28 22:43:16",
    "diggCount": 15,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 142623253,
    "title": "SpringBoot 服务性能优化4",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623253",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 561,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623253",
    "postTime": "2024-09-28 22:43:11",
    "diggCount": 7,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 11
  },
  {
    "articleId": 142623264,
    "title": "SpringBoot 服务性能优化3",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623264",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 887,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623264",
    "postTime": "2024-09-28 22:43:07",
    "diggCount": 29,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142623236,
    "title": "SpringBoot 服务性能优化2",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623236",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 814,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623236",
    "postTime": "2024-09-28 22:41:58",
    "diggCount": 10,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/b7c158d858628eb0a223003d6371183c.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142623186,
    "title": "SpringBoot 服务性能优化1",
    "description": "如果你的项目并发量比较高，想要修改最大线程数、最大连接数等配置信息，可以通过自定义Web 容器的方式，代码如下所示。注意上面的代码，我们设置了它的协议为 org.apache.coyote.http11.Http11Nio2Protocol，意思就是开启了 Nio2。这个参数在 Tomcat 8.0之后才有，开启之后会增加一部分性能。对比如下（测试项目代码见）：默认。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142623186",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 595,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142623186",
    "postTime": "2024-09-28 22:41:54",
    "diggCount": 20,
    "formatTime": "2024.09.28",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/a1f64eeea81df515117b0f427fcd028d.png"
    ],
    "collectCount": 20
  },
  {
    "articleId": 142071706,
    "title": "案例分析：并行计算让代码“飞”起来12",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071706",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 875,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071706",
    "postTime": "2024-09-09 23:06:31",
    "diggCount": 10,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142071693,
    "title": "案例分析：并行计算让代码“飞”起来11",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071693",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1014,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071693",
    "postTime": "2024-09-09 23:05:48",
    "diggCount": 26,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142071677,
    "title": "案例分析：并行计算让代码“飞”起来10",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071677",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 776,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071677",
    "postTime": "2024-09-09 23:04:43",
    "diggCount": 7,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 142071651,
    "title": "案例分析：并行计算让代码“飞”起来9",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071651",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 913,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071651",
    "postTime": "2024-09-09 23:03:22",
    "diggCount": 13,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142071628,
    "title": "案例分析：并行计算让代码“飞”起来8",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071628",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 960,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071628",
    "postTime": "2024-09-09 23:02:08",
    "diggCount": 28,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142071596,
    "title": "案例分析：并行计算让代码“飞”起来7",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071596",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 945,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071596",
    "postTime": "2024-09-09 23:00:32",
    "diggCount": 8,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 142071573,
    "title": "案例分析：并行计算让代码“飞”起来6",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071573",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 651,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071573",
    "postTime": "2024-09-09 22:59:19",
    "diggCount": 12,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142071562,
    "title": "案例分析：并行计算让代码“飞”起来5",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071562",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 553,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071562",
    "postTime": "2024-09-09 22:58:32",
    "diggCount": 11,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 142071540,
    "title": "案例分析：并行计算让代码“飞”起来4",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071540",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 808,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071540",
    "postTime": "2024-09-09 22:57:25",
    "diggCount": 12,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 142071520,
    "title": "案例分析：并行计算让代码“飞”起来3",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071520",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 766,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071520",
    "postTime": "2024-09-09 22:56:15",
    "diggCount": 22,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 21
  },
  {
    "articleId": 142071497,
    "title": "案例分析：并行计算让代码“飞”起来2",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071497",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 595,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071497",
    "postTime": "2024-09-09 22:54:44",
    "diggCount": 12,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142071476,
    "title": "案例分析：并行计算让代码“飞”起来1",
    "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142071476",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 961,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142071476",
    "postTime": "2024-09-09 22:53:24",
    "diggCount": 24,
    "formatTime": "2024.09.09",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
    ],
    "collectCount": 27
  },
  {
    "articleId": 142028516,
    "title": "案例分析：如何用设计模式优化性能15",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028516",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 847,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028516",
    "postTime": "2024-09-08 16:23:37",
    "diggCount": 27,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142028537,
    "title": "案例分析：如何用设计模式优化性能14",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028537",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1004,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028537",
    "postTime": "2024-09-08 16:23:33",
    "diggCount": 29,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 142028559,
    "title": "案例分析：如何用设计模式优化性能13",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028559",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 608,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028559",
    "postTime": "2024-09-08 16:23:29",
    "diggCount": 17,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 142028597,
    "title": "案例分析：如何用设计模式优化性能12",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028597",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 578,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028597",
    "postTime": "2024-09-08 16:23:25",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 142028706,
    "title": "案例分析：如何用设计模式优化性能11",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028706",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 778,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028706",
    "postTime": "2024-09-08 16:23:21",
    "diggCount": 15,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142028579,
    "title": "案例分析：如何用设计模式优化性能10",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028579",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1197,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028579",
    "postTime": "2024-09-08 16:23:16",
    "diggCount": 31,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 142028614,
    "title": "【无标题】案例分析：如何用设计模式优化性能9",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028614",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 818,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028614",
    "postTime": "2024-09-08 16:23:12",
    "diggCount": 24,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142028765,
    "title": "案例分析：如何用设计模式优化性能8",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028765",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 991,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028765",
    "postTime": "2024-09-08 16:23:07",
    "diggCount": 32,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 28
  },
  {
    "articleId": 142028683,
    "title": "案例分析：如何用设计模式优化性能7",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028683",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1003,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028683",
    "postTime": "2024-09-08 16:23:01",
    "diggCount": 28,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 142028721,
    "title": "案例分析：如何用设计模式优化性能6",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028721",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 975,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028721",
    "postTime": "2024-09-08 16:22:13",
    "diggCount": 16,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142028661,
    "title": "案例分析：如何用设计模式优化性能5",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028661",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 774,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028661",
    "postTime": "2024-09-08 16:18:27",
    "diggCount": 27,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 142028648,
    "title": "案例分析：如何用设计模式优化性能4",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028648",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 648,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028648",
    "postTime": "2024-09-08 16:17:55",
    "diggCount": 23,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 26
  },
  {
    "articleId": 142028637,
    "title": "案例分析：如何用设计模式优化性能3",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028637",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 866,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028637",
    "postTime": "2024-09-08 16:17:09",
    "diggCount": 10,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 22
  },
  {
    "articleId": 142028610,
    "title": "案例分析：如何用设计模式优化性能2",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028610",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 938,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028610",
    "postTime": "2024-09-08 16:15:55",
    "diggCount": 24,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 142028567,
    "title": "案例分析：如何用设计模式优化性能1",
    "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/142028567",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 606,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/142028567",
    "postTime": "2024-09-08 16:13:51",
    "diggCount": 20,
    "formatTime": "2024.09.08",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141966426,
    "title": "超越常规：斐波那契数列的极速计算技术9",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966426",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 702,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966426",
    "postTime": "2024-09-06 18:12:03",
    "diggCount": 9,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141966441,
    "title": "超越常规：斐波那契数列的极速计算技术7",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966441",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 796,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966441",
    "postTime": "2024-09-06 18:11:48",
    "diggCount": 24,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141966299,
    "title": "超越常规：斐波那契数列的极速计算技术8",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966299",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 737,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966299",
    "postTime": "2024-09-06 18:11:25",
    "diggCount": 9,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141966391,
    "title": "超越常规：斐波那契数列的极速计算技术11",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966391",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 421,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966391",
    "postTime": "2024-09-06 18:11:20",
    "diggCount": 22,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 14
  },
  {
    "articleId": 141966346,
    "title": "超越常规：斐波那契数列的极速计算技术12",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966346",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 643,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966346",
    "postTime": "2024-09-06 18:11:16",
    "diggCount": 24,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 12
  },
  {
    "articleId": 141966376,
    "title": "超越常规：斐波那契数列的极速计算技术13",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966376",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 828,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966376",
    "postTime": "2024-09-06 18:11:12",
    "diggCount": 23,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141966313,
    "title": "超越常规：斐波那契数列的极速计算技术14",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966313",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 880,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966313",
    "postTime": "2024-09-06 18:11:07",
    "diggCount": 13,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141966410,
    "title": "超越常规：斐波那契数列的极速计算技术10",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966410",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 550,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966410",
    "postTime": "2024-09-06 18:11:00",
    "diggCount": 23,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141966271,
    "title": "超越常规：斐波那契数列的极速计算技术15",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966271",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 738,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966271",
    "postTime": "2024-09-06 18:06:37",
    "diggCount": 24,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141966326,
    "title": "超越常规：斐波那契数列的极速计算技术6",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966326",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 430,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966326",
    "postTime": "2024-09-06 18:06:23",
    "diggCount": 11,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141966288,
    "title": "超越常规：斐波那契数列的极速计算技术5",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966288",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 630,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966288",
    "postTime": "2024-09-06 18:04:30",
    "diggCount": 20,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141966243,
    "title": "超越常规：斐波那契数列的极速计算技术4",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966243",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 547,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966243",
    "postTime": "2024-09-06 18:02:20",
    "diggCount": 18,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141966163,
    "title": "超越常规：斐波那契数列的极速计算技术3",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966163",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 683,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966163",
    "postTime": "2024-09-06 17:59:48",
    "diggCount": 20,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141966147,
    "title": "超越常规：斐波那契数列的极速计算技术2",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966147",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 653,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966147",
    "postTime": "2024-09-06 17:59:17",
    "diggCount": 16,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141966118,
    "title": "超越常规：斐波那契数列的极速计算技术1",
    "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141966118",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 488,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141966118",
    "postTime": "2024-09-06 17:58:04",
    "diggCount": 12,
    "formatTime": "2024.09.06",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
    ],
    "collectCount": 9
  },
  {
    "articleId": 141933449,
    "title": "案例分析：大对象复用的目标和注意点5",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141933449",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 433,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933449",
    "postTime": "2024-09-05 15:57:26",
    "diggCount": 5,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141933429,
    "title": "案例分析：大对象复用的目标和注意点4",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141933429",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 918,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933429",
    "postTime": "2024-09-05 15:56:55",
    "diggCount": 18,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 19
  },
  {
    "articleId": 141933405,
    "title": "案例分析：大对象复用的目标和注意点3",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141933405",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1037,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933405",
    "postTime": "2024-09-05 15:56:18",
    "diggCount": 11,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 141933379,
    "title": "案例分析：大对象复用的目标和注意点2",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141933379",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 888,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933379",
    "postTime": "2024-09-05 15:55:46",
    "diggCount": 15,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 16
  },
  {
    "articleId": 141933353,
    "title": "案例分析：大对象复用的目标和注意点1",
    "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141933353",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 780,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141933353",
    "postTime": "2024-09-05 15:55:11",
    "diggCount": 18,
    "formatTime": "2024.09.05",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141888862,
    "title": "零拷贝---零拷贝---零拷贝15",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141888862",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 223,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888862",
    "postTime": "2024-09-04 11:41:27",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141888895,
    "title": "零拷贝---零拷贝---零拷贝14",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141888895",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 221,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888895",
    "postTime": "2024-09-04 11:41:09",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141888936,
    "title": "零拷贝---零拷贝---零拷贝13",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141888936",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 231,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888936",
    "postTime": "2024-09-04 11:40:51",
    "diggCount": 3,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141888973,
    "title": "零拷贝---零拷贝---零拷贝12",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141888973",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 259,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888973",
    "postTime": "2024-09-04 11:40:36",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 3
  },
  {
    "articleId": 141889036,
    "title": "零拷贝---零拷贝---零拷贝11",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141889036",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 145,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889036",
    "postTime": "2024-09-04 11:40:19",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141889005,
    "title": "零拷贝---零拷贝---零拷贝10",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141889005",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 421,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889005",
    "postTime": "2024-09-04 11:39:51",
    "diggCount": 5,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141889127,
    "title": "零拷贝---零拷贝---零拷贝9",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141889127",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 197,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889127",
    "postTime": "2024-09-04 11:39:28",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141889074,
    "title": "零拷贝---零拷贝---零拷贝8",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141889074",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 226,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889074",
    "postTime": "2024-09-04 11:39:09",
    "diggCount": 6,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141889179,
    "title": "零拷贝---零拷贝---零拷贝7",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141889179",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889179",
    "postTime": "2024-09-04 11:38:49",
    "diggCount": 13,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141889128,
    "title": "零拷贝---零拷贝---零拷贝6",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141889128",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 261,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889128",
    "postTime": "2024-09-04 11:38:26",
    "diggCount": 15,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141889153,
    "title": "零拷贝---零拷贝---零拷贝5",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141889153",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 127,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889153",
    "postTime": "2024-09-04 11:38:12",
    "diggCount": 3,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141889097,
    "title": "零拷贝---零拷贝---零拷贝4",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141889097",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 311,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889097",
    "postTime": "2024-09-04 11:37:53",
    "diggCount": 2,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141889054,
    "title": "零拷贝---零拷贝---零拷贝3",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141889054",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 243,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141889054",
    "postTime": "2024-09-04 11:33:42",
    "diggCount": 8,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141888991,
    "title": "零拷贝---零拷贝---零拷贝2",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141888991",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 307,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888991",
    "postTime": "2024-09-04 11:31:41",
    "diggCount": 9,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141888879,
    "title": "零拷贝---零拷贝---零拷贝1",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141888879",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 263,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141888879",
    "postTime": "2024-09-04 11:28:44",
    "diggCount": 10,
    "formatTime": "2024.09.04",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141864729,
    "title": "无处不在的缓存，高并发系统的法宝14",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864729",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 870,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864729",
    "postTime": "2024-09-03 16:13:00",
    "diggCount": 18,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141864682,
    "title": "无处不在的缓存，高并发系统的法宝13",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864682",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 624,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864682",
    "postTime": "2024-09-03 16:11:48",
    "diggCount": 25,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 141864661,
    "title": "无处不在的缓存，高并发系统的法宝12",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864661",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 413,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864661",
    "postTime": "2024-09-03 16:11:13",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141864637,
    "title": "无处不在的缓存，高并发系统的法宝11",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864637",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1063,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864637",
    "postTime": "2024-09-03 16:10:39",
    "diggCount": 28,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141864615,
    "title": "无处不在的缓存，高并发系统的法宝10",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864615",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 746,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864615",
    "postTime": "2024-09-03 16:10:03",
    "diggCount": 20,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 30
  },
  {
    "articleId": 141864584,
    "title": "无处不在的缓存，高并发系统的法宝9",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864584",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 840,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864584",
    "postTime": "2024-09-03 16:09:43",
    "diggCount": 30,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 25
  },
  {
    "articleId": 141864543,
    "title": "无处不在的缓存，高并发系统的法宝8",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864543",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 395,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864543",
    "postTime": "2024-09-03 16:08:22",
    "diggCount": 4,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141864518,
    "title": "无处不在的缓存，高并发系统的法宝7",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864518",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 757,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864518",
    "postTime": "2024-09-03 16:07:52",
    "diggCount": 13,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141864487,
    "title": "无处不在的缓存，高并发系统的法宝6",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864487",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 302,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864487",
    "postTime": "2024-09-03 16:07:03",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141864463,
    "title": "无处不在的缓存，高并发系统的法宝5",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864463",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 320,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864463",
    "postTime": "2024-09-03 16:06:31",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 6
  },
  {
    "articleId": 141864414,
    "title": "无处不在的缓存，高并发系统的法宝4",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864414",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 443,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864414",
    "postTime": "2024-09-03 16:05:05",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 10
  },
  {
    "articleId": 141864371,
    "title": "无处不在的缓存，高并发系统的法宝3",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864371",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 323,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864371",
    "postTime": "2024-09-03 16:04:00",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 7
  },
  {
    "articleId": 141864315,
    "title": "无处不在的缓存，高并发系统的法宝2",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864315",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 625,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864315",
    "postTime": "2024-09-03 16:02:18",
    "diggCount": 10,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 17
  },
  {
    "articleId": 141864291,
    "title": "无处不在的缓存，高并发系统的法宝1",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864291",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 456,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864291",
    "postTime": "2024-09-03 16:01:44",
    "diggCount": 5,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/01ae4d8ea2454ad0a6c593889fe554d8.png"
    ],
    "collectCount": 8
  },
  {
    "articleId": 141864267,
    "title": "无处不在的缓存，高并发系统的法宝",
    "description": "堆内缓存最常用的有 FIFO、LRU、LFU 这三种算法。FIFO这是一种先进先出的模式。如果缓存容量满了，将会移除最先加入的元素。这种缓存实现方式简单，但符合先进先出的队列模式场景的功能不多，应用场景较少。LRULRU 是最近最少使用的意思，当缓存容量达到上限，它会优先移除那些最久未被使用的数据，LRU是目前最常用的缓存算法，稍后我们会使用 Java 的 API 简单实现一个。LFULFU 是最近最不常用的意思。相对于 LRU 的时间维度，LFU 增加了访问次数的维度。如果缓存满的时候，将。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141864267",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 815,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141864267",
    "postTime": "2024-09-03 16:01:14",
    "diggCount": 22,
    "formatTime": "2024.09.03",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/7cf81c08f4f54a89a3908d828fdf6108.png"
    ],
    "collectCount": 29
  },
  {
    "articleId": 141817005,
    "title": "JMC —— 获取 Java 应用详细性能数据",
    "description": "对于我们常用的 HotSpot 来说，有更强大的工具，那就是 JMC。JMC 集成了一个非常好用的功能：JFR（Java Flight Recorder）。Flight Recorder 源自飞机的黑盒子，是用来录制信息然后事后分析的。JFR 功能是建在 JVM 内部的，不需要额外依赖，可以直接使用，它能够监测大量数据。比如，我们提到的锁竞争、延迟、阻塞等；甚至在 JVM 内部，比如 SafePoint、JIT 编译等，也能去分析。，下面介绍一下 JMC 的使用。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141817005",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 637,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141817005",
    "postTime": "2024-09-02 12:52:46",
    "diggCount": 7,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/d49dbb074d0143809c53d3ebcf63bd5f.png"
    ],
    "collectCount": 18
  },
  {
    "articleId": 141816990,
    "title": "jvisualvm —— 获取 JVM 性能数据",
    "description": "jvisualvm 原是随着 JDK 发布的一个工具，Java 9 之后开始单独发布。我们可以连接本地或者远程的服务器，监控大量的性能数据。对于性能优化来说，我们主要用到它的采样器。注意，由于抽样分析过程对程序运行性能有较大的影响，一般我们只在测试环境中使用此功能。对于一个 Java 应用来说，除了要关注它的 CPU 指标，垃圾回收方面也是不容忽视的性能点，我们主要关注以下三点。通过插件功能，jvisualvm 能获得更强大的扩展。要想监控远程的应用，还需要在被监控的 App 上加入 jmx 参数。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816990",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 195,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816990",
    "postTime": "2024-09-02 12:50:40",
    "diggCount": 9,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/378a64131f79478ba94612e6b3ed71c7.png"
    ],
    "collectCount": 5
  },
  {
    "articleId": 141816975,
    "title": "nmon —— 获取系统性能数据",
    "description": "通过下面的命令，表示每 5 秒采集一次数据，共采集 12 次，它会把这一段时间之内的数据记录下来。它的监控范围很广，包括 CPU、内存、网络、磁盘、文件系统、NFS、系统资源等信息。nmon 便是一个老牌的 Linux 性能监控工具，它不仅有漂亮的监控界面（如下图所示），还能产出细致的监控报表。我在对应用做性能评估时，通常会加上 nmon 的报告，这会让测试结果更加有说服力。按 N 键可加入网络；按 D 键可加入磁盘等。除了在上一课时中介绍的 top、free 等命令，还有一些将资源整合在一起的监控工具，",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816975",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 202,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816975",
    "postTime": "2024-09-02 12:49:51",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/d309274dca1140059ab3b21122868fd3.png"
    ],
    "collectCount": 4
  },
  {
    "articleId": 141816965,
    "title": "零拷贝---零拷贝---零拷贝",
    "description": "零拷贝有多种模式，我们用 sendfile 来举例。如下图所示，在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。是一种非常重要的性能优化手段，比如常见的 Kafka、Nginx 等，就使用了这种技术。我们来看一下有无零拷贝之间的区别。没有采取零拷贝手段的图。采取了零拷贝手段的图。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816965",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 375,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816965",
    "postTime": "2024-09-02 12:48:47",
    "diggCount": 16,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4ceaaf8e428e4201a0e8228912739ba7.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141816956,
    "title": "iostat--- iostat--- iostat",
    "description": "最能体现 I/O 繁忙程度的，就是 top 命令和 vmstat 命令中的 wa%。如果你的应用写了大量的日志，I/O wait 就可能非常高。很多同学反馈到，不知道有哪些便捷好用的查看磁盘 I/O 的工具，其实 iostat 就是。你可以通过 sysstat 包进行安装。上图中的指标详细介绍如下所示。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816956",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 262,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816956",
    "postTime": "2024-09-02 12:47:47",
    "diggCount": 3,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/68f41f32cc5548eeb61ad4f0b470e85f.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141816942,
    "title": "从操作系统层面来看一下内存的分布",
    "description": "要想了解内存对性能的影响，则需要从操作系统层面来看一下内存的分布。我们在平常写完代码后，比如写了一个 C++ 程序，去查看它的汇编，如果看到其中的内存地址，并不是实际的物理内存地址，那么应用程序所使用的，就是。学过计算机组成结构的同学应该都有了解。和，那么整个系统可用的内存就是两者之和。比如你的物理内存是 4GB，分配了 8GB 的 SWAP 分区，那么应用可用的总内存就是 12GB。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816942",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 963,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816942",
    "postTime": "2024-09-02 12:46:23",
    "diggCount": 33,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/1f20816e15694cf3b56262c1f87e2a14.png"
    ],
    "collectCount": 15
  },
  {
    "articleId": 141816914,
    "title": "vmstat —— CPU 繁忙程度",
    "description": "要看 CPU 的繁忙程度，可以通过 vmstat 命令，下图是 vmstat 命令的一些输出信息。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816914",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 152,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816914",
    "postTime": "2024-09-02 12:44:26",
    "diggCount": 1,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/7ca7738362d74dc0867c0c0ec139a490.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141816906,
    "title": "负载 —— CPU 任务排队情况",
    "description": "如果我们评估 CPU 任务执行的排队情况，那么需要通过负载（load）来完成。除了 top 命令，使用 uptime 命令也能够查看负载情况，load 的效果是一样的，分别显示了最近 1min、5min、15min 的数值。很多人看到 load 的值达到 1，就认为系统负载已经到了极限。这在单核的硬件上没有问题，但在多核硬件上，这种描述就不完全正确，它还与 CPU 的个数有关。所以，对于一个 load 到了 10，却是 16 核的机器，你的系统还远没有达到负载极限。针对这个问题，误解还是比较多的。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816906",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 338,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816906",
    "postTime": "2024-09-02 12:43:49",
    "diggCount": 4,
    "formatTime": "2024.09.02",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/3869a1bf1a42471495519d5a7fc6c252.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141816897,
    "title": "top 命令 —— CPU 性能",
    "description": "如下图，当进入 top 命令后，按 1 键即可看到每核 CPU 的运行指标和详细性能。一般地，我们比较关注空闲 CPU 的百分比，它可以从整体上体现 CPU 的利用情况。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816897",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 273,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816897",
    "postTime": "2024-09-02 12:43:18",
    "diggCount": 1,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4b5cec64800340beae6054c655a7cf1e.png"
    ],
    "collectCount": 1
  },
  {
    "articleId": 141816884,
    "title": "资源冲突优化",
    "description": "这些共享资源，有的是单机的，比如一个 HashMap；现实中的性能问题，和锁相关的问题是非常多的。大多数我们会想到数据库的行锁、表锁、Java 中的各种锁等。在更底层，比如 CPU 命令级别的锁、JVM 指令级别的锁、操作系统内部锁等，可以说无处不在。按照锁级别，锁可分为乐观锁和悲观锁，乐观锁在效率上肯定是更高一些；按照锁类型，锁又分为公平锁和非公平锁，在对任务的调度上，有一些细微的差别。对资源的争用，会造成严重的性能问题，所以会有一些针对无锁队列之类的研究，对性能的提升也是巨大的。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816884",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 124,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816884",
    "postTime": "2024-09-02 12:42:01",
    "diggCount": 1,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/572905547ec843e4b3f154a0f7e78dd8.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141816873,
    "title": "性能优化---结果集优化",
    "description": "除了书写要简单一些，一个重要的原因就是它的体积变小了，传输效率和解析效率变高了，像 Google 的 Protobuf，体积就更小了一些。虽然可读性降低，但在一些高并发场景下（如 RPC），能够显著提高效率，这是典型的对结果集的优化。数据从服务器传输到客户端，需要分发多份，这个数据量是急剧膨胀的，每减少一小部分存储，都会有比较大的传输性能和成本提升。像 Nginx，一般都会开启 GZIP 压缩，使得传输的内容保持紧凑。我们要吸取缓冲区的经验，尽量减少网络连接的交互，采用批量处理的方式，增加处理速度。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816873",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 298,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816873",
    "postTime": "2024-09-02 12:41:20",
    "diggCount": 6,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/4922a9a615b24d27b392559e630e92de.png"
    ],
    "collectCount": 0
  },
  {
    "articleId": 141816866,
    "title": "性能优化---计算优化",
    "description": "现在的 CPU 发展速度很快，绝大多数硬件，都是多核。要想加快某个任务的执行，最快最优的解决方式，就是让它并行执行。并行执行有以下三种模式。第一种模式是，采用负载均衡的方式，将流量或者大的计算拆分成多个部分，同时进行处理。比如，Hadoop 通过 MapReduce 的方式，把任务打散，多机同时进行计算。第二种模式是。比如 Nginx，采用 NIO 编程模型，Master 统一管理 Worker 进程，然后由 Worker 进程进行真正的请求代理，这也能很好地利用硬件的多个 CPU。第三种模式是。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816866",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 247,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816866",
    "postTime": "2024-09-02 12:40:37",
    "diggCount": 8,
    "formatTime": "2024.09.02",
    "picList": [],
    "collectCount": 3
  },
  {
    "articleId": 141816849,
    "title": "复用优化：缓冲（Buffer）+缓存（Cache）",
    "description": "由于这些对象的创建和销毁成本都比较大，我们在使用之后，也会将这部分对象暂时存储，下次用的时候，就不用再走一遍耗时的初始化操作了。上面的描述是编码逻辑上的优化，对于数据存取来说，有同样的复用情况。无论是在生活中还是编码中，重复的事情一直在发生，如果没有复用，工作和生活就会比较累。在写代码的时候，你会发现有很多重复的代码可以提取出来，做成公共的方法。这样，在下次用的时候，就不用再费劲写一遍了。注意这两个词的区别，它们的意义是完全不同的，很多同学很容易搞混，在这里简单地介绍一下。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816849",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 413,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816849",
    "postTime": "2024-09-02 12:39:35",
    "diggCount": 11,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/9028e39718fb492c9a1b24edd9fac82e.png"
    ],
    "collectCount": 2
  },
  {
    "articleId": 141816842,
    "title": "性能优化理论方法和注意点",
    "description": "很显然，过早优化会让这种难以维护的特性过早介入到你的项目中，等代码重构的时候，就会花更大的力气去解决它。其实，仅凭一个人的一次请求，就下了“慢”这个结论，是不合适的，而在我们进行性能评估的时候，也往往会陷入这样的误区。有些优化会引入新的性能问题，有时候这些新问题会引起更严重的性能下降，你需要评估这个连锁反应，确保这种优化确实需要，同时需要使用数字去衡量这个过程，而不是靠感觉猜想。比如，在数据库应用中，制约性能最严重的是落盘的 I/O 问题，也就是说，硬盘是这个场景下的短板，我们首要的任务就是补齐这个短板。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816842",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 997,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816842",
    "postTime": "2024-09-02 12:38:29",
    "diggCount": 9,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/16004df8df5f4a5c9e3ee992d2d81736.png"
    ],
    "collectCount": 13
  },
  {
    "articleId": 141816793,
    "title": "性能优化，有哪些衡量指标？",
    "description": "但是，如果信号灯频繁切换，反而会导致单位时间内通过的车辆减少，换一个角度，我们也可以认为这个十字路口的车辆吞吐量减少了。像我们平常开发中经常提到的，QPS 代表每秒查询的数量，TPS 代表每秒事务的数量，HPS 代表每秒的 HTTP 请求数量等，这都是常用的与吞吐量相关的量化指标。在压测的时候，接口直接超出服务能力，触发熔断了，但是压测并没有对接口响应的正确性做判断，造成了非常低级的错误。比如，某段时间若发生了长时间的 GC，那它的某个时间段之上的指标就会产生严重的抖动，但一些低百分位的数值却很少有变化。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/141816793",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1074,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/141816793",
    "postTime": "2024-09-02 12:37:11",
    "diggCount": 31,
    "formatTime": "2024.09.02",
    "picList": [
      "https://i-blog.csdnimg.cn/direct/aeef01402a784a83ac8529cd3a3973d0.png"
    ],
    "collectCount": 24
  },
  {
    "articleId": 140908020,
    "title": "JMH—基准测试工具",
    "description": "如果你通过 04 课时介绍的一系列外部工具，定位到了热点代码，要测试它的性能数据，评估改善情况，就可以交给 JMH。它的下面，我们介绍一下这个工具的使用。JMH 是一个 jar 包，它和单元测试框架 JUnit 非常像，可以通过注解进行一些基础配置。这部分配置有很多是可以通过 main 方法的 OptionsBuilder 进行设置的。上图是一个典型的 JMH 程序执行的内容。通过开启多个进程，多个线程，先执行预热，然后执行迭代，最后汇总所有的测试数据进行分析。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/140908020",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 945,
    "commentCount": 0,
    "editUrl": "https://mp.csdn.net/console/editor/html/140908020",
    "postTime": "2024-08-04 16:50:09",
    "diggCount": 15,
    "formatTime": "2024.08.04",
    "picList": [
      "https://img-blog.csdnimg.cn/img_convert/d49dbb074d0143809c53d3ebcf63bd5f.png"
    ],
    "collectCount": 23
  },
  {
    "articleId": 140889884,
    "title": "SOFATracer 介绍",
    "description": "基于并扩展其能力提供链路跟踪的解决方案。各个框架或者组件可以基于此实现，通过在各个组件中埋点的方式来提供链路跟踪的能力。",
    "url": "https://blog.csdn.net/2401_86608186/article/details/140889884",
    "type": 1,
    "top": false,
    "forcePlan": false,
    "viewCount": 1124,
    "commentCount": 1,
    "editUrl": "https://mp.csdn.net/console/editor/html/140889884",
    "postTime": "2024-08-03 14:06:46",
    "diggCount": 29,
    "formatTime": "2024.08.03",
    "picList": [],
    "collectCount": 10
  }
]
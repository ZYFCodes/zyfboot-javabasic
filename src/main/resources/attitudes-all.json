[
  {
    "articleCreaterNum": "13624089959",
    "articleInfos": [
      {
        "articleId": 141858973,
        "title": "掌握检索技术：构建高效知识检索系统的架构与算法1",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141858973",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1031,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141858973",
        "postTime": "2024-09-03 13:10:12",
        "diggCount": 4,
        "formatTime": "2024.09.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
        ],
        "collectCount": 9,
        "tags": [
          "人工智能",
          "机器学习"
        ]
      },
      {
        "articleId": 141829182,
        "title": "重排策略算法",
        "description": "版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/138051035。重排策略算法用于重新排序搜索结果或推荐列表，以提高用户满意度或达到特定的优化目标。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141829182",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 867,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141829182",
        "postTime": "2024-09-02 20:18:10",
        "diggCount": 2,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/ea03c98aeec0608bbfe79cddab99da12.png"
        ],
        "collectCount": 0,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141829170,
        "title": "过滤策略算法",
        "description": "通过合理设计和实施基于用户行为的过滤策略，可以有效地过滤掉用户不感兴趣或不希望看到的内容，提高用户的满意度和搜索系统的效率。用户隐私保护：在收集和使用用户行为数据时，需遵循相关的隐私保护政策和法律法规，保护用户的隐私权益。灵活性和个性化：考虑用户的个性化需求和偏好，为用户提供灵活的过滤选项，以提高用户体验和满意度。过滤效果评估：定期评估过滤策略的效果，了解用户满意度和系统性能，根据评估结果进行调整和优化。比如针对过滤用户拉黑的内容和不感兴趣的内容，可以采用基于用户行为的过滤策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141829170",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1137,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141829170",
        "postTime": "2024-09-02 20:17:35",
        "diggCount": 11,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/d80b9e2c5d020d421682660f33cdb29e.png"
        ],
        "collectCount": 8,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 141829133,
        "title": "召回策略算法-粗排算法",
        "description": "提高搜索结果的相关性： 通过选择与用户查询相关性最高的文档进行召回，召回策略算法能够提高搜索结果的相关性，使用户更容易找到所需信息。基于文档相关性： 使用基于文本相似度的算法（如 TF-IDF、BM25）计算文档与查询的相关性，选取相关性较高的文档作为候选结果。提高检索效率： 召回策略算法能够快速过滤出与用户查询相关的文档，减少了后续排序和排除不相关文档的计算量，从而提高了检索效率。支持个性化搜索： 基于用户行为和兴趣建模的召回策略算法能够针对不同用户提供个性化的搜索结果，满足用户的个性化检索需求。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141829133",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1006,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141829133",
        "postTime": "2024-09-02 20:16:22",
        "diggCount": 6,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/2320877cfa0b41a384781ece0154fffd.png"
        ],
        "collectCount": 1,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141829120,
        "title": "召回策略算法",
        "description": "提高搜索结果的相关性： 通过选择与用户查询相关性最高的文档进行召回，召回策略算法能够提高搜索结果的相关性，使用户更容易找到所需信息。提高检索效率： 召回策略算法能够快速过滤出与用户查询相关的文档，减少了后续排序和排除不相关文档的计算量，从而提高了检索效率。支持个性化搜索： 基于用户行为和兴趣建模的召回策略算法能够针对不同用户提供个性化的搜索结果，满足用户的个性化检索需求。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141829120",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 826,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141829120",
        "postTime": "2024-09-02 20:15:49",
        "diggCount": 2,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/2320877cfa0b41a384781ece0154fffd.png"
        ],
        "collectCount": 0,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141829103,
        "title": "QP策略",
        "description": "QP策略用于解析用户的查询请求，并将其转换为内部表示形式，以便搜索引擎能够理解和处理。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141829103",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 834,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141829103",
        "postTime": "2024-09-02 20:15:19",
        "diggCount": 3,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/dce831b1af7a4793aa00e711cbc864b1.png"
        ],
        "collectCount": 0,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 141829091,
        "title": "工程架构在构建检索系统中决定了系统的可扩展性、高可用性和性能",
        "description": "水平扩展：采用分布式架构，将检索任务分布到多个节点上，实现水平扩展。批量索引更新：对于大规模数据集的索引更新，可以设计批量索引更新机制，定期或按需对索引进行批量更新，以减少对系统性能的影响。实时索引更新：对于需要实时更新索引的场景，设计实时索引更新机制，将新增、修改和删除的文档变更快速地反映到索引中。监控系统：设计监控系统，监控系统各个节点的运行状态、负载情况、索引更新速度等指标，及时发现问题并进行调整。缓存机制：对于频繁查询的结果，可以设计缓存机制，在内存或分布式缓存中缓存查询结果，以提高查询响应速度。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141829091",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1095,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141829091",
        "postTime": "2024-09-02 20:14:38",
        "diggCount": 12,
        "formatTime": "2024.09.02",
        "picList": [],
        "collectCount": 0,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 141829068,
        "title": "检索专业工程架构要点",
        "description": "水平扩展：采用分布式架构，将检索任务分布到多个节点上，实现水平扩展。批量索引更新：对于大规模数据集的索引更新，可以设计批量索引更新机制，定期或按需对索引进行批量更新，以减少对系统性能的影响。实时索引更新：对于需要实时更新索引的场景，设计实时索引更新机制，将新增、修改和删除的文档变更快速地反映到索引中。监控系统：设计监控系统，监控系统各个节点的运行状态、负载情况、索引更新速度等指标，及时发现问题并进行调整。缓存机制：对于频繁查询的结果，可以设计缓存机制，在内存或分布式缓存中缓存查询结果，以提高查询响应速度。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141829068",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 767,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141829068",
        "postTime": "2024-09-02 20:13:57",
        "diggCount": 3,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/da7cf0188839092a89454a80bd8888cd.png"
        ],
        "collectCount": 0,
        "tags": [
          "架构",
          "分布式"
        ]
      },
      {
        "articleId": 141829054,
        "title": "检索专业工程架构要求",
        "description": "水平扩展：采用分布式架构，将检索任务分布到多个节点上，实现水平扩展。批量索引更新：对于大规模数据集的索引更新，可以设计批量索引更新机制，定期或按需对索引进行批量更新，以减少对系统性能的影响。实时索引更新：对于需要实时更新索引的场景，设计实时索引更新机制，将新增、修改和删除的文档变更快速地反映到索引中。监控系统：设计监控系统，监控系统各个节点的运行状态、负载情况、索引更新速度等指标，及时发现问题并进行调整。缓存机制：对于频繁查询的结果，可以设计缓存机制，在内存或分布式缓存中缓存查询结果，以提高查询响应速度。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141829054",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1107,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141829054",
        "postTime": "2024-09-02 20:13:25",
        "diggCount": 12,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/da7cf0188839092a89454a80bd8888cd.png"
        ],
        "collectCount": 0,
        "tags": [
          "架构",
          "分布式"
        ]
      },
      {
        "articleId": 141829037,
        "title": "检索专业工程架构",
        "description": "水平扩展：采用分布式架构，将检索任务分布到多个节点上，实现水平扩展。批量索引更新：对于大规模数据集的索引更新，可以设计批量索引更新机制，定期或按需对索引进行批量更新，以减少对系统性能的影响。实时索引更新：对于需要实时更新索引的场景，设计实时索引更新机制，将新增、修改和删除的文档变更快速地反映到索引中。监控系统：设计监控系统，监控系统各个节点的运行状态、负载情况、索引更新速度等指标，及时发现问题并进行调整。缓存机制：对于频繁查询的结果，可以设计缓存机制，在内存或分布式缓存中缓存查询结果，以提高查询响应速度。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141829037",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 937,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141829037",
        "postTime": "2024-09-02 20:12:44",
        "diggCount": 6,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/da7cf0188839092a89454a80bd8888cd.png"
        ],
        "collectCount": 0,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 140907596,
        "title": "全面解析专业知识检索的高级架构与算法策略",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/140907596",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1496,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140907596",
        "postTime": "2024-08-04 16:20:13",
        "diggCount": 10,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/14c64669185b43de8fad5c96e7a5921b.png"
        ],
        "collectCount": 17,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 140907283,
        "title": "从算法到架构：深度探讨专业知识检索技术",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/140907283",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1175,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140907283",
        "postTime": "2024-08-04 16:19:48",
        "diggCount": 17,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/55529fbcec1f4bc5b07d96cafc61df79.png"
        ],
        "collectCount": 10,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 140907582,
        "title": "创新检索技术：专业知识检索的高级算法与架构设计",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/140907582",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1514,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140907582",
        "postTime": "2024-08-04 16:19:25",
        "diggCount": 13,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/d84ada1935ed454ca76c76f71365b239.png"
        ],
        "collectCount": 8,
        "tags": [
          "spring"
        ]
      },
      {
        "articleId": 140907378,
        "title": "专业知识检索的高级策略与工程实现",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/140907378",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1189,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140907378",
        "postTime": "2024-08-04 16:19:21",
        "diggCount": 10,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/29c8f49d7b4341ef979e5c73cf942880.png"
        ],
        "collectCount": 6,
        "tags": [
          "java",
          "python"
        ]
      },
      {
        "articleId": 140907566,
        "title": "提升检索性能：专业知识检索的工程架构与算法解析",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/140907566",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1496,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140907566",
        "postTime": "2024-08-04 16:18:49",
        "diggCount": 18,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/e63685b8e3d34f19bb0dfdfddf5ee0e8.png"
        ],
        "collectCount": 13,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 140907398,
        "title": "掌握检索技术：构建高效知识检索系统的架构与算法",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/140907398",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1454,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140907398",
        "postTime": "2024-08-04 16:18:42",
        "diggCount": 22,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
        ],
        "collectCount": 8,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 140907549,
        "title": "从理论到实践：高级知识检索的架构与算法",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/140907549",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1637,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140907549",
        "postTime": "2024-08-04 16:18:08",
        "diggCount": 7,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/0344d675529b4f93a42814d17575ea66.png"
        ],
        "collectCount": 9,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 140907461,
        "title": "专业知识检索优化：高级技术与工程实践",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/140907461",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1281,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140907461",
        "postTime": "2024-08-04 16:18:01",
        "diggCount": 9,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5bc7a0c1e91d4b16ae221be5d1acdc45.png"
        ],
        "collectCount": 19,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 140907480,
        "title": "知识检索的前沿技术：算法与架构的深度融合",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/140907480",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1613,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140907480",
        "postTime": "2024-08-04 16:17:29",
        "diggCount": 14,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/fb1a7a38d7ed457cae8ded1a459f0553.png"
        ],
        "collectCount": 14,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 140907517,
        "title": "打造高效检索系统：专业知识检索的技术与架构",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/140907517",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1383,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140907517",
        "postTime": "2024-08-04 16:16:34",
        "diggCount": 22,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a577918b226e4e278e01f857ea4a80c6.png"
        ],
        "collectCount": 16,
        "tags": [
          "架构"
        ]
      },
      {
        "articleId": 141932989,
        "title": "案例分析：大对象复用的目标和注意点12",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932989",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1324,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932989",
        "postTime": "2024-09-05 15:45:25",
        "diggCount": 25,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 17,
        "tags": [
          "jetty"
        ]
      },
      {
        "articleId": 141932962,
        "title": "案例分析：大对象复用的目标和注意点11",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932962",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1038,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932962",
        "postTime": "2024-09-05 15:44:49",
        "diggCount": 3,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 9,
        "tags": [
          "spring boot"
        ]
      },
      {
        "articleId": 141932941,
        "title": "案例分析：大对象复用的目标和注意点10",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932941",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1036,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932941",
        "postTime": "2024-09-05 15:44:11",
        "diggCount": 5,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 9,
        "tags": [
          "jvm"
        ]
      },
      {
        "articleId": 141932904,
        "title": "案例分析：大对象复用的目标和注意点9",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932904",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1189,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932904",
        "postTime": "2024-09-05 15:43:26",
        "diggCount": 11,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 7,
        "tags": [
          "spring cloud"
        ]
      },
      {
        "articleId": 141932862,
        "title": "案例分析：大对象复用的目标和注意点8",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932862",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 980,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932862",
        "postTime": "2024-09-05 15:42:24",
        "diggCount": 3,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 8,
        "tags": [
          "java-ee"
        ]
      },
      {
        "articleId": 141932842,
        "title": "案例分析：大对象复用的目标和注意点7",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932842",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1338,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932842",
        "postTime": "2024-09-05 15:41:52",
        "diggCount": 15,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 8,
        "tags": [
          "intellij-idea"
        ]
      },
      {
        "articleId": 141932823,
        "title": "案例分析：大对象复用的目标和注意点6",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932823",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1198,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932823",
        "postTime": "2024-09-05 15:41:17",
        "diggCount": 18,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 11,
        "tags": [
          "kafka"
        ]
      },
      {
        "articleId": 141932772,
        "title": "案例分析：大对象复用的目标和注意点5",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932772",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 998,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932772",
        "postTime": "2024-09-05 15:39:54",
        "diggCount": 3,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 6,
        "tags": [
          "struts"
        ]
      },
      {
        "articleId": 141932753,
        "title": "案例分析：大对象复用的目标和注意点4",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932753",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1796,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932753",
        "postTime": "2024-09-05 15:39:22",
        "diggCount": 29,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 16,
        "tags": [
          "maven"
        ]
      },
      {
        "articleId": 141932725,
        "title": "案例分析：大对象复用的目标和注意点3",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932725",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1442,
        "commentCount": 3,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932725",
        "postTime": "2024-09-05 15:38:42",
        "diggCount": 20,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 13,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141932706,
        "title": "案例分析：大对象复用的目标和注意点2",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932706",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1680,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932706",
        "postTime": "2024-09-05 15:38:11",
        "diggCount": 9,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59a7f35500164e1a98cb534503d03b44.png"
        ],
        "collectCount": 24,
        "tags": [
          "spring"
        ]
      },
      {
        "articleId": 141932679,
        "title": "案例分析：大对象复用的目标和注意点1",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141932679",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1343,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141932679",
        "postTime": "2024-09-05 15:37:41",
        "diggCount": 28,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/fcecaf0af7bc4a93978bf92acef14f65.png"
        ],
        "collectCount": 22,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 141889718,
        "title": "掌握检索技术：构建高效知识检索系统的架构与算法27",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141889718",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1468,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141889718",
        "postTime": "2024-09-04 11:58:26",
        "diggCount": 18,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
        ],
        "collectCount": 20,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141889671,
        "title": "掌握检索技术：构建高效知识检索系统的架构与算法25",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141889671",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1425,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141889671",
        "postTime": "2024-09-04 11:55:59",
        "diggCount": 24,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
        ],
        "collectCount": 14,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141889655,
        "title": "掌握检索技术：构建高效知识检索系统的架构与算法24",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141889655",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1317,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141889655",
        "postTime": "2024-09-04 11:55:26",
        "diggCount": 6,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
        ],
        "collectCount": 12,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141889632,
        "title": "掌握检索技术：构建高效知识检索系统的架构与算法26",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141889632",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1284,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141889632",
        "postTime": "2024-09-04 11:55:20",
        "diggCount": 5,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
        ],
        "collectCount": 15,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141889615,
        "title": "掌握检索技术：构建高效知识检索系统的架构与算法23",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141889615",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1626,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141889615",
        "postTime": "2024-09-04 11:53:59",
        "diggCount": 23,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
        ],
        "collectCount": 5,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141889554,
        "title": "掌握检索技术：构建高效知识检索系统的架构与算法22",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141889554",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1313,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141889554",
        "postTime": "2024-09-04 11:53:33",
        "diggCount": 24,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
        ],
        "collectCount": 14,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141889600,
        "title": "掌握检索技术：构建高效知识检索系统的架构与算法21",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141889600",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1564,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141889600",
        "postTime": "2024-09-04 11:53:26",
        "diggCount": 10,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
        ],
        "collectCount": 7,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 141889578,
        "title": "掌握检索技术：构建高效知识检索系统的架构与算法20",
        "description": "在检索专业知识层需要涵盖更高级的检索技术，包括工程架构和算法策略。",
        "url": "https://blog.csdn.net/2301_76981999/article/details/141889578",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1344,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141889578",
        "postTime": "2024-09-04 11:52:25",
        "diggCount": 9,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1a75f907df604be7bca92259e7116061.png"
        ],
        "collectCount": 5,
        "tags": [
          "人工智能"
        ]
      }
    ]
  },
  {
    "articleCreaterNum": "13848271208",
    "articleInfos": [
      {
        "articleId": 142686027,
        "title": "天猫高频编程考题：合并区间 （中等）",
        "description": "首先，我们需要按区间的起始位置对区间进行排序。这样可以确保我们处理区间时，所有重叠区间都在一起，便于合并。：O(n)，因为我们仅遍历一遍区间列表。要解决这个问题，我们需要合并所有重叠的区间。区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。区间 [1,4] 和 [4,5] 可被视为重叠区间。：O(n log n)，其中 n 是区间的数量；表示若干个区间的集合，其中单个区间为。中的区间即为合并后的不重叠区间。，用于存储合并后的区间。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142686027",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1094,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142686027",
        "postTime": "2024-10-02 22:14:42",
        "diggCount": 5,
        "formatTime": "2024.10.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/465f329593c849c9922664afd75bdb2f.png"
        ],
        "collectCount": 8,
        "tags": [
          "leetcode",
          "算法"
        ]
      },
      {
        "articleId": 142686017,
        "title": "天猫高频编程考题：轮转数组 （中等）",
        "description": "使用环状替换算法，通过逐个移动元素到其最终位置来实现轮转。这种方法也是 O(n) 时间复杂度，并且 O(1) 空间复杂度。向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]这种方法不使用额外的空间（O(1) 空间复杂度），且时间复杂度为 O(n)。：通过创建新数组并将元素放置到新位置，然后将结果复制回原数组。这种方法简单但需要额外的空间。：通过反转整个数组，然后分别反转前。，将数组中的元素向右轮转。要将数组中的元素向右轮转。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142686017",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1118,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142686017",
        "postTime": "2024-10-02 22:13:54",
        "diggCount": 5,
        "formatTime": "2024.10.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/677576f0d4e54e619b3e13548aac6a5d.png"
        ],
        "collectCount": 7,
        "tags": [
          "算法",
          "python",
          "leetcode"
        ]
      },
      {
        "articleId": 142865589,
        "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析15",
        "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都 ok 了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142865589",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1309,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142865589",
        "postTime": "2024-10-11 23:32:03",
        "diggCount": 18,
        "formatTime": "2024.10.11",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
        ],
        "collectCount": 10,
        "tags": [
          "mysql",
          "数据库"
        ]
      },
      {
        "articleId": 142700355,
        "title": "天猫高频编程考题：​K 个一组翻转链表 （困难）​",
        "description": "在翻转每一组的过程中，注意将前一组翻转后的最后一个节点连接到当前组翻转后的第一个节点上。个节点，我们将它们翻转。可以借助一个辅助函数来实现链表的一部分翻转。是一个正整数，它的值小于或等于链表的长度。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。的整数倍，那么请将最后剩余的节点保持原有顺序。个节点一组进行翻转，请你返回修改后的链表。：我们从头节点开始，遍历链表，找到每。额外内存空间的算法解决此问题吗？个节点作为一组需要翻转的部分。：如果最后剩余的节点数量不足。，则保持其原有顺序不动。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700355",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 969,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700355",
        "postTime": "2024-10-04 10:11:57",
        "diggCount": 3,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/772d27f78e1546bc9c4e46fd3d91d890.png"
        ],
        "collectCount": 7,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 142700352,
        "title": "天猫高频编程考题：随机链表的复制（中等）",
        "description": "指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。要实现一个带有随机指针的链表的深拷贝，我们可以使用一个三步法来确保新链表节点的。：我们遍历原链表，对于每一个节点，我们创建一个新的节点，并将其插入到当前节点的。：最后，我们再一次遍历链表，将新节点从旧节点中分离出来形成新的链表。节点组成，其中每个新节点的值都设为其对应的原节点的值。个节点组成的链表来表示输入/输出中的链表。因为新节点紧随其原节点，所以新节点的。，该指针可以指向链表中的任何节点或空节点。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700352",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1215,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700352",
        "postTime": "2024-10-04 10:11:19",
        "diggCount": 9,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/3a04e28961904e509f32eb0475386f9d.png"
        ],
        "collectCount": 13,
        "tags": [
          "链表",
          "算法",
          "数据结构"
        ]
      },
      {
        "articleId": 142700347,
        "title": "天猫高频编程考题：排序链表（中等）",
        "description": "归并排序适合链表的排序，因为它能在 O(1) 的空间复杂度下完成，而数组的归并排序需要额外的 O(n) 空间复杂度。要对链表进行排序，并且满足 O(n log n) 的时间复杂度，最合适的算法是。时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700347",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1028,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700347",
        "postTime": "2024-10-04 10:10:46",
        "diggCount": 3,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/b2368e980057424192b6034177936a5b.png"
        ],
        "collectCount": 5,
        "tags": [
          "链表",
          "算法",
          "数据结构"
        ]
      },
      {
        "articleId": 142700342,
        "title": "天猫高频编程考题：合并 K 个升序链表 （困难）",
        "description": "对于每个节点的插入和删除操作，优先队列的时间复杂度为 O(log k)，其中 k 是链表的数量。总的时间复杂度为 O(N log k)，其中 N 是所有节点的总数。要将多个有序链表合并成一个有序链表，可以使用优先队列（最小堆）来实现，这样能够有效地将多个链表中的最小节点逐步合并，最终形成一个有序的链表。：空间复杂度主要取决于优先队列的存储空间，最坏情况下为 O(k)。请你将所有链表合并到一个升序链表中，返回合并后的链表。给你一个链表数组，每个链表都已经按升序排列。将它们合并到一个有序链表中得到。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700342",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1064,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700342",
        "postTime": "2024-10-04 10:10:09",
        "diggCount": 4,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/751dafd55ff34389bdf5fe2439f17feb.png"
        ],
        "collectCount": 6,
        "tags": [
          "链表",
          "windows",
          "数据结构"
        ]
      },
      {
        "articleId": 142700335,
        "title": "天猫高频编程考题：LRU 缓存（中等）",
        "description": "/ 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.put(4, 4);// 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}// 缓存是 {1=1, 2=2}要实现一个满足 LRU (最近最少使用) 缓存约束的数据结构，可以使用。// 返回 -1 (未找到)lRUCache.get(1);// 返回 -1 (未找到)lRUCache.put(1, 1);// 缓存是 {1=1}lRUCache.get(1);",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700335",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1193,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700335",
        "postTime": "2024-10-04 10:09:38",
        "diggCount": 5,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/c37c6a5ba9734596a43ad012b2d6b2ef.png"
        ],
        "collectCount": 6,
        "tags": [
          "缓存",
          "算法",
          "数据结构"
        ]
      },
      {
        "articleId": 142700324,
        "title": "天猫高频编程考题：二叉树的中序遍历（简单）",
        "description": "要实现二叉树的中序遍历，最常见的方式是使用递归。递归算法很简单，你可以通过迭代算法完成吗？迭代方法使用栈来替代递归。给定一个二叉树的根节点。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700324",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 981,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700324",
        "postTime": "2024-10-04 10:08:49",
        "diggCount": 5,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/f3ef3b4a0148408e818b215f1792b710.png"
        ],
        "collectCount": 7,
        "tags": [
          "算法",
          "数据结构"
        ]
      },
      {
        "articleId": 142700315,
        "title": "天猫高频编程考题：二叉树的最大深度（简单）",
        "description": "是指从根节点到最远叶子节点的最长路径上的节点数。递归方法较为简洁直观。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700315",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 921,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700315",
        "postTime": "2024-10-04 10:08:15",
        "diggCount": 4,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/caef40e28a5e46a09db40b2d1e1b1cab.png"
        ],
        "collectCount": 3,
        "tags": [
          "算法",
          "数据结构",
          "深度优先"
        ]
      },
      {
        "articleId": 142700311,
        "title": "天猫高频编程考题：翻转二叉树（简单）",
        "description": "所以空间复杂度是 O(n)。但对于平衡树，树的高度是 log(n)，因此在平衡树的情况下，空间复杂度是 O(log n)。递归调用会消耗栈空间，栈的深度是树的高度。最坏情况下，树是链式结构（即退化为单边树），高度为。：翻转二叉树的操作是交换每个节点的左子树和右子树。这个操作从根节点开始，然后递归地进行到每个子节点。每个节点都需要访问一次以进行交换和递归操作。因此，时间复杂度是 O(n)。，翻转这棵二叉树，并返回其根节点。给你一棵二叉树的根节点。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700311",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 963,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700311",
        "postTime": "2024-10-04 10:07:42",
        "diggCount": 5,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/01fb91e9d0e04f89ba4eb117d2b48d69.png"
        ],
        "collectCount": 8,
        "tags": [
          "java",
          "算法"
        ]
      },
      {
        "articleId": 142700301,
        "title": "天猫高频编程考题：对称二叉树（简单）",
        "description": "要检查一个二叉树是否是轴对称的，我们可以使用递归或迭代的方法。这里提供了两种方法的解题思路和复杂度分析。：可以使用队列来模拟递归检查过程，通过层次遍历来比较每层的节点对称性。：我们需要检查左右子树是否对称。你可以运用递归和迭代两种方法解决这个问题吗？给你一个二叉树的根节点。， 检查它是否轴对称。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700301",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1568,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700301",
        "postTime": "2024-10-04 10:07:01",
        "diggCount": 24,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/f1d3ad76cc91463f8ff63d44ab93ecfa.png"
        ],
        "collectCount": 19,
        "tags": [
          "算法",
          "数据结构"
        ]
      },
      {
        "articleId": 142700293,
        "title": "天猫高频编程考题：二叉树的直径（简单）",
        "description": "要找到二叉树的直径，我们需要找到树中任意两个节点之间的最长路径。：直径是树中两个节点之间最长的路径长度。这个路径可能会经过树的根节点，也可能不会。3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。因此，整体的空间复杂度主要由递归栈的深度决定，对于最坏情况下是。：通过递归计算每个节点的左右子树的深度，返回节点的最大深度。这条路径可能经过也可能不经过根节点。是指树中任意两个节点之间最长路径的。给你一棵二叉树的根节点，返回该树的。由它们之间边数表示。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700293",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 909,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700293",
        "postTime": "2024-10-04 10:06:21",
        "diggCount": 4,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/82d34823cc444d24b5582f303808b59d.png"
        ],
        "collectCount": 4,
        "tags": [
          "深度优先",
          "算法"
        ]
      },
      {
        "articleId": 142700286,
        "title": "天猫高频编程考题：二叉树的层序遍历（中等）",
        "description": "层序遍历（二叉树的宽度优先遍历）可以使用队列（FIFO）来实现。我们逐层遍历树中的节点，每次处理一层的所有节点，并将它们的子节点加入队列中。（即逐层地，从左到右访问所有节点）。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700286",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 946,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700286",
        "postTime": "2024-10-04 10:05:50",
        "diggCount": 4,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/4a728c2c3636420b9248f8fe0400e427.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "算法"
        ]
      },
      {
        "articleId": 142700276,
        "title": "天猫高频编程考题：将有序数组转换为二叉搜索树（简单）",
        "description": "要将一个升序排列的整数数组转换为一棵平衡二叉搜索树（BST），我们可以利用递归方法构建树。这是因为一个平衡的BST的中序遍历应该是升序排列的，因此我们可以通过递归的方式选择中间的元素作为根节点，递归构建左右子树，从而保持平衡。：由于数组已经是升序排列的，选择中间元素作为根节点可以保证树的高度平衡。[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。排列，请你将其转换为一棵 平衡 二叉搜索树。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700276",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 943,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700276",
        "postTime": "2024-10-04 10:05:11",
        "diggCount": 4,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/f674c50e28b4432a9ebe786a773e0764.png"
        ],
        "collectCount": 9,
        "tags": [
          "算法",
          "java",
          "数据结构"
        ]
      },
      {
        "articleId": 142700248,
        "title": "天猫高频编程考题：验证二叉搜索树（中等）",
        "description": "根节点的值是 5 ，但是右子节点的值是 4。，判断其是否是一个有效的二叉搜索树。给你一个二叉树的根节点。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700248",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1001,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700248",
        "postTime": "2024-10-04 10:03:07",
        "diggCount": 4,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/33d363efcf4c482ab02d62a67441d97d.png"
        ],
        "collectCount": 8,
        "tags": [
          "算法",
          "java",
          "数据结构"
        ]
      },
      {
        "articleId": 142700236,
        "title": "天猫高频编程考题：二叉树的右视图（中等）",
        "description": "要从二叉树的右侧查看并返回节点值，我们可以使用层序遍历（广度优先遍历）来实现。具体来说，我们需要从右侧依次访问每一层的节点，并从每一层的最右侧节点开始返回结果。，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700236",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1046,
        "commentCount": 3,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700236",
        "postTime": "2024-10-04 10:01:56",
        "diggCount": 5,
        "formatTime": "2024.10.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/b6e4941ea10b490a8db4b67f420a3305.png"
        ],
        "collectCount": 8,
        "tags": [
          "算法"
        ]
      },
      {
        "articleId": 142697354,
        "title": "天猫高频编程考题：两两交换链表中的节点（中等）",
        "description": "要实现两两交换链表中的相邻节点，可以使用迭代的方法，借助指针操作来完成节点的交换。这里我们不修改节点的值，只通过调整节点之间的连接顺序来达到目的。给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。:为了方便处理链表头节点的特殊情况，我们可以创建一个虚拟头节点。来指向要交换的节点及其前驱节点；",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142697354",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 819,
        "commentCount": 3,
        "editUrl": "https://mp.csdn.net/console/editor/html/142697354",
        "postTime": "2024-10-03 22:43:06",
        "diggCount": 6,
        "formatTime": "2024.10.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/9accb6bd07004664b210ee2efda6fd14.png"
        ],
        "collectCount": 3,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 142697349,
        "title": "天猫高频编程考题：删除链表的倒数第 N 个结点（中等）",
        "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。要删除链表中的倒数第 n 个节点，进阶要求使用一趟扫描来实现。可以使用双指针法（快慢指针）来完成这个任务。:如果删除的是头节点，需要特别处理，直接返回。指针正好停在要删除的节点的前一个节点上。给你一个链表，删除链表的倒数第。个结点，并且返回链表的头结点。你能尝试使用一趟扫描实现吗？指针，跳过需要删除的节点。，都指向链表的头节点。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142697349",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 962,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142697349",
        "postTime": "2024-10-03 22:42:35",
        "diggCount": 6,
        "formatTime": "2024.10.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/137d35a769744e3d812ca666350ba469.png"
        ],
        "collectCount": 1,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 142697342,
        "title": "天猫高频编程考题：两数相加（中等）",
        "description": "要将两个逆序存储的链表表示的非负整数相加，并返回一个新的链表表示它们的和，可以逐位相加，处理进位问题。每一位的加法要考虑两个链表当前节点的值以及前一位的进位。:遍历两个链表，直到所有节点都处理完；你可以假设除了数字 0 之外，这两个数都不会以 0 开头。不为 0，则需要在结果链表末尾添加一个新节点表示进位。的链表，表示两个非负的整数。请你将两个数相加，并以相同形式返回一个表示和的链表。的方式存储的，并且每个节点只能存储。将计算出的节点值添加到结果链表中。计算当前位的和以及新的进位 (，即结果链表的头节点。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142697342",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1124,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142697342",
        "postTime": "2024-10-03 22:42:00",
        "diggCount": 5,
        "formatTime": "2024.10.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/42e15fcd06a149b982b950da829a46d2.png"
        ],
        "collectCount": 8,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 142697329,
        "title": "天猫高频编程考题：环形链表 II（中等）",
        "description": "快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快慢指针会在环中相遇。:当快慢指针相遇时，将慢指针移回链表的头部，同时保持快指针在相遇点，二者都以相同的速度（每次移动一个节点）继续移动。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。），并在此基础上进一步寻找环的起始节点。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。，返回链表开始入环的第一个节点。要找出链表中环的起始节点，可以使用。，则在该链表中没有环。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142697329",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1011,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142697329",
        "postTime": "2024-10-03 22:40:53",
        "diggCount": 4,
        "formatTime": "2024.10.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/6da46c3a975b45bbb633b479137c614b.png"
        ],
        "collectCount": 3,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 142697324,
        "title": "天猫高频编程考题：环形链表（简单）",
        "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数。来表示链表尾连接到链表中的位置（索引从 0 开始）。判断链表中是否有环，可以使用一种高效的算法，即。如果链表中有某个节点，可以通过连续跟踪。链表中有一个环，其尾部连接到第二个节点。链表中有一个环，其尾部连接到第一个节点。仅仅是为了标识链表的实际情况。，判断链表中是否有环。给你一个链表的头节点。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142697324",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1043,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142697324",
        "postTime": "2024-10-03 22:40:19",
        "diggCount": 4,
        "formatTime": "2024.10.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a464ef15b5bc49359b7acf9308dc37eb.png"
        ],
        "collectCount": 3,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 142931288,
        "title": "zookeeper 都有哪些使用场景？思考3",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931288",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 926,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931288",
        "postTime": "2024-10-14 23:11:25",
        "diggCount": 4,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 8,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931251,
        "title": "zookeeper 都有哪些使用场景？思考4",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931251",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 945,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931251",
        "postTime": "2024-10-14 23:11:22",
        "diggCount": 4,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 7,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931319,
        "title": "zookeeper 都有哪些使用场景？思考5",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931319",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 953,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931319",
        "postTime": "2024-10-14 23:11:19",
        "diggCount": 4,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 4,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931339,
        "title": "zookeeper 都有哪些使用场景？思考6",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931339",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 978,
        "commentCount": 3,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931339",
        "postTime": "2024-10-14 23:11:15",
        "diggCount": 4,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 7,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931252,
        "title": "zookeeper 都有哪些使用场景？思考7",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931252",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 953,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931252",
        "postTime": "2024-10-14 23:11:12",
        "diggCount": 4,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 6,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931364,
        "title": "zookeeper 都有哪些使用场景？思考8",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931364",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1092,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931364",
        "postTime": "2024-10-14 23:11:08",
        "diggCount": 5,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 6,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931287,
        "title": "zookeeper 都有哪些使用场景？思考9",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931287",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 985,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931287",
        "postTime": "2024-10-14 23:07:04",
        "diggCount": 3,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 5,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931298,
        "title": "zookeeper 都有哪些使用场景？思考10",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931298",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 969,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931298",
        "postTime": "2024-10-14 23:07:00",
        "diggCount": 3,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 8,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931208,
        "title": "zookeeper 都有哪些使用场景？思考11",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931208",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 948,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931208",
        "postTime": "2024-10-14 23:03:26",
        "diggCount": 4,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 6,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931171,
        "title": "zookeeper 都有哪些使用场景？思考12",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931171",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 992,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931171",
        "postTime": "2024-10-14 23:03:23",
        "diggCount": 3,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 7,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931155,
        "title": "zookeeper 都有哪些使用场景？思考13",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931155",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 883,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931155",
        "postTime": "2024-10-14 23:03:19",
        "diggCount": 4,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 4,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142931138,
        "title": "zookeeper 都有哪些使用场景？思考14",
        "description": "那么此时就可以使用 zookeeper 分布式锁，一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；这个其实是 zookeeper 很经典的一个用法，简单来说，就好比，你 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。，一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。那个 znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931138",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1026,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931138",
        "postTime": "2024-10-14 23:03:15",
        "diggCount": 3,
        "formatTime": "2024.10.14",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 4,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142896388,
        "title": "FairSync extends Sync 线程抢锁分析7",
        "description": "【代码】FairSync extends Sync 线程抢锁分析7。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142896388",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 790,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142896388",
        "postTime": "2024-10-13 12:08:46",
        "diggCount": 3,
        "formatTime": "2024.10.13",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
        ],
        "collectCount": 0,
        "tags": [
          "java",
          "jvm",
          "算法"
        ]
      },
      {
        "articleId": 142896298,
        "title": "FairSync extends Sync 线程抢锁分析1",
        "description": "【代码】FairSync extends Sync 线程抢锁分析1。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142896298",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 861,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142896298",
        "postTime": "2024-10-13 12:08:41",
        "diggCount": 1,
        "formatTime": "2024.10.13",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
        ],
        "collectCount": 0,
        "tags": [
          "java",
          "jvm",
          "算法"
        ]
      },
      {
        "articleId": 142896408,
        "title": "FairSync extends Sync 线程抢锁分析2",
        "description": "【代码】FairSync extends Sync 线程抢锁分析2。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142896408",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 845,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142896408",
        "postTime": "2024-10-13 12:08:38",
        "diggCount": 2,
        "formatTime": "2024.10.13",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
        ],
        "collectCount": 0,
        "tags": [
          "java",
          "jvm",
          "算法"
        ]
      },
      {
        "articleId": 142896396,
        "title": "FairSync extends Sync 线程抢锁分析3",
        "description": "【代码】FairSync extends Sync 线程抢锁分析3。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142896396",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 884,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142896396",
        "postTime": "2024-10-13 12:08:35",
        "diggCount": 1,
        "formatTime": "2024.10.13",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
        ],
        "collectCount": 0,
        "tags": [
          "java",
          "jvm",
          "算法"
        ]
      },
      {
        "articleId": 142896318,
        "title": "FairSync extends Sync 线程抢锁分析4",
        "description": "【代码】FairSync extends Sync 线程抢锁分析4。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142896318",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 853,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142896318",
        "postTime": "2024-10-13 12:08:32",
        "diggCount": 3,
        "formatTime": "2024.10.13",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
        ],
        "collectCount": 0,
        "tags": [
          "java",
          "jvm",
          "算法"
        ]
      },
      {
        "articleId": 142896348,
        "title": "FairSync extends Sync 线程抢锁分析5",
        "description": "【代码】FairSync extends Sync 线程抢锁分析5。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142896348",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 842,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142896348",
        "postTime": "2024-10-13 12:08:29",
        "diggCount": 1,
        "formatTime": "2024.10.13",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
        ],
        "collectCount": 0,
        "tags": [
          "java",
          "jvm",
          "算法"
        ]
      },
      {
        "articleId": 142896380,
        "title": "FairSync extends Sync 线程抢锁分析6",
        "description": "【代码】FairSync extends Sync 线程抢锁分析6。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142896380",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 773,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142896380",
        "postTime": "2024-10-13 12:08:26",
        "diggCount": 2,
        "formatTime": "2024.10.13",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
        ],
        "collectCount": 0,
        "tags": [
          "java",
          "jvm",
          "算法"
        ]
      },
      {
        "articleId": 142896361,
        "title": "FairSync extends Sync 线程抢锁分析8",
        "description": "【代码】FairSync extends Sync 线程抢锁分析8。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142896361",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 841,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142896361",
        "postTime": "2024-10-13 12:08:18",
        "diggCount": 1,
        "formatTime": "2024.10.13",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/21d571bae583483a98cb3ab3849d62ea.png"
        ],
        "collectCount": 0,
        "tags": [
          "java",
          "jvm",
          "算法"
        ]
      },
      {
        "articleId": 144447882,
        "title": "搜索广告召回技术在美团的实践2",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447882",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 733,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447882",
        "postTime": "2024-12-13 13:44:36",
        "diggCount": 23,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 15,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447823,
        "title": "搜索广告召回技术在美团的实践3",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447823",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 992,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447823",
        "postTime": "2024-12-13 13:44:33",
        "diggCount": 34,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 16,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447770,
        "title": "搜索广告召回技术在美团的实践4",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447770",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 621,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447770",
        "postTime": "2024-12-13 13:44:29",
        "diggCount": 28,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 11,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447866,
        "title": "搜索广告召回技术在美团的实践5",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447866",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 772,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447866",
        "postTime": "2024-12-13 13:44:25",
        "diggCount": 18,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 23,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447800,
        "title": "搜索广告召回技术在美团的实践6",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447800",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 867,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447800",
        "postTime": "2024-12-13 13:44:22",
        "diggCount": 18,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 12,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447769,
        "title": "搜索广告召回技术在美团的实践7",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447769",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 851,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447769",
        "postTime": "2024-12-13 13:44:18",
        "diggCount": 11,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 13,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447898,
        "title": "搜索广告召回技术在美团的实践8",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447898",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 889,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447898",
        "postTime": "2024-12-13 13:44:14",
        "diggCount": 30,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 12,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447867,
        "title": "搜索广告召回技术在美团的实践9",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447867",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 950,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447867",
        "postTime": "2024-12-13 13:42:31",
        "diggCount": 28,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 22,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447785,
        "title": "搜索广告召回技术在美团的实践10",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447785",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 699,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447785",
        "postTime": "2024-12-13 13:42:28",
        "diggCount": 23,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 25,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447732,
        "title": "搜索广告召回技术在美团的实践11",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447732",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1144,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447732",
        "postTime": "2024-12-13 13:42:24",
        "diggCount": 37,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 17,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447838,
        "title": "搜索广告召回技术在美团的实践12",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447838",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 646,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447838",
        "postTime": "2024-12-13 13:42:21",
        "diggCount": 25,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 11,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447713,
        "title": "搜索广告召回技术在美团的实践13",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447713",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 930,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447713",
        "postTime": "2024-12-13 13:42:16",
        "diggCount": 17,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 10,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447698,
        "title": "搜索广告召回技术在美团的实践14",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447698",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1253,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447698",
        "postTime": "2024-12-13 13:42:09",
        "diggCount": 21,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 21,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447678,
        "title": "搜索广告召回技术在美团的实践15",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144447678",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1224,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447678",
        "postTime": "2024-12-13 13:42:04",
        "diggCount": 17,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 25,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144327094,
        "title": "大前端：突破动态化容器的天花板1",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144327094",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 830,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144327094",
        "postTime": "2024-12-08 16:17:05",
        "diggCount": 11,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 10,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144327117,
        "title": "大前端：突破动态化容器的天花板2",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144327117",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 928,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144327117",
        "postTime": "2024-12-08 16:16:57",
        "diggCount": 16,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 12,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144327156,
        "title": "大前端：突破动态化容器的天花板3",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144327156",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 934,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144327156",
        "postTime": "2024-12-08 16:16:53",
        "diggCount": 9,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 21,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144327174,
        "title": "大前端：突破动态化容器的天花板4",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144327174",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 514,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144327174",
        "postTime": "2024-12-08 16:16:49",
        "diggCount": 16,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 13,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144327127,
        "title": "大前端：突破动态化容器的天花板5",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144327127",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 655,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144327127",
        "postTime": "2024-12-08 16:16:46",
        "diggCount": 29,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 28,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144327193,
        "title": "大前端：突破动态化容器的天花板6",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144327193",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 993,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144327193",
        "postTime": "2024-12-08 16:16:42",
        "diggCount": 13,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 8,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144572597,
        "title": "分布式因果推断在美团履约平台的探索与实践15",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572597",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 810,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572597",
        "postTime": "2024-12-19 00:21:37",
        "diggCount": 19,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 29,
        "tags": [
          "均值算法"
        ]
      },
      {
        "articleId": 144571812,
        "title": "百亿规模API网关服务Shepherd的设计与实现1",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571812",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 822,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571812",
        "postTime": "2024-12-18 23:14:52",
        "diggCount": 18,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 20,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571794,
        "title": "百亿规模API网关服务Shepherd的设计与实现2",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571794",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 794,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571794",
        "postTime": "2024-12-18 23:14:48",
        "diggCount": 24,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 24,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571729,
        "title": "百亿规模API网关服务Shepherd的设计与实现3",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571729",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 685,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571729",
        "postTime": "2024-12-18 23:14:44",
        "diggCount": 30,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 16,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571811,
        "title": "百亿规模API网关服务Shepherd的设计与实现4",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571811",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 820,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571811",
        "postTime": "2024-12-18 23:14:40",
        "diggCount": 28,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 18,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571755,
        "title": "百亿规模API网关服务Shepherd的设计与实现5",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571755",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 878,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571755",
        "postTime": "2024-12-18 23:14:36",
        "diggCount": 19,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 24,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571772,
        "title": "百亿规模API网关服务Shepherd的设计与实现6",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571772",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 949,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571772",
        "postTime": "2024-12-18 23:14:31",
        "diggCount": 31,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 13,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571793,
        "title": "百亿规模API网关服务Shepherd的设计与实现7",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571793",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 560,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571793",
        "postTime": "2024-12-18 23:14:27",
        "diggCount": 24,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 19,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571829,
        "title": "百亿规模API网关服务Shepherd的设计与实现9",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571829",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1065,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571829",
        "postTime": "2024-12-18 23:13:52",
        "diggCount": 13,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 28,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571742,
        "title": "百亿规模API网关服务Shepherd的设计与实现10",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571742",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 864,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571742",
        "postTime": "2024-12-18 23:13:48",
        "diggCount": 15,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 17,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571705,
        "title": "百亿规模API网关服务Shepherd的设计与实现11",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571705",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 665,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571705",
        "postTime": "2024-12-18 23:13:44",
        "diggCount": 12,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 21,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571685,
        "title": "百亿规模API网关服务Shepherd的设计与实现12",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571685",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 505,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571685",
        "postTime": "2024-12-18 23:13:39",
        "diggCount": 11,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 11,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571686,
        "title": "百亿规模API网关服务Shepherd的设计与实现13",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571686",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 522,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571686",
        "postTime": "2024-12-18 23:13:36",
        "diggCount": 14,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 25,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571668,
        "title": "百亿规模API网关服务Shepherd的设计与实现14",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571668",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1259,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571668",
        "postTime": "2024-12-18 23:13:31",
        "diggCount": 38,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 14,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144571649,
        "title": "百亿规模API网关服务Shepherd的设计与实现15",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571649",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 786,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571649",
        "postTime": "2024-12-18 23:13:26",
        "diggCount": 26,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 23,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144547086,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践1",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144547086",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 857,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144547086",
        "postTime": "2024-12-17 23:45:53",
        "diggCount": 24,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 8,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144547166,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践2",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144547166",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 694,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144547166",
        "postTime": "2024-12-17 23:45:50",
        "diggCount": 15,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 24,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144547143,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践3",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144547143",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 528,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144547143",
        "postTime": "2024-12-17 23:45:47",
        "diggCount": 23,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 20,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144547186,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践4",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144547186",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 561,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144547186",
        "postTime": "2024-12-17 23:45:43",
        "diggCount": 26,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 22,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144547101,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践5",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144547101",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 752,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144547101",
        "postTime": "2024-12-17 23:45:40",
        "diggCount": 30,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 15,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144597792,
        "title": "Linux下跨语言调用C++实践12",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597792",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 840,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597792",
        "postTime": "2024-12-20 08:29:34",
        "diggCount": 19,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 27,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597900,
        "title": "Linux下跨语言调用C++实践8",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597900",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 789,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597900",
        "postTime": "2024-12-20 08:29:19",
        "diggCount": 28,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 18,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597852,
        "title": "Linux下跨语言调用C++实践9",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597852",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 763,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597852",
        "postTime": "2024-12-20 08:29:13",
        "diggCount": 10,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 20,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597830,
        "title": "Linux下跨语言调用C++实践10",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597830",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 852,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597830",
        "postTime": "2024-12-20 08:29:05",
        "diggCount": 15,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 12,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597780,
        "title": "Linux下跨语言调用C++实践13",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597780",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 841,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597780",
        "postTime": "2024-12-20 08:28:45",
        "diggCount": 9,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 30,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597768,
        "title": "Linux下跨语言调用C++实践14",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597768",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 931,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597768",
        "postTime": "2024-12-20 08:28:19",
        "diggCount": 16,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 24,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597755,
        "title": "Linux下跨语言调用C++实践15",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597755",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1030,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597755",
        "postTime": "2024-12-20 08:28:04",
        "diggCount": 14,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 10,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144572729,
        "title": "分布式因果推断在美团履约平台的探索与实践8",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572729",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 583,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572729",
        "postTime": "2024-12-19 00:24:13",
        "diggCount": 19,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 15,
        "tags": [
          "centos"
        ]
      },
      {
        "articleId": 144572698,
        "title": "分布式因果推断在美团履约平台的探索与实践2",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572698",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 611,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572698",
        "postTime": "2024-12-19 00:23:57",
        "diggCount": 27,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 28,
        "tags": [
          "安全威胁分析"
        ]
      },
      {
        "articleId": 144572688,
        "title": "分布式因果推断在美团履约平台的探索与实践3",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572688",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 639,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572688",
        "postTime": "2024-12-19 00:23:48",
        "diggCount": 18,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 28,
        "tags": [
          "极限编程"
        ]
      },
      {
        "articleId": 144572671,
        "title": "分布式因果推断在美团履约平台的探索与实践4",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572671",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 720,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572671",
        "postTime": "2024-12-19 00:23:38",
        "diggCount": 8,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 23,
        "tags": [
          "中文分词"
        ]
      },
      {
        "articleId": 144572709,
        "title": "分布式因果推断在美团履约平台的探索与实践5",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572709",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 661,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572709",
        "postTime": "2024-12-19 00:23:29",
        "diggCount": 18,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 11,
        "tags": [
          "简单工厂模式"
        ]
      },
      {
        "articleId": 144572680,
        "title": "分布式因果推断在美团履约平台的探索与实践6",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572680",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1008,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572680",
        "postTime": "2024-12-19 00:23:19",
        "diggCount": 12,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 30,
        "tags": [
          "pcb工艺"
        ]
      },
      {
        "articleId": 144572651,
        "title": "分布式因果推断在美团履约平台的探索与实践7",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572651",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 861,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572651",
        "postTime": "2024-12-19 00:23:09",
        "diggCount": 11,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 8,
        "tags": [
          "微服务"
        ]
      },
      {
        "articleId": 144572642,
        "title": "分布式因果推断在美团履约平台的探索与实践9",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572642",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 869,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572642",
        "postTime": "2024-12-19 00:22:45",
        "diggCount": 7,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 13,
        "tags": [
          "vscode"
        ]
      },
      {
        "articleId": 144572691,
        "title": "分布式因果推断在美团履约平台的探索与实践10",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572691",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1142,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572691",
        "postTime": "2024-12-19 00:22:35",
        "diggCount": 20,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 11,
        "tags": [
          "symfony"
        ]
      },
      {
        "articleId": 144572664,
        "title": "分布式因果推断在美团履约平台的探索与实践11",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572664",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 878,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572664",
        "postTime": "2024-12-19 00:22:17",
        "diggCount": 11,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 22,
        "tags": [
          "symfony"
        ]
      },
      {
        "articleId": 144572625,
        "title": "分布式因果推断在美团履约平台的探索与实践12",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572625",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 885,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572625",
        "postTime": "2024-12-19 00:22:07",
        "diggCount": 35,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 28,
        "tags": [
          "kind"
        ]
      },
      {
        "articleId": 144572606,
        "title": "分布式因果推断在美团履约平台的探索与实践13",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572606",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 871,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572606",
        "postTime": "2024-12-19 00:21:56",
        "diggCount": 21,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 9,
        "tags": [
          "逻辑回归"
        ]
      },
      {
        "articleId": 144572617,
        "title": "分布式因果推断在美团履约平台的探索与实践14",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572617",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 766,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572617",
        "postTime": "2024-12-19 00:21:47",
        "diggCount": 15,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 30,
        "tags": [
          "依赖倒置原则"
        ]
      },
      {
        "articleId": 144645625,
        "title": "Android静态代码扫描效率优化与实践3",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645625",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 946,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645625",
        "postTime": "2024-12-22 13:46:57",
        "diggCount": 27,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 9,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645688,
        "title": "Android静态代码扫描效率优化与实践4",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645688",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 808,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645688",
        "postTime": "2024-12-22 13:46:53",
        "diggCount": 16,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 16,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645610,
        "title": "Android静态代码扫描效率优化与实践5",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645610",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 747,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645610",
        "postTime": "2024-12-22 13:46:48",
        "diggCount": 22,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 29,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645597,
        "title": "Android静态代码扫描效率优化与实践6",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645597",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 523,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645597",
        "postTime": "2024-12-22 13:46:45",
        "diggCount": 30,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 12,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645638,
        "title": "Android静态代码扫描效率优化与实践7",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645638",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 660,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645638",
        "postTime": "2024-12-22 13:46:41",
        "diggCount": 26,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 15,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645668,
        "title": "Android静态代码扫描效率优化与实践8",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645668",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 555,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645668",
        "postTime": "2024-12-22 13:46:37",
        "diggCount": 28,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 23,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645682,
        "title": "Android静态代码扫描效率优化与实践",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645682",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 997,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645682",
        "postTime": "2024-12-22 13:46:34",
        "diggCount": 21,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 16,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645669,
        "title": "Android静态代码扫描效率优化与实践10",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645669",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 872,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645669",
        "postTime": "2024-12-22 13:46:30",
        "diggCount": 9,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 17,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645650,
        "title": "Android静态代码扫描效率优化与实践11",
        "description": "背景与问题\n\nDevOps实践中，我们在CI(Continuous Integration)持续集成过程主要包含了代码提交、静态检测、单元测试、编译打包环节。其中静态代码检测可以在编码规范，代码缺陷，性能等问题上提前预知，从而保证项目的交付质量。Android项目常用的静态扫描工具包括CheckStyle、Lint、FindBugs等，为降低接入成本，美团点评集团内部孵化了静态代码扫描插件，集合了以上常用的扫描工具。项目初期引入集团内部基建时我们接入了代码扫描插件，在PR(Pull Request)流程中借",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645650",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 695,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645650",
        "postTime": "2024-12-22 13:46:23",
        "diggCount": 20,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 20,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645561,
        "title": "Android静态代码扫描效率优化与实践12",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645561",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 763,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645561",
        "postTime": "2024-12-22 13:46:19",
        "diggCount": 7,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 17,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645547,
        "title": "Android静态代码扫描效率优化与实践13",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645547",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 853,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645547",
        "postTime": "2024-12-22 13:46:16",
        "diggCount": 27,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 9,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645538,
        "title": "Android静态代码扫描效率优化与实践14",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645538",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 680,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645538",
        "postTime": "2024-12-22 13:46:08",
        "diggCount": 24,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 12,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144645523,
        "title": "Android静态代码扫描效率优化与实践15",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR 文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144645523",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 356,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144645523",
        "postTime": "2024-12-22 13:46:03",
        "diggCount": 5,
        "formatTime": "2024.12.22",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/10689e24ea8b048930550f3a292e2138.jpeg"
        ],
        "collectCount": 8,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144597876,
        "title": "Linux下跨语言调用C++实践1",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597876",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 608,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597876",
        "postTime": "2024-12-20 08:30:27",
        "diggCount": 9,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 21,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597844,
        "title": "Linux下跨语言调用C++实践2",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597844",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 768,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597844",
        "postTime": "2024-12-20 08:30:22",
        "diggCount": 28,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 8,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597813,
        "title": "Linux下跨语言调用C++实践3",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597813",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 724,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597813",
        "postTime": "2024-12-20 08:30:17",
        "diggCount": 21,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 26,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597866,
        "title": "Linux下跨语言调用C++实践4",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597866",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 667,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597866",
        "postTime": "2024-12-20 08:30:12",
        "diggCount": 30,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 27,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597913,
        "title": "Linux下跨语言调用C++实践6",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597913",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 655,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597913",
        "postTime": "2024-12-20 08:30:05",
        "diggCount": 33,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 8,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597814,
        "title": "Linux下跨语言调用C++实践7",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597814",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 557,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597814",
        "postTime": "2024-12-20 08:30:00",
        "diggCount": 25,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 14,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597922,
        "title": "Linux下跨语言调用C++实践11",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597922",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 828,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597922",
        "postTime": "2024-12-20 08:29:38",
        "diggCount": 22,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 26,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144731028,
        "title": "短视频内容理解与生成技术在美团的创新实践6",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144731028",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 700,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144731028",
        "postTime": "2024-12-26 00:04:49",
        "diggCount": 28,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 25,
        "tags": [
          "大数据"
        ]
      },
      {
        "articleId": 144730998,
        "title": "短视频内容理解与生成技术在美团的创新实践7",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144730998",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 543,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144730998",
        "postTime": "2024-12-26 00:04:45",
        "diggCount": 28,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 15,
        "tags": [
          "大数据"
        ]
      },
      {
        "articleId": 144731007,
        "title": "短视频内容理解与生成技术在美团的创新实践8",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144731007",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 699,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144731007",
        "postTime": "2024-12-26 00:04:41",
        "diggCount": 21,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 14,
        "tags": [
          "hadoop"
        ]
      },
      {
        "articleId": 144731016,
        "title": "短视频内容理解与生成技术在美团的创新实践9",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144731016",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 958,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144731016",
        "postTime": "2024-12-26 00:04:38",
        "diggCount": 29,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 19,
        "tags": [
          "大数据"
        ]
      },
      {
        "articleId": 144731015,
        "title": "短视频内容理解与生成技术在美团的创新实践10",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144731015",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 775,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144731015",
        "postTime": "2024-12-26 00:04:35",
        "diggCount": 12,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 26,
        "tags": [
          "大数据"
        ]
      },
      {
        "articleId": 144731030,
        "title": "短视频内容理解与生成技术在美团的创新实践11",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144731030",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 743,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144731030",
        "postTime": "2024-12-26 00:04:31",
        "diggCount": 8,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 29,
        "tags": [
          "性能优化"
        ]
      },
      {
        "articleId": 144730985,
        "title": "短视频内容理解与生成技术在美团的创新实践12",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144730985",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 964,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144730985",
        "postTime": "2024-12-26 00:04:26",
        "diggCount": 27,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 27,
        "tags": [
          "性能优化"
        ]
      },
      {
        "articleId": 144730963,
        "title": "短视频内容理解与生成技术在美团的创新实践13",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144730963",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 528,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144730963",
        "postTime": "2024-12-26 00:04:22",
        "diggCount": 7,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 24,
        "tags": [
          "hadoop"
        ]
      },
      {
        "articleId": 144730976,
        "title": "短视频内容理解与生成技术在美团的创新实践14",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144730976",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 545,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144730976",
        "postTime": "2024-12-26 00:04:17",
        "diggCount": 16,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 18,
        "tags": [
          "性能优化"
        ]
      },
      {
        "articleId": 144730955,
        "title": "短视频内容理解与生成技术在美团的创新实践15",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144730955",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 757,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144730955",
        "postTime": "2024-12-26 00:04:08",
        "diggCount": 17,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 26,
        "tags": [
          "memcached"
        ]
      },
      {
        "articleId": 144705672,
        "title": "Hadoop YARN：调度性能优化实践4",
        "description": "本文主要介绍了美团点评Hadoop YARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705672",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 948,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705672",
        "postTime": "2024-12-25 08:00:46",
        "diggCount": 26,
        "formatTime": "2024.12.25",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/dc5ef43b14f128a758d00e7ff82c3557.png"
        ],
        "collectCount": 19,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 144705582,
        "title": "Hadoop YARN：调度性能优化实践2",
        "description": "本文主要介绍了美团点评Hadoop YARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705582",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 774,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705582",
        "postTime": "2024-12-25 08:00:40",
        "diggCount": 22,
        "formatTime": "2024.12.25",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/208b25fad7c733401f9d2251198d6343.png"
        ],
        "collectCount": 22,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 144705639,
        "title": "Hadoop YARN：调度性能优化实践3",
        "description": "本文主要介绍了美团点评Hadoop YARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705639",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 784,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705639",
        "postTime": "2024-12-25 08:00:37",
        "diggCount": 13,
        "formatTime": "2024.12.25",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/208b25fad7c733401f9d2251198d6343.png"
        ],
        "collectCount": 24,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 144705684,
        "title": "Hadoop YARN：调度性能优化实践5",
        "description": "本文主要介绍了美团点评Hadoop YARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705684",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 527,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705684",
        "postTime": "2024-12-25 08:00:32",
        "diggCount": 16,
        "formatTime": "2024.12.25",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/208b25fad7c733401f9d2251198d6343.png"
        ],
        "collectCount": 25,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 144705655,
        "title": "Hadoop YARN：调度性能优化实践6",
        "description": "本文主要介绍了美团点评Hadoop YARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705655",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 593,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705655",
        "postTime": "2024-12-25 08:00:30",
        "diggCount": 20,
        "formatTime": "2024.12.25",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/208b25fad7c733401f9d2251198d6343.png"
        ],
        "collectCount": 18,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 144705628,
        "title": "Hadoop YARN：调度性能优化实践7",
        "description": "本文主要介绍了美团点评Hadoop YARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705628",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 793,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705628",
        "postTime": "2024-12-25 08:00:28",
        "diggCount": 9,
        "formatTime": "2024.12.25",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/208b25fad7c733401f9d2251198d6343.png"
        ],
        "collectCount": 19,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 144705546,
        "title": "Hadoop YARN：调度性能优化实践8",
        "description": "本文主要介绍了美团点评Hadoop YARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705546",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 982,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705546",
        "postTime": "2024-12-25 08:00:26",
        "diggCount": 28,
        "formatTime": "2024.12.25",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/208b25fad7c733401f9d2251198d6343.png"
        ],
        "collectCount": 11,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 144705685,
        "title": "Hadoop YARN：调度性能优化实践9",
        "description": "本文主要介绍了美团点评Hadoop YARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705685",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 719,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705685",
        "postTime": "2024-12-25 08:00:23",
        "diggCount": 23,
        "formatTime": "2024.12.25",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/208b25fad7c733401f9d2251198d6343.png"
        ],
        "collectCount": 25,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 144705614,
        "title": "Hadoop YARN：调度性能优化实践10",
        "description": "本文主要介绍了美团点评Hadoop YARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705614",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 837,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705614",
        "postTime": "2024-12-25 08:00:21",
        "diggCount": 29,
        "formatTime": "2024.12.25",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/208b25fad7c733401f9d2251198d6343.png"
        ],
        "collectCount": 14,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 144705559,
        "title": "Hadoop YARN：调度性能优化实践11",
        "description": "本文主要介绍了美团点评Hadoop YARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705559",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 796,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705559",
        "postTime": "2024-12-25 08:00:18",
        "diggCount": 8,
        "formatTime": "2024.12.25",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/208b25fad7c733401f9d2251198d6343.png"
        ],
        "collectCount": 22,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 142697336,
        "title": "天猫高频编程考题：合并两个有序链表（简单）",
        "description": "具体可参考：https://zyfcodes.blog.csdn.net/article/details/141401712。指向合并后的链表的头节点。新链表是通过拼接给定的两个链表的所有节点组成的。法来逐个比较两个链表的节点，然后将较小的节点添加到结果链表中。:当一个链表遍历完后，将另一个链表的剩余部分直接连接到。要将两个升序链表合并为一个新的升序链表，我们可以使用。的当前节点值，将较小的那个节点添加到。将两个升序链表合并为一个新的。，这是合并后链表的头节点。，并移动相应链表的指针；",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142697336",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 891,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142697336",
        "postTime": "2025-01-19 17:18:44",
        "diggCount": 3,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/0a0f72df00724db1ab6a6588c0a2b867.png"
        ],
        "collectCount": 1,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 142700241,
        "title": "天猫高频编程考题：二叉搜索树中第 K 小的元素（中等）",
        "description": "小元素，我们可以利用BST的中序遍历特性。中序遍历BST会以升序方式访问所有节点，因此第。：中序遍历BST的结果是一个升序排列的节点值列表。可以使用递归或迭代的方式进行中序遍历。：在遍历过程中，维护一个计数器来记录已经遍历的节点数量，当计数器等于。如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第。要查找二叉搜索树（BST）中的第。小的元素就是中序遍历结果中的第。小的元素（从1开始计数）。给定一个二叉搜索树的根节点。小的值，你将如何优化算法？时，返回当前节点的值。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142700241",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1005,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142700241",
        "postTime": "2025-01-19 17:18:34",
        "diggCount": 3,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/7be7b92a469348fe9165d76356a1a0fc.png"
        ],
        "collectCount": 4,
        "tags": [
          "算法",
          "java",
          "数据结构"
        ]
      },
      {
        "articleId": 142865631,
        "title": "MYSQL如何设计可以动态扩容缩容的分库分表方案？面试题剖析11",
        "description": "这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都ok了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。这都是玩儿分库分表线上必须经历的事儿。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142865631",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1386,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142865631",
        "postTime": "2025-01-19 17:18:19",
        "diggCount": 5,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/b777dc61e4af4c1599cf7de1df904640.png"
        ],
        "collectCount": 15,
        "tags": [
          "mysql",
          "数据库"
        ]
      },
      {
        "articleId": 142931189,
        "title": "zookeeper 都有哪些使用场景？思考15",
        "description": "那么此时就可以使用zookeeper分布式锁，一个机器接收到了请求之后先获取zookeeper上的一把分布式锁，就是可以去创建一个znode，接着执行操作；这个其实是zookeeper很经典的一个用法，简单来说，就好比，你A系统发送个请求到mq，然后B系统消息消费之后处理了。，一旦B系统处理完了就修改zookeeper那个节点的值，A系统立马就可以收到通知，完美解决。那个znode，结果发现自己创建不了，因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142931189",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 986,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142931189",
        "postTime": "2025-01-19 17:18:10",
        "diggCount": 4,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/c746fd4b62eceecb8b22810a7302ecfb.png"
        ],
        "collectCount": 6,
        "tags": [
          "zookeeper",
          "分布式",
          "云原生"
        ]
      },
      {
        "articleId": 142933636,
        "title": "看看消息队列设计精要14",
        "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142933636",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1665,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142933636",
        "postTime": "2025-01-19 17:17:59",
        "diggCount": 15,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
        ],
        "collectCount": 21,
        "tags": [
          "kafka"
        ]
      },
      {
        "articleId": 144547056,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践14",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144547056",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 709,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144547056",
        "postTime": "2025-01-19 17:17:38",
        "diggCount": 13,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/13b68def209f524d38c4046da8332d74.png"
        ],
        "collectCount": 18,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144571773,
        "title": "百亿规模API网关服务Shepherd的设计与实现8",
        "description": "1.背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144571773",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 794,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144571773",
        "postTime": "2025-01-19 17:17:19",
        "diggCount": 11,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/7beb2f689e4e3e260122038186196616.png"
        ],
        "collectCount": 23,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572699,
        "title": "分布式因果推断在美团履约平台的探索与实践1",
        "description": "1.背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144572699",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 956,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572699",
        "postTime": "2025-01-19 17:17:01",
        "diggCount": 8,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/ca00ca25423b8822842ca6bb3d9c1102.png"
        ],
        "collectCount": 9,
        "tags": [
          "迭代器模式"
        ]
      },
      {
        "articleId": 144682479,
        "title": "Android 兼容 Java 8 语法特性的原理分析4",
        "description": "Java8是Java开发语言非常重要的一个版本。Oracle从2014年3月18日发布Java8，从该版本起，Java开始支持函数式编程。特别是吸收了运行在JVM上的Scala、Groovy等动态脚本语言的特性之后，Java8在语言的表达力、简洁性两个方面有了很大的提高。Lambda表达（函数闭包）函数式接口（@FunctionalInterface）StreamAPI（通过流式调用支持map、filter等高阶函数）方法引用（使用::关键字将函数转化为对象）",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144682479",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 756,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144682479",
        "postTime": "2025-01-19 17:16:45",
        "diggCount": 29,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/95ae900ff49fb389b1aaa93ca4eeacbf.png"
        ],
        "collectCount": 27,
        "tags": [
          "android",
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144705599,
        "title": "Hadoop YARN：调度性能优化实践1",
        "description": "本文主要介绍了美团点评HadoopYARN集群公平调度器的性能优化实践。做性能优化，首先要定义宏观的性能指标，从而能够评估系统的性能。定义压测需要观察的细粒度指标，才能清晰看到系统的瓶颈。工欲善其事，必先利其器。高效的压力测试工具是性能优化必备的利器。优化算法的思路主要有：降低算法时间复杂度；减少重复计算和不必要的计算；并行化。性能优化是永无止境的，要根据真实业务来合理预估业务压力，逐步开展性能优化的工作。代码上线需谨慎，做好防御方案。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144705599",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 593,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144705599",
        "postTime": "2025-01-19 17:16:36",
        "diggCount": 24,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/208b25fad7c733401f9d2251198d6343.png"
        ],
        "collectCount": 17,
        "tags": [
          "hadoop",
          "性能优化",
          "大数据"
        ]
      },
      {
        "articleId": 142933587,
        "title": "Kafka+RabbitMQ+ActiveMQ看看消息队列设计精要",
        "description": "消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。本文不会一一介绍这些消息队列的所有特性，而是探讨一下自主开发设计一个消息队列时，你需要思考和设计的重要方面。过程中我们会参考这些成熟消息队列的很多重要思想。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/142933587",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 976,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142933587",
        "postTime": "2025-01-19 17:13:58",
        "diggCount": 10,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/b1ab7eb34ddd4765a52424920253dac9.png"
        ],
        "collectCount": 27,
        "tags": [
          "分布式"
        ]
      },
      {
        "articleId": 144311991,
        "title": "AutoConsis：UI内容一致性智能检测15",
        "description": "目前，移动App上的业务页面愈发复杂，技术团队常会以页面为单位来拆解团队开发分工，同一类业务元素信息分散在不同团队负责的页面内。在具体的实践中，存在一类不易检出但又影响用户体验的异常：页面中的UI信息相互矛盾（如下图中同一个商品在多个页面上的实际价格不一致）。此类UI内容不一致的异常，没有固定的出现位置和表现规律，长期以来主要依赖测试人员对于UI的熟悉度，主要靠手工测试执行时来随机进行发现。图：界面间UI内容不一致举例（示意图）美团App中的众多业务具备内容繁多的多种页面布局，以及多技术栈共存，如何低成本地",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144311991",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1006,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144311991",
        "postTime": "2025-01-19 17:13:43",
        "diggCount": 16,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 14,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144597891,
        "title": "Linux下跨语言调用C++实践5",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144597891",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 980,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597891",
        "postTime": "2025-01-19 17:13:30",
        "diggCount": 9,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a69f5e143827508c63eb1a0723984cd6.png"
        ],
        "collectCount": 14,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144682185,
        "title": "人工智能短视频内容理解与生成技术在美团的创新实践",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。HadoopYARN：调度性能优化实践-美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144682185",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 804,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144682185",
        "postTime": "2025-01-19 17:13:00",
        "diggCount": 22,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/2a8d94443298520e0fad7f37815e8c2b.gif"
        ],
        "collectCount": 19,
        "tags": [
          "android",
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144807885,
        "title": "Spring Boot引起的“堆外内存泄漏”排查及经验总结",
        "description": "因为strace命令中已经显示申请内存的线程ID。直接使用命令jstackpid去查看线程栈，找到对应的线程栈（注意10进制和16进制转换）如下：strace申请空间的线程栈这里基本上就可以看出问题来了：MCC（美团统一配置中心）使用了Reflections进行扫包，底层使用了SpringBoot去加载JAR。因为解压JAR使用Inflater类，需要用到堆外内存，然后使用Btrace去追踪这个类，栈如下：btrace追踪栈然后查看使用MCC的地方，发现没有配置扫包路径，默认是扫描所有的包。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144807885",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 797,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144807885",
        "postTime": "2025-01-19 17:12:32",
        "diggCount": 28,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/ee6cd12a2a8b62c9516a1e915e4fcb60.png"
        ],
        "collectCount": 9,
        "tags": [
          "python",
          "前端",
          "开发语言"
        ]
      },
      {
        "articleId": 144731064,
        "title": "短视频内容理解与生成技术在美团的创新实践1",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144731064",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 722,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144731064",
        "postTime": "2024-12-26 00:05:09",
        "diggCount": 26,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 26,
        "tags": [
          "代理模式"
        ]
      },
      {
        "articleId": 144731054,
        "title": "短视频内容理解与生成技术在美团的创新实践2",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144731054",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 575,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144731054",
        "postTime": "2024-12-26 00:05:06",
        "diggCount": 17,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 14,
        "tags": [
          "音视频",
          "人工智能"
        ]
      },
      {
        "articleId": 144730997,
        "title": "短视频内容理解与生成技术在美团的创新实践3",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144730997",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 587,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144730997",
        "postTime": "2024-12-26 00:05:02",
        "diggCount": 21,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 25,
        "tags": [
          "性能优化"
        ]
      },
      {
        "articleId": 144731029,
        "title": "短视频内容理解与生成技术在美团的创新实践4",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144731029",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 661,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144731029",
        "postTime": "2024-12-26 00:04:59",
        "diggCount": 8,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 23,
        "tags": [
          "大数据"
        ]
      },
      {
        "articleId": 144731045,
        "title": "短视频内容理解与生成技术在美团的创新实践5",
        "description": "以上分享了美团在视频标签、视频封面与剪辑、视频细粒度像素级编辑技术领域，通过与业务场景的结合期望为商家和用户提供更加智能的信息展示和获取方式。未来，短视频技术应用方面，在美团丰富的业务场景包括本地生活服务、零售电商，都会发挥更大的潜在价值。视频理解技术方面，多模态自监督训练，对于缓解标注数据依赖，提升模型在复杂业务场景的泛化性能方面非常有价值，我们也在做一些尝试和探索。Hadoop YARN：调度性能优化实践 - 美团技术团队。",
        "url": "https://blog.csdn.net/macbookpro11/article/details/144731045",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 846,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144731045",
        "postTime": "2024-12-26 00:04:56",
        "diggCount": 25,
        "formatTime": "2024.12.26",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/71f90bd2a32dcac69986be63977d2b0f.png"
        ],
        "collectCount": 13,
        "tags": [
          "性能优化"
        ]
      }
    ]
  },
  {
    "articleCreaterNum": "13370136591",
    "articleInfos": [
      {
        "articleId": 141828487,
        "title": "使用同步锁的代码示例13",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828487",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 827,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828487",
        "postTime": "2024-09-02 19:49:07",
        "diggCount": 8,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 5,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141828471,
        "title": "使用同步锁的代码示例9",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828471",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 949,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828471",
        "postTime": "2024-09-02 19:48:34",
        "diggCount": 9,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 2,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141828460,
        "title": "使用同步锁的代码示例8",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828460",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 801,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828460",
        "postTime": "2024-09-02 19:47:58",
        "diggCount": 7,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141828444,
        "title": "使用同步锁的代码示例15",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828444",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 832,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828444",
        "postTime": "2024-09-02 19:47:26",
        "diggCount": 1,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 2,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141828409,
        "title": "使用同步锁的代码示例10",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828409",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 907,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828409",
        "postTime": "2024-09-02 19:47:06",
        "diggCount": 2,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141828343,
        "title": "使用同步锁的代码示例7",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828343",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1066,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828343",
        "postTime": "2024-09-02 19:46:54",
        "diggCount": 13,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 3,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141828427,
        "title": "使用同步锁的代码示例6",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828427",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1093,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828427",
        "postTime": "2024-09-02 19:46:50",
        "diggCount": 14,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 5,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141828391,
        "title": "使用同步锁的代码示例12",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828391",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 813,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828391",
        "postTime": "2024-09-02 19:46:25",
        "diggCount": 7,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 1,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141828380,
        "title": "使用同步锁的代码示例14",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828380",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1045,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828380",
        "postTime": "2024-09-02 19:44:35",
        "diggCount": 7,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141828363,
        "title": "使用同步锁的代码示例2",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828363",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 971,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828363",
        "postTime": "2024-09-02 19:44:04",
        "diggCount": 8,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141828331,
        "title": "使用同步锁的代码示例1",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141828331",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1067,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141828331",
        "postTime": "2024-09-02 19:42:50",
        "diggCount": 14,
        "formatTime": "2024.09.02",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 140899532,
        "title": "如何通过表态投票机制提高技术文章的质量与相关性",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899532",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 928,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899532",
        "postTime": "2024-08-04 00:33:01",
        "diggCount": 5,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/750d2fbfe4e64092873bf94359b0ea77.png"
        ],
        "collectCount": 7,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 140899413,
        "title": "利用表态投票机制实现技术文章的真实读者反馈",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899413",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1027,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899413",
        "postTime": "2024-08-04 00:32:55",
        "diggCount": 4,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/26708d18bdcb49fe8ec9b186c5714c61.png"
        ],
        "collectCount": 6,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 140899429,
        "title": "优化技术内容：表态投票如何塑造更具影响力的文章",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899429",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1095,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899429",
        "postTime": "2024-08-04 00:32:27",
        "diggCount": 4,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/fab9aeac0bb54601accf50cc036b7d1e.png"
        ],
        "collectCount": 3,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 140899437,
        "title": "通过表态投票获得精确读者反馈的技术路径",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899437",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1111,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899437",
        "postTime": "2024-08-04 00:32:00",
        "diggCount": 5,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/07d2833290104f8fa53bf53b35e85565.png"
        ],
        "collectCount": 3,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 140899517,
        "title": "深入解析表态投票机制在技术写作中的应用潜力",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899517",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1008,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899517",
        "postTime": "2024-08-04 00:31:41",
        "diggCount": 3,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/51cd3c27d6b241eaa6484772ad1d03c4.png"
        ],
        "collectCount": 8,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 140899447,
        "title": "技术文章新风向：表态投票带来的反馈革命",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899447",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 972,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899447",
        "postTime": "2024-08-04 00:31:28",
        "diggCount": 3,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/64f1378cdada4e1199e2836b7de5c817.png"
        ],
        "collectCount": 4,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 140899509,
        "title": "表态投票的力量：如何通过反馈改进你的技术文章",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899509",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 983,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899509",
        "postTime": "2024-08-04 00:30:37",
        "diggCount": 4,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1266acb6c2f5483a8fa8e7148f9e45ab.png"
        ],
        "collectCount": 6,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 140899497,
        "title": "从数据到决策：表态投票如何改变技术文章的评估方式",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899497",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 979,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899497",
        "postTime": "2024-08-04 00:30:22",
        "diggCount": 4,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/3ed02238b7f344058c8b507f1f0fb9d7.png"
        ],
        "collectCount": 6,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 140899503,
        "title": "提升技术文章质量的秘密武器：表态投票机制",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899503",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1076,
        "commentCount": 3,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899503",
        "postTime": "2024-08-04 00:29:57",
        "diggCount": 3,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/85d2fe4856cd4aeeaccab69537d447f1.png"
        ],
        "collectCount": 3,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 141931752,
        "title": "案例分析：大对象复用的目标和注意点9",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141931752",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1764,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141931752",
        "postTime": "2024-09-05 15:12:25",
        "diggCount": 22,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
        ],
        "collectCount": 23,
        "tags": [
          "redis"
        ]
      },
      {
        "articleId": 141931724,
        "title": "案例分析：大对象复用的目标和注意点8",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141931724",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1534,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141931724",
        "postTime": "2024-09-05 15:11:46",
        "diggCount": 24,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
        ],
        "collectCount": 30,
        "tags": [
          "算法"
        ]
      },
      {
        "articleId": 141931710,
        "title": "案例分析：大对象复用的目标和注意点7",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141931710",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1563,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141931710",
        "postTime": "2024-09-05 15:11:14",
        "diggCount": 24,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
        ],
        "collectCount": 11,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 141931613,
        "title": "案例分析：大对象复用的目标和注意点6",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141931613",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1693,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141931613",
        "postTime": "2024-09-05 15:08:05",
        "diggCount": 7,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
        ],
        "collectCount": 25,
        "tags": [
          "hbase"
        ]
      },
      {
        "articleId": 141931585,
        "title": "案例分析：大对象复用的目标和注意点5",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141931585",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1541,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141931585",
        "postTime": "2024-09-05 15:07:25",
        "diggCount": 12,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
        ],
        "collectCount": 20,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 141931564,
        "title": "案例分析：大对象复用的目标和注意点4",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141931564",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1652,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141931564",
        "postTime": "2024-09-05 15:06:35",
        "diggCount": 16,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
        ],
        "collectCount": 19,
        "tags": [
          "eclipse"
        ]
      },
      {
        "articleId": 141931466,
        "title": "案例分析：大对象复用的目标和注意点2",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141931466",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1509,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141931466",
        "postTime": "2024-09-05 15:03:36",
        "diggCount": 12,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
        ],
        "collectCount": 28,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 141931438,
        "title": "案例分析：大对象复用的目标和注意点1",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在 JVM 中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从 JDK 的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141931438",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1702,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141931438",
        "postTime": "2024-09-05 15:03:06",
        "diggCount": 16,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
        ],
        "collectCount": 21,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 141890420,
        "title": "使用同步锁的代码示例43",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890420",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 930,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890420",
        "postTime": "2024-09-04 12:45:17",
        "diggCount": 3,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 5,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890404,
        "title": "使用同步锁的代码示例44",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890404",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 888,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890404",
        "postTime": "2024-09-04 12:44:28",
        "diggCount": 3,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 1,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890182,
        "title": "使用同步锁的代码示例41",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890182",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 934,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890182",
        "postTime": "2024-09-04 12:30:57",
        "diggCount": 4,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 3,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890165,
        "title": "使用同步锁的代码示例40",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890165",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 911,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890165",
        "postTime": "2024-09-04 12:30:52",
        "diggCount": 5,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890204,
        "title": "使用同步锁的代码示例39",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890204",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 816,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890204",
        "postTime": "2024-09-04 12:30:45",
        "diggCount": 5,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 1,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890187,
        "title": "【无标题】使用同步锁的代码示例42",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890187",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 981,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890187",
        "postTime": "2024-09-04 12:29:18",
        "diggCount": 10,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 2,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890155,
        "title": "使用同步锁的代码示例45",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890155",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 998,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890155",
        "postTime": "2024-09-04 12:27:13",
        "diggCount": 3,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 5,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890149,
        "title": "使用同步锁的代码示例38",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890149",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1007,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890149",
        "postTime": "2024-09-04 12:27:00",
        "diggCount": 6,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 5,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890133,
        "title": "使用同步锁的代码示例37",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890133",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 896,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890133",
        "postTime": "2024-09-04 12:26:31",
        "diggCount": 9,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890124,
        "title": "使用同步锁的代码示例36",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890124",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 945,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890124",
        "postTime": "2024-09-04 12:26:23",
        "diggCount": 3,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 2,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890109,
        "title": "使用同步锁的代码示例35",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890109",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1008,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890109",
        "postTime": "2024-09-04 12:26:18",
        "diggCount": 5,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 141890095,
        "title": "使用同步锁的代码示例34",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间: 20 ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141890095",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 894,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141890095",
        "postTime": "2024-09-04 12:24:29",
        "diggCount": 4,
        "formatTime": "2024.09.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 3,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 144326946,
        "title": "大前端：突破动态化容器的天花板9",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144326946",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 925,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144326946",
        "postTime": "2024-12-08 16:04:00",
        "diggCount": 12,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 24,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144326873,
        "title": "大前端：突破动态化容器的天花板10",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144326873",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 864,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144326873",
        "postTime": "2024-12-08 16:03:54",
        "diggCount": 22,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 19,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144326841,
        "title": "大前端：突破动态化容器的天花板11",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144326841",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 813,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144326841",
        "postTime": "2024-12-08 16:03:51",
        "diggCount": 28,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 24,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144326840,
        "title": "大前端：突破动态化容器的天花板12",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144326840",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 550,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144326840",
        "postTime": "2024-12-08 16:03:48",
        "diggCount": 23,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 10,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144326831,
        "title": "大前端：突破动态化容器的天花板13",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144326831",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 782,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144326831",
        "postTime": "2024-12-08 16:03:44",
        "diggCount": 9,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 11,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144326806,
        "title": "大前端：突破动态化容器的天花板14",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144326806",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 542,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144326806",
        "postTime": "2024-12-08 16:03:41",
        "diggCount": 11,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 9,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144326793,
        "title": "大前端：突破动态化容器的天花板15",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144326793",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 682,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144326793",
        "postTime": "2024-12-08 16:03:37",
        "diggCount": 9,
        "formatTime": "2024.12.08",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 20,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144309827,
        "title": "AutoConsis：UI内容一致性智能检测1",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309827",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 849,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309827",
        "postTime": "2024-12-07 14:57:27",
        "diggCount": 16,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 29,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309869,
        "title": "AutoConsis：UI内容一致性智能检测2",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309869",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 699,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309869",
        "postTime": "2024-12-07 14:57:24",
        "diggCount": 11,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 10,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309974,
        "title": "AutoConsis：UI内容一致性智能检测3",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309974",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 728,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309974",
        "postTime": "2024-12-07 14:57:20",
        "diggCount": 22,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 20,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309928,
        "title": "AutoConsis：UI内容一致性智能检测4",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309928",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 864,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309928",
        "postTime": "2024-12-07 14:57:14",
        "diggCount": 27,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 27,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309884,
        "title": "AutoConsis：UI内容一致性智能检测5",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309884",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 611,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309884",
        "postTime": "2024-12-07 14:57:10",
        "diggCount": 8,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 29,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309998,
        "title": "AutoConsis：UI内容一致性智能检测6",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309998",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 977,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309998",
        "postTime": "2024-12-07 14:57:02",
        "diggCount": 19,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 25,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309905,
        "title": "AutoConsis：UI内容一致性智能检测7",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309905",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1072,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309905",
        "postTime": "2024-12-07 14:56:58",
        "diggCount": 29,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 9,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309843,
        "title": "AutoConsis：UI内容一致性智能检测8",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309843",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 966,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309843",
        "postTime": "2024-12-07 14:56:54",
        "diggCount": 8,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 16,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309951,
        "title": "AutoConsis：UI内容一致性智能检测9",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309951",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 569,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309951",
        "postTime": "2024-12-07 14:56:50",
        "diggCount": 9,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 19,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309883,
        "title": "AutoConsis：UI内容一致性智能检测10",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309883",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 927,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309883",
        "postTime": "2024-12-07 14:56:45",
        "diggCount": 28,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 21,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144310016,
        "title": "AutoConsis：UI内容一致性智能检测11",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144310016",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 877,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144310016",
        "postTime": "2024-12-07 14:56:41",
        "diggCount": 8,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 18,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309798,
        "title": "AutoConsis：UI内容一致性智能检测12",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309798",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1063,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309798",
        "postTime": "2024-12-07 14:56:37",
        "diggCount": 14,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 27,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309814,
        "title": "AutoConsis：UI内容一致性智能检测13",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144309814",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 602,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309814",
        "postTime": "2024-12-07 14:56:33",
        "diggCount": 21,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 27,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144515131,
        "title": "Spark向量化计算在美团生产环境的实践14",
        "description": "i < num;++i) {计算在CPU内完成，逻辑计算单元操作寄存器中的数据，算术运算的源操作数要先放置到CPU的寄存器中，哪怕简单的内存拷贝也需要过CPU寄存器。加载（Load），从内存加载2个源操作数（a[i]和b[i]）到2个寄存器。计算（Compute），执行加法指令，作用于2个寄存器里的源操作数副本，结果产生到目标寄存器。存储（Store），将目标寄存器的数据存入（拷贝）到目标内存位置（c[i]）。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144515131",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 933,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144515131",
        "postTime": "2024-12-16 18:37:31",
        "diggCount": 21,
        "formatTime": "2024.12.16",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/90f687fdaa8ed263d16cfcb6134e8d75.png"
        ],
        "collectCount": 13,
        "tags": [
          "spark",
          "大数据",
          "分布式"
        ]
      },
      {
        "articleId": 144515146,
        "title": "Spark向量化计算在美团生产环境的实践15",
        "description": "i < num;++i) {计算在CPU内完成，逻辑计算单元操作寄存器中的数据，算术运算的源操作数要先放置到CPU的寄存器中，哪怕简单的内存拷贝也需要过CPU寄存器。加载（Load），从内存加载2个源操作数（a[i]和b[i]）到2个寄存器。计算（Compute），执行加法指令，作用于2个寄存器里的源操作数副本，结果产生到目标寄存器。存储（Store），将目标寄存器的数据存入（拷贝）到目标内存位置（c[i]）。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144515146",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1072,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144515146",
        "postTime": "2024-12-16 18:37:26",
        "diggCount": 27,
        "formatTime": "2024.12.16",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/90f687fdaa8ed263d16cfcb6134e8d75.png"
        ],
        "collectCount": 13,
        "tags": [
          "spark",
          "大数据",
          "分布式"
        ]
      },
      {
        "articleId": 144478189,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践1",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478189",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 774,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478189",
        "postTime": "2024-12-14 23:05:11",
        "diggCount": 11,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 13,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478167,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践2",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478167",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 959,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478167",
        "postTime": "2024-12-14 23:05:05",
        "diggCount": 17,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 16,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478102,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践3",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478102",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 534,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478102",
        "postTime": "2024-12-14 23:05:01",
        "diggCount": 11,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 16,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478101,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践4",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478101",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 552,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478101",
        "postTime": "2024-12-14 23:04:56",
        "diggCount": 8,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 28,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478206,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践5",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478206",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 526,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478206",
        "postTime": "2024-12-14 23:04:50",
        "diggCount": 16,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 24,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478083,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践6",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478083",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 702,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478083",
        "postTime": "2024-12-14 23:04:45",
        "diggCount": 27,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 20,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478207,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践7",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478207",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 626,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478207",
        "postTime": "2024-12-14 23:04:39",
        "diggCount": 9,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 14,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478221,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践8",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478221",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 826,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478221",
        "postTime": "2024-12-14 23:04:35",
        "diggCount": 17,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 21,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478137,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践9",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478137",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 516,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478137",
        "postTime": "2024-12-14 23:04:31",
        "diggCount": 28,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 8,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478152,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践10",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478152",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 926,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478152",
        "postTime": "2024-12-14 23:04:25",
        "diggCount": 13,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 18,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478117,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践11",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478117",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 795,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478117",
        "postTime": "2024-12-14 23:03:44",
        "diggCount": 15,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 23,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478040,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践12",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478040",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1203,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478040",
        "postTime": "2024-12-14 23:03:40",
        "diggCount": 37,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 26,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478052,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践13",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478052",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 850,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478052",
        "postTime": "2024-12-14 23:03:35",
        "diggCount": 11,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 10,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478023,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践14",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478023",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 868,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478023",
        "postTime": "2024-12-14 23:03:30",
        "diggCount": 16,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 9,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144478005,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践15",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144478005",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 927,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144478005",
        "postTime": "2024-12-14 23:02:27",
        "diggCount": 15,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 24,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144447092,
        "title": "搜索广告召回技术在美团的实践1",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144447092",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 953,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447092",
        "postTime": "2024-12-13 13:21:04",
        "diggCount": 26,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 30,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447069,
        "title": "搜索广告召回技术在美团的实践2",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144447069",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 969,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447069",
        "postTime": "2024-12-13 13:21:01",
        "diggCount": 21,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 23,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144447054,
        "title": "搜索广告召回技术在美团的实践3",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144447054",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 848,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144447054",
        "postTime": "2024-12-13 13:20:57",
        "diggCount": 10,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 28,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144549648,
        "title": "百亿规模API网关服务Shepherd的设计与实现1",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549648",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 623,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549648",
        "postTime": "2024-12-18 22:52:20",
        "diggCount": 10,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 26,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549727,
        "title": "百亿规模API网关服务Shepherd的设计与实现2",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549727",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 704,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549727",
        "postTime": "2024-12-18 22:52:00",
        "diggCount": 7,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 24,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549745,
        "title": "百亿规模API网关服务Shepherd的设计与实现3",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549745",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 945,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549745",
        "postTime": "2024-12-18 22:51:37",
        "diggCount": 13,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 27,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549647,
        "title": "百亿规模API网关服务Shepherd的设计与实现4",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549647",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 544,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549647",
        "postTime": "2024-12-18 22:51:14",
        "diggCount": 7,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 23,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549705,
        "title": "百亿规模API网关服务Shepherd的设计与实现5",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549705",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 805,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549705",
        "postTime": "2024-12-18 22:51:10",
        "diggCount": 14,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 22,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549772,
        "title": "百亿规模API网关服务Shepherd的设计与实现6",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549772",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 797,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549772",
        "postTime": "2024-12-18 22:51:06",
        "diggCount": 18,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 29,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549773,
        "title": "百亿规模API网关服务Shepherd的设计与实现7",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549773",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 753,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549773",
        "postTime": "2024-12-18 22:51:02",
        "diggCount": 18,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 18,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549685,
        "title": "百亿规模API网关服务Shepherd的设计与实现9",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549685",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 929,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549685",
        "postTime": "2024-12-18 22:48:59",
        "diggCount": 8,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 26,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549614,
        "title": "百亿规模API网关服务Shepherd的设计与实现10",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549614",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1023,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549614",
        "postTime": "2024-12-18 22:44:49",
        "diggCount": 10,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 11,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549613,
        "title": "百亿规模API网关服务Shepherd的设计与实现11",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549613",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 846,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549613",
        "postTime": "2024-12-18 22:44:44",
        "diggCount": 24,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 22,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549565,
        "title": "百亿规模API网关服务Shepherd的设计与实现12",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549565",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 878,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549565",
        "postTime": "2024-12-18 22:44:40",
        "diggCount": 15,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 16,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549564,
        "title": "百亿规模API网关服务Shepherd的设计与实现13",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549564",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 554,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549564",
        "postTime": "2024-12-18 09:21:32",
        "diggCount": 15,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 28,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144549538,
        "title": "百亿规模API网关服务Shepherd的设计与实现14",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549538",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 592,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549538",
        "postTime": "2024-12-18 09:21:28",
        "diggCount": 9,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/8a4bfa4a5d53ce03efff2abd920b6ca4.png"
        ],
        "collectCount": 28,
        "tags": [
          "前端",
          "网络"
        ]
      },
      {
        "articleId": 144549550,
        "title": "百亿规模API网关服务Shepherd的设计与实现15",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549550",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1108,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549550",
        "postTime": "2024-12-18 09:21:21",
        "diggCount": 17,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/8a4bfa4a5d53ce03efff2abd920b6ca4.png"
        ],
        "collectCount": 8,
        "tags": [
          "前端",
          "网络"
        ]
      },
      {
        "articleId": 144523595,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144523595",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 852,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523595",
        "postTime": "2024-12-17 23:15:26",
        "diggCount": 10,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 16,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144523580,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144523580",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 701,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523580",
        "postTime": "2024-12-17 23:15:23",
        "diggCount": 7,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 19,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144523635,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144523635",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 685,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523635",
        "postTime": "2024-12-17 23:15:20",
        "diggCount": 8,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 15,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144523561,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144523561",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 720,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523561",
        "postTime": "2024-12-17 23:15:11",
        "diggCount": 17,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 30,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144523649,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144523649",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 904,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523649",
        "postTime": "2024-12-17 23:15:08",
        "diggCount": 12,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 26,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144523686,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144523686",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 796,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523686",
        "postTime": "2024-12-17 23:15:04",
        "diggCount": 14,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 18,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144597886,
        "title": "Linux下跨语言调用C++实践9",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597886",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 822,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597886",
        "postTime": "2024-12-20 08:31:07",
        "diggCount": 27,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 9,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597807,
        "title": "Linux下跨语言调用C++实践10",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597807",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 639,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597807",
        "postTime": "2024-12-20 08:31:03",
        "diggCount": 15,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 26,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597896,
        "title": "Linux下跨语言调用C++实践11",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597896",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 636,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597896",
        "postTime": "2024-12-20 08:30:58",
        "diggCount": 22,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 25,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597742,
        "title": "Linux下跨语言调用C++实践12",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597742",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 687,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597742",
        "postTime": "2024-12-20 08:30:54",
        "diggCount": 30,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 16,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597765,
        "title": "Linux下跨语言调用C++实践13",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597765",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 721,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597765",
        "postTime": "2024-12-20 08:30:50",
        "diggCount": 10,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 9,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597727,
        "title": "Linux下跨语言调用C++实践15",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597727",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 855,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597727",
        "postTime": "2024-12-20 08:30:40",
        "diggCount": 23,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 16,
        "tags": [
          "c++",
          "python",
          "java"
        ]
      },
      {
        "articleId": 144572647,
        "title": "分布式因果推断在美团履约平台的探索与实践1",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572647",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 919,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572647",
        "postTime": "2024-12-19 00:18:14",
        "diggCount": 20,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 22,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572607,
        "title": "分布式因果推断在美团履约平台的探索与实践2",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572607",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 927,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572607",
        "postTime": "2024-12-19 00:18:09",
        "diggCount": 19,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 27,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572621,
        "title": "分布式因果推断在美团履约平台的探索与实践3",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572621",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 982,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572621",
        "postTime": "2024-12-19 00:18:03",
        "diggCount": 15,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 10,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572631,
        "title": "分布式因果推断在美团履约平台的探索与实践4",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572631",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 560,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572631",
        "postTime": "2024-12-19 00:17:56",
        "diggCount": 29,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 18,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572592,
        "title": "分布式因果推断在美团履约平台的探索与实践6",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572592",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 816,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572592",
        "postTime": "2024-12-19 00:17:49",
        "diggCount": 28,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 19,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572579,
        "title": "分布式因果推断在美团履约平台的探索与实践7",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572579",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 652,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572579",
        "postTime": "2024-12-19 00:17:46",
        "diggCount": 23,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 23,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572584,
        "title": "分布式因果推断在美团履约平台的探索与实践8",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572584",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 806,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572584",
        "postTime": "2024-12-19 00:17:41",
        "diggCount": 19,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 13,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572600,
        "title": "分布式因果推断在美团履约平台的探索与实践9",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572600",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 655,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572600",
        "postTime": "2024-12-19 00:17:38",
        "diggCount": 29,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 14,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572568,
        "title": "分布式因果推断在美团履约平台的探索与实践10",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572568",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 848,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572568",
        "postTime": "2024-12-19 00:17:34",
        "diggCount": 23,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 13,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572601,
        "title": "分布式因果推断在美团履约平台的探索与实践11",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572601",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 889,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572601",
        "postTime": "2024-12-19 00:17:31",
        "diggCount": 17,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 19,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572552,
        "title": "分布式因果推断在美团履约平台的探索与实践12",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572552",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 595,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572552",
        "postTime": "2024-12-19 00:17:27",
        "diggCount": 7,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 29,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572539,
        "title": "分布式因果推断在美团履约平台的探索与实践13",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572539",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 688,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572539",
        "postTime": "2024-12-19 00:17:24",
        "diggCount": 11,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 29,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572525,
        "title": "分布式因果推断在美团履约平台的探索与实践14",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572525",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 953,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572525",
        "postTime": "2024-12-19 00:17:20",
        "diggCount": 25,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 10,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572512,
        "title": "分布式因果推断在美团履约平台的探索与实践15",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为Causal On Spark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践 - 美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572512",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 721,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572512",
        "postTime": "2024-12-19 00:17:15",
        "diggCount": 14,
        "formatTime": "2024.12.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 19,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144597752,
        "title": "Linux下跨语言调用C++实践14",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597752",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 907,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597752",
        "postTime": "2025-01-19 13:25:19",
        "diggCount": 23,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 9,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 141931548,
        "title": "案例分析：大对象复用的目标和注意点3",
        "description": "对于“”的优化。这里的“大对象”，是一个泛化概念，它可能存放在JVM中，也可能正在网络上传输，也可能存在于数据库中。那么为什么大对象会影响我们的应用性能呢？结合我们前面提到的缓存，以及对象的池化操作，加上对一些中间结果的保存，我们能够对大对象进行初步的提速。但这还远远不够，我们仅仅减少了对象的创建频率，但并没有改变对象“大”这个事实。本课时，将从JDK的一些知识点讲起，先来看几个面试频率比较高的；接下来，从数据的和出发，分别逐步看一下一些把对象变小，把操作聚焦的策略。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141931548",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1283,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141931548",
        "postTime": "2025-01-19 13:25:12",
        "diggCount": 19,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/223d189e6e8e418ebc6182f219d4fc94.png"
        ],
        "collectCount": 15,
        "tags": [
          "算法"
        ]
      },
      {
        "articleId": 144515292,
        "title": "Spark向量化计算在美团生产环境的实践4",
        "description": "i<num;++i){计算在CPU内完成，逻辑计算单元操作寄存器中的数据，算术运算的源操作数要先放置到CPU的寄存器中，哪怕简单的内存拷贝也需要过CPU寄存器。加载（Load），从内存加载2个源操作数（a[i]和b[i]）到2个寄存器。计算（Compute），执行加法指令，作用于2个寄存器里的源操作数副本，结果产生到目标寄存器。存储（Store），将目标寄存器的数据存入（拷贝）到目标内存位置（c[i]）。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144515292",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 769,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144515292",
        "postTime": "2025-01-19 13:25:03",
        "diggCount": 27,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/90f687fdaa8ed263d16cfcb6134e8d75.png"
        ],
        "collectCount": 14,
        "tags": [
          "spark",
          "大数据",
          "分布式"
        ]
      },
      {
        "articleId": 144523614,
        "title": "JAVA领域驱动设计DDD在B端营销系统的实践",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144523614",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 703,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523614",
        "postTime": "2025-01-19 13:24:53",
        "diggCount": 14,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 16,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144549666,
        "title": "百亿规模API网关服务Shepherd的设计与实现8",
        "description": "1.背景\n\n中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。\n\n以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144549666",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 898,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549666",
        "postTime": "2025-01-19 13:24:44",
        "diggCount": 22,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/483418aed2160bba64e9658482bdc170.png"
        ],
        "collectCount": 18,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 144572602,
        "title": "分布式因果推断在美团履约平台的探索与实践5",
        "description": "经过两年持续迭代，我们实现的分布式因果推断工具包已经发展成集模型训练、评估、去偏、Serving于一身的综合型因果工具包。我们内部为这个项目命名为CausalOnSpark，简称COS。目前这个项目也已经全部集成到图灵机器学习平台中。将来有机会我们会再次为大家分享美团履约技术团队在分布式因果推断领域的探索和实践经验。分布式因果推断在美团履约平台的探索与实践-美团技术团队提升分布式系统响应速度：分布式系统远程调用性能提升之道-CSDN博客。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144572602",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 957,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144572602",
        "postTime": "2025-01-19 13:24:36",
        "diggCount": 9,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 14,
        "tags": [
          "人工智能",
          "计算机视觉",
          "算法"
        ]
      },
      {
        "articleId": 141858619,
        "title": "使用同步锁的代码示例28",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循CC4.0BY-SA版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间:20ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/141858619",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1046,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141858619",
        "postTime": "2025-01-19 13:24:26",
        "diggCount": 13,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a3d2d9ece72c40b0a8e3dccd2c59cbbd.png"
        ],
        "collectCount": 5,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 140896092,
        "title": "Java 同步锁性能的最佳实践：从理论到实践的完整指南",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循CC4.0BY-SA版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间:20ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140896092",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 984,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140896092",
        "postTime": "2025-01-19 13:24:19",
        "diggCount": 7,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/d5d6434fa5844e56bf193d6577afcf14.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 140899400,
        "title": "从反馈到改进：表态投票在技术文章中的创新应用",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899400",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 247,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899400",
        "postTime": "2025-01-19 13:22:15",
        "diggCount": 4,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/934d0196efbb408b8aa68271f559ea16.png"
        ],
        "collectCount": 6,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 140896304,
        "title": "Java 同步锁的性能重塑：如何用优化策略打破效率桎梏？",
        "description": "从结果中可以明显看出，同步锁会带来显著的性能开销。同步锁的存在增加了线程间的等待时间和上下文切换的开销，从而降低了程序的整体运行效率。所以在使用锁时，对锁的优化使用是必不可少的。版权声明：本文为博主原创文章，遵循CC4.0BY-SA版权协议，转载请附上原文出处链接和本声明。原文链接：https://blog.csdn.net/xiaofeng10330111/article/details/139611703。运行以上代码，我当前的机器上可以直观的看到。不使用同步锁的时间:20ms。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140896304",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 527,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140896304",
        "postTime": "2025-01-19 13:22:05",
        "diggCount": 14,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/db3787141d668b1b21ce6510b847fa3b.png"
        ],
        "collectCount": 0,
        "tags": [
          "java",
          "jvm",
          "开发语言"
        ]
      },
      {
        "articleId": 140899341,
        "title": "揭秘表态投票：如何通过实时反馈提升技术文章的准确性",
        "description": "查看思考和实现为了简化我们暂时只聚焦在文章类型上，例如以下是以表格形式展示不同类型文章的表态选项：通过这样的投票机制，不仅能让读者在阅读过程中更具参与感，还能通过投票结果帮助其他读者快速了解文章的受欢迎程度和优缺点。同时，作者也能通过这些反馈不断优化和改进自己的创作。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/140899341",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 351,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140899341",
        "postTime": "2025-01-19 13:21:51",
        "diggCount": 7,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/934d0196efbb408b8aa68271f559ea16.png"
        ],
        "collectCount": 5,
        "tags": [
          "python",
          "windows",
          "开发语言"
        ]
      },
      {
        "articleId": 144624938,
        "title": "Android静态代码扫描效率优化与实践",
        "description": "FindBugs是一个静态分析工具，它检查类或者JAR文件，通过Apache的BCEL库来分析Class，将字节码与一组缺陷模式进行对比以发现问题。FindBugs自身定义了一套缺陷模式，目前的版本3.0.1内置了总计300多种缺陷，详细可参考官方文档。FindBugs作为一个扫描的工具集，可以非常灵活的集成在各种编译工具中。接下来，我们主要分析在Gradle中FindBugs的相关内容。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144624938",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1011,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144624938",
        "postTime": "2025-01-19 13:21:37",
        "diggCount": 12,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a8488b855a6348dead8c2e4aa9143f8e.png"
        ],
        "collectCount": 14,
        "tags": [
          "android"
        ]
      },
      {
        "articleId": 144597825,
        "title": "Linux下跨语言调用C++实践1",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597825",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 562,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597825",
        "postTime": "2024-12-20 08:31:42",
        "diggCount": 11,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 15,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597789,
        "title": "Linux下跨语言调用C++实践2",
        "description": "1 背景\n\n查询理解（QU, Query Understanding）是美团搜索的核心模块，主要职责是理解用户查询，生成查询意图、成分、改写等基础信号，应用于搜索的召回、排序、展示等多个环节，对搜索基础体验至关重要。该服务的线上主体程序基于C++语言开发，服务中会加载大量的词表数据、预估模型等，这些数据与模型的离线生产过程有很多文本解析能力需要与线上服务保持一致，从而保证效果层面的一致性，如文本归一化、分词等。\n\n而这些离线生产过程通常用Python与Java实现。如果在线、离线用不同语言各自开发一份",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597789",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 771,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597789",
        "postTime": "2024-12-20 08:31:36",
        "diggCount": 16,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 28,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597864,
        "title": "Linux下跨语言调用C++实践3",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597864",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 995,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597864",
        "postTime": "2024-12-20 08:31:32",
        "diggCount": 14,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 9,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597873,
        "title": "Linux下跨语言调用C++实践4",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597873",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 569,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597873",
        "postTime": "2024-12-20 08:31:27",
        "diggCount": 22,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 12,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597910,
        "title": "Linux下跨语言调用C++实践5",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597910",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 894,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597910",
        "postTime": "2024-12-20 08:31:24",
        "diggCount": 13,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 31,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597840,
        "title": "Linux下跨语言调用C++实践6",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597840",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 894,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597840",
        "postTime": "2024-12-20 08:31:20",
        "diggCount": 15,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 21,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597798,
        "title": "Linux下跨语言调用C++实践7",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597798",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 867,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597798",
        "postTime": "2024-12-20 08:31:16",
        "diggCount": 19,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 20,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      },
      {
        "articleId": 144597851,
        "title": "Linux下跨语言调用C++实践8",
        "description": "为了达到业务方开箱即用的目的，综合考虑C++、Python、Java用户的使用习惯，我们设计了如下的协作结构：图 1实现方案一节中提到Python/Java不能直接调用C++接口，要先对C++中对外提供的接口用C语言的形式进行封装。这里根本原因在于使用动态库中的接口前，需要根据函数名查找接口在内存中的地址，动态库中函数的寻址通过系统函数dlsym实现，dlsym是严格按照传入的函数名寻址。在C语言中，函数签名即为代码函数的名称，而在C++语言中，因为需要支持函数重载，可能会有多个同名函数。",
        "url": "https://blog.csdn.net/2401_86609655/article/details/144597851",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 899,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144597851",
        "postTime": "2024-12-20 08:31:11",
        "diggCount": 28,
        "formatTime": "2024.12.20",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/1e532c1d8b7d6141f149470d95a820a6.png"
        ],
        "collectCount": 19,
        "tags": [
          "linux",
          "c++",
          "python"
        ]
      }
    ]
  },
  {
    "articleCreaterNum": "15847798961",
    "articleInfos": [
      {
        "articleId": 141929369,
        "title": "案例分析：Redis 如何助力秒杀业务5",
        "description": "秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141929369",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 2881,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141929369",
        "postTime": "2025-01-18 23:56:49",
        "diggCount": 39,
        "formatTime": "2025.01.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/2a0efeddd52d4fa993069498695ad92a.png"
        ],
        "collectCount": 34,
        "tags": [
          "wpf"
        ]
      },
      {
        "articleId": 142025665,
        "title": "案例分析：如何用设计模式优化性能11",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025665",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1545,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025665",
        "postTime": "2025-01-18 23:56:41",
        "diggCount": 28,
        "formatTime": "2025.01.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 26,
        "tags": [
          "gitlab"
        ]
      },
      {
        "articleId": 141956593,
        "title": "超越常规：斐波那契数列的极速计算技术6",
        "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141956593",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1475,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141956593",
        "postTime": "2025-01-18 23:56:32",
        "diggCount": 20,
        "formatTime": "2025.01.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
        ],
        "collectCount": 9,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144326485,
        "title": "大前端：突破动态化容器的天花板3",
        "description": "最终我们获得了一个如上图的高性能、安全的动态化容器，可以以Wasm的方式支持原生级别的性能，也可以将JavaScript 的前端工程的性能提升一截。从某个角度看，像是我们把RN用Rust重写了，添加了Wasm解释器的支持。但用熟悉WebView架构的视角看，也可以看作是一个WebEngine Lite，只是试图绘制暂时用的系统UI。文章最后做一下回望和展望。回望：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。动态化容器的本质复杂度是什么？",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144326485",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 918,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144326485",
        "postTime": "2025-01-18 23:56:19",
        "diggCount": 10,
        "formatTime": "2025.01.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/a85307852cd0c2796eb453c811e08e6f.png"
        ],
        "collectCount": 24,
        "tags": [
          "前端"
        ]
      },
      {
        "articleId": 144445401,
        "title": "搜索广告召回技术在美团的实践1",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445401",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 629,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445401",
        "postTime": "2025-01-18 23:56:09",
        "diggCount": 30,
        "formatTime": "2025.01.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 11,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 140888851,
        "title": "Spring AOP理解与研发使用：mock赋能干预举例",
        "description": "参考进行学习总结。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140888851",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1641,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140888851",
        "postTime": "2025-01-18 23:54:01",
        "diggCount": 12,
        "formatTime": "2025.01.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1ea411ef4d604251a0601aa26b407b51.png"
        ],
        "collectCount": 9,
        "tags": [
          "spring",
          "java",
          "后端"
        ]
      },
      {
        "articleId": 141819632,
        "title": "解锁 Feign 技术：优化微服务通信的实战秘籍",
        "description": "Feign 是一个声明式的 Web Service 客户端。它的出现使开发 Web Service 客户端变得很简单。使用 Feign 只需要创建一个接口加上对应的注解，比如：@FeignClient 注解。Feign 有可插拔的注解，包括 Feign 注解和 AX-RS 注解。Feign 也支持编码器和解码器，Spring Cloud Open Feign 对 Feign 进行增强支持 Spring Mvc 注解，可以像 Spring Web 一样使用 HttpMessageConverters 等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141819632",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 818,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141819632",
        "postTime": "2025-01-18 23:53:19",
        "diggCount": 15,
        "formatTime": "2025.01.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1dd51dcdfe704e80896478a4ede5985a.png"
        ],
        "collectCount": 24,
        "tags": [
          "spring cloud"
        ]
      },
      {
        "articleId": 144278948,
        "title": "Spring Guava数据流转换与处理13",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144278948",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 522,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278948",
        "postTime": "2025-01-18 23:53:10",
        "diggCount": 21,
        "formatTime": "2025.01.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 9,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 140742246,
        "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
        "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140742246",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1109,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140742246",
        "postTime": "2025-01-18 23:53:00",
        "diggCount": 3,
        "formatTime": "2025.01.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/1e43dd475a6e431bad459dbf347ef42f.png"
        ],
        "collectCount": 5,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 144549386,
        "title": "基于多模态信息抽取的菜品知识图谱构建1",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549386",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 561,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549386",
        "postTime": "2024-12-18 08:46:26",
        "diggCount": 28,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 29,
        "tags": [
          "flume"
        ]
      },
      {
        "articleId": 144549232,
        "title": "基于多模态信息抽取的菜品知识图谱构建2",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549232",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 711,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549232",
        "postTime": "2024-12-18 08:46:16",
        "diggCount": 25,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 23,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549330,
        "title": "基于多模态信息抽取的菜品知识图谱构建3",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549330",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 744,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549330",
        "postTime": "2024-12-18 08:46:11",
        "diggCount": 22,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 23,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549265,
        "title": "基于多模态信息抽取的菜品知识图谱构建4",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549265",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 899,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549265",
        "postTime": "2024-12-18 08:46:05",
        "diggCount": 8,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 22,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549346,
        "title": "基于多模态信息抽取的菜品知识图谱构建5",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549346",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 568,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549346",
        "postTime": "2024-12-18 08:45:56",
        "diggCount": 24,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/671f42ab07fd990f949a1c903140dd83.png"
        ],
        "collectCount": 22,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549402,
        "title": "基于多模态信息抽取的菜品知识图谱构建6",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549402",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 879,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549402",
        "postTime": "2024-12-18 08:45:52",
        "diggCount": 8,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 9,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549282,
        "title": "基于多模态信息抽取的菜品知识图谱构建7",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549282",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 744,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549282",
        "postTime": "2024-12-18 08:45:46",
        "diggCount": 9,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 17,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549212,
        "title": "基于多模态信息抽取的菜品知识图谱构建8",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549212",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 719,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549212",
        "postTime": "2024-12-18 08:45:42",
        "diggCount": 14,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 13,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549403,
        "title": "基于多模态信息抽取的菜品知识图谱构建9",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549403",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 838,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549403",
        "postTime": "2024-12-18 08:45:37",
        "diggCount": 15,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 18,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549319,
        "title": "基于多模态信息抽取的菜品知识图谱构建10",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549319",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 923,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549319",
        "postTime": "2024-12-18 08:45:32",
        "diggCount": 28,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 25,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549139,
        "title": "基于多模态信息抽取的菜品知识图谱构建11",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549139",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 901,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549139",
        "postTime": "2024-12-18 08:45:26",
        "diggCount": 9,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 19,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549153,
        "title": "基于多模态信息抽取的菜品知识图谱构建12",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549153",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1015,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549153",
        "postTime": "2024-12-18 08:45:22",
        "diggCount": 9,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 28,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549128,
        "title": "基于多模态信息抽取的菜品知识图谱构建13",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549128",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 922,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549128",
        "postTime": "2024-12-18 08:45:17",
        "diggCount": 12,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 8,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549114,
        "title": "基于多模态信息抽取的菜品知识图谱构建14",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549114",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 691,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549114",
        "postTime": "2024-12-18 08:45:12",
        "diggCount": 19,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3114e847dfefa903340b339fc70ef750.png"
        ],
        "collectCount": 11,
        "tags": [
          "知识图谱",
          "人工智能",
          "计算机视觉"
        ]
      },
      {
        "articleId": 144549051,
        "title": "基于多模态信息抽取的菜品知识图谱构建15",
        "description": "1. 背景中国有句古话：“民以食为天”。对食物的分析和理解，特别是识别菜肴的食材，在健康管理、卡路里计算、烹饪艺术、食物搜索等领域具有重要意义。但是，算法技术尽管在目标检测[1]-[3]、通用场景理解[4][5]和跨模态检索[6]-[8]方面取得了很大进展，却没有在食物相关的场景中取得好的表现，尤其是对烹饪菜肴的相关场景。其核心原因是缺乏细粒度食材的基准，这已经成为该领域发展的瓶颈。以往的研究主要集中在食物层面的表征学习，如Food2K上的食物识别[9]-[12]，UNIMIB2016上的食物检测",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144549051",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1002,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144549051",
        "postTime": "2024-12-18 08:45:06",
        "diggCount": 24,
        "formatTime": "2024.12.18",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/8a4bfa4a5d53ce03efff2abd920b6ca4.png"
        ],
        "collectCount": 24,
        "tags": [
          "前端",
          "网络"
        ]
      },
      {
        "articleId": 144523249,
        "title": "领域驱动设计DDD在B端营销系统的实践1",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523249",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 890,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523249",
        "postTime": "2024-12-17 08:34:39",
        "diggCount": 23,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 8,
        "tags": [
          "java-ee"
        ]
      },
      {
        "articleId": 144523239,
        "title": "领域驱动设计DDD在B端营销系统的实践2",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523239",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 631,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523239",
        "postTime": "2024-12-17 08:34:30",
        "diggCount": 16,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 9,
        "tags": [
          "模拟退火算法"
        ]
      },
      {
        "articleId": 144523293,
        "title": "领域驱动设计DDD在B端营销系统的实践3",
        "description": "1 背景通过营销活动实现客户/用户拉新、留存和促活是业界普遍采用的方法。为实现商户增长和留存，美团核心本地商业/商业增值技术部也构建了相应的营销系统来支撑商户的线上营销运营。在系统建设过程中，面临着业务体量大、行业跨度大、场景多样、客户结构复杂，需求多变等挑战。本文试图还原从0到1构建面向商户的营销系统过程中，并通过DDD（领域驱动设计）来应对系统设计和建设中遇到的业务复杂度高、需求多变、维护成本大等问题。2 基本概念软件系统的复杂性主要体现在三个方面。隐晦：一是抽象层面的隐晦，抽象系统时，",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523293",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 649,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523293",
        "postTime": "2024-12-17 08:34:21",
        "diggCount": 10,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 26,
        "tags": [
          "支持向量机"
        ]
      },
      {
        "articleId": 144523188,
        "title": "领域驱动设计DDD在B端营销系统的实践4",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523188",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 845,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523188",
        "postTime": "2024-12-17 08:34:12",
        "diggCount": 9,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 8,
        "tags": [
          "actionscript"
        ]
      },
      {
        "articleId": 144523161,
        "title": "领域驱动设计DDD在B端营销系统的实践5",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523161",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 979,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523161",
        "postTime": "2024-12-17 08:34:04",
        "diggCount": 27,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 29,
        "tags": [
          "big data"
        ]
      },
      {
        "articleId": 144523277,
        "title": "领域驱动设计DDD在B端营销系统的实践6",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523277",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 910,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523277",
        "postTime": "2024-12-17 08:33:55",
        "diggCount": 21,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 29,
        "tags": [
          "swift"
        ]
      },
      {
        "articleId": 144523148,
        "title": "领域驱动设计DDD在B端营销系统的实践7",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523148",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 607,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523148",
        "postTime": "2024-12-17 08:33:47",
        "diggCount": 27,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 19,
        "tags": [
          "elasticsearch"
        ]
      },
      {
        "articleId": 144523248,
        "title": "领域驱动设计DDD在B端营销系统的实践8",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523248",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 815,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523248",
        "postTime": "2024-12-17 08:33:38",
        "diggCount": 11,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 11,
        "tags": [
          "emacs"
        ]
      },
      {
        "articleId": 144523229,
        "title": "领域驱动设计DDD在B端营销系统的实践9",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523229",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 712,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523229",
        "postTime": "2024-12-17 08:33:30",
        "diggCount": 27,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 27,
        "tags": [
          "散列表"
        ]
      },
      {
        "articleId": 144523200,
        "title": "领域驱动设计DDD在B端营销系统的实践10",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523200",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 815,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523200",
        "postTime": "2024-12-17 08:33:22",
        "diggCount": 15,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 16,
        "tags": [
          "逻辑回归"
        ]
      },
      {
        "articleId": 144523238,
        "title": "领域驱动设计DDD在B端营销系统的实践11",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523238",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 623,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523238",
        "postTime": "2024-12-17 08:33:13",
        "diggCount": 27,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 26,
        "tags": [
          "node.js"
        ]
      },
      {
        "articleId": 144523112,
        "title": "领域驱动设计DDD在B端营销系统的实践12",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523112",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 798,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523112",
        "postTime": "2024-12-17 08:33:05",
        "diggCount": 19,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 30,
        "tags": [
          "启发式算法"
        ]
      },
      {
        "articleId": 144523101,
        "title": "领域驱动设计DDD在B端营销系统的实践13",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523101",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 964,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523101",
        "postTime": "2024-12-17 08:32:57",
        "diggCount": 31,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 15,
        "tags": [
          "qt"
        ]
      },
      {
        "articleId": 144523074,
        "title": "领域驱动设计DDD在B端营销系统的实践14",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523074",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 789,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523074",
        "postTime": "2024-12-17 08:32:47",
        "diggCount": 28,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 13,
        "tags": [
          "随机森林"
        ]
      },
      {
        "articleId": 144523066,
        "title": "领域驱动设计DDD在B端营销系统的实践15",
        "description": "我们做的大部分系统都不是全新系统，如CRM、HR或SCM等，已经有很多业界实践，可充分借鉴这些实践，没必要自己创造新概念。要重视统一语言。没有统一语言就不会有概念模型，没有概念模型就不可能有靠谱的代码模型，拿到需求后就开始设计代码模型是不靠谱的。领域驱动设计是团队工作。现实中没有一个是严格意义上的领域专家，所有参与到这项工作的人都可以是领域专家，整个工作可以由技术团队主导，但一定要落地到产品和业务。拥抱变化，持续迭代。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144523066",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 795,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144523066",
        "postTime": "2024-12-17 08:32:37",
        "diggCount": 11,
        "formatTime": "2024.12.17",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/c76c23925b8b016c07414f3f0c578411.png"
        ],
        "collectCount": 27,
        "tags": [
          "node.js"
        ]
      },
      {
        "articleId": 144514540,
        "title": "Spark向量化计算在美团生产环境的实践1",
        "description": "i < num;++i) {计算在CPU内完成，逻辑计算单元操作寄存器中的数据，算术运算的源操作数要先放置到CPU的寄存器中，哪怕简单的内存拷贝也需要过CPU寄存器。加载（Load），从内存加载2个源操作数（a[i]和b[i]）到2个寄存器。计算（Compute），执行加法指令，作用于2个寄存器里的源操作数副本，结果产生到目标寄存器。存储（Store），将目标寄存器的数据存入（拷贝）到目标内存位置（c[i]）。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144514540",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 737,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144514540",
        "postTime": "2024-12-16 18:06:48",
        "diggCount": 22,
        "formatTime": "2024.12.16",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/90f687fdaa8ed263d16cfcb6134e8d75.png"
        ],
        "collectCount": 27,
        "tags": [
          "spark",
          "大数据",
          "分布式"
        ]
      },
      {
        "articleId": 144477514,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践7",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144477514",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 508,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477514",
        "postTime": "2024-12-14 22:15:32",
        "diggCount": 24,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 24,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477486,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践8",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144477486",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 927,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477486",
        "postTime": "2024-12-14 22:15:28",
        "diggCount": 12,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 15,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477374,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践9",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144477374",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 615,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477374",
        "postTime": "2024-12-14 22:15:22",
        "diggCount": 9,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 10,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477503,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践10",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144477503",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 957,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477503",
        "postTime": "2024-12-14 22:15:18",
        "diggCount": 25,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 19,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477448,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践11",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144477448",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 986,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477448",
        "postTime": "2024-12-14 22:15:13",
        "diggCount": 20,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 9,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477302,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践12",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144477302",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1015,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477302",
        "postTime": "2024-12-14 22:12:32",
        "diggCount": 28,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 28,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477323,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践13",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144477323",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 966,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477323",
        "postTime": "2024-12-14 22:12:29",
        "diggCount": 14,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 30,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477280,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践14",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144477280",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 680,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477280",
        "postTime": "2024-12-14 22:12:25",
        "diggCount": 23,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 21,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477261,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践15",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144477261",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 680,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477261",
        "postTime": "2024-12-14 22:12:20",
        "diggCount": 17,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 11,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144445689,
        "title": "搜索广告召回技术在美团的实践2",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445689",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 666,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445689",
        "postTime": "2024-12-13 11:27:06",
        "diggCount": 21,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 25,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144445600,
        "title": "搜索广告召回技术在美团的实践3",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445600",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 889,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445600",
        "postTime": "2024-12-13 11:27:03",
        "diggCount": 8,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 26,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144445543,
        "title": "搜索广告召回技术在美团的实践4",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445543",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 569,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445543",
        "postTime": "2024-12-13 11:27:00",
        "diggCount": 18,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 17,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144445629,
        "title": "搜索广告召回技术在美团的实践5",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445629",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 546,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445629",
        "postTime": "2024-12-13 11:26:56",
        "diggCount": 19,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 8,
        "tags": [
          "散列表"
        ]
      },
      {
        "articleId": 144445516,
        "title": "搜索广告召回技术在美团的实践6",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445516",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 901,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445516",
        "postTime": "2024-12-13 11:26:47",
        "diggCount": 17,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 14,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144445452,
        "title": "搜索广告召回技术在美团的实践7",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445452",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 811,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445452",
        "postTime": "2024-12-13 11:26:44",
        "diggCount": 12,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 21,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144445573,
        "title": "搜索广告召回技术在美团的实践8",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445573",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 937,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445573",
        "postTime": "2024-12-13 11:26:41",
        "diggCount": 24,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 17,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144445666,
        "title": "搜索广告召回技术在美团的实践9",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445666",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 560,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445666",
        "postTime": "2024-12-13 11:26:36",
        "diggCount": 16,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 10,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144445488,
        "title": "搜索广告召回技术在美团的实践14",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445488",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 773,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445488",
        "postTime": "2024-12-13 11:26:32",
        "diggCount": 19,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 26,
        "tags": [
          "memcache"
        ]
      },
      {
        "articleId": 144445487,
        "title": "搜索广告召回技术在美团的实践10",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445487",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 907,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445487",
        "postTime": "2024-12-13 11:26:21",
        "diggCount": 9,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 30,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144445489,
        "title": "搜索广告召回技术在美团的实践11",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144445489",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 568,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144445489",
        "postTime": "2024-12-13 11:26:18",
        "diggCount": 17,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 9,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144278991,
        "title": "Spring Guava数据流转换与处理8",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144278991",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 474,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278991",
        "postTime": "2024-12-06 00:12:46",
        "diggCount": 22,
        "formatTime": "2024.12.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 18,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278978,
        "title": "Spring Guava数据流转换与处理9",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144278978",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 521,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278978",
        "postTime": "2024-12-06 00:12:43",
        "diggCount": 14,
        "formatTime": "2024.12.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 16,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144279054,
        "title": "Spring Guava数据流转换与处理10",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144279054",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 581,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144279054",
        "postTime": "2024-12-06 00:12:39",
        "diggCount": 11,
        "formatTime": "2024.12.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 15,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144279006,
        "title": "Spring Guava数据流转换与处理12",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144279006",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 804,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144279006",
        "postTime": "2024-12-06 00:07:17",
        "diggCount": 7,
        "formatTime": "2024.12.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 11,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278956,
        "title": "Spring Guava数据流转换与处理13",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144278956",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 785,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278956",
        "postTime": "2024-12-06 00:07:13",
        "diggCount": 21,
        "formatTime": "2024.12.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 15,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278940,
        "title": "Spring Guava数据流转换与处理14",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144278940",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 707,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278940",
        "postTime": "2024-12-06 00:07:10",
        "diggCount": 15,
        "formatTime": "2024.12.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 17,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278921,
        "title": "Spring Guava数据流转换与处理15",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144278921",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 366,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278921",
        "postTime": "2024-12-06 00:07:05",
        "diggCount": 5,
        "formatTime": "2024.12.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 10,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144253295,
        "title": "Guava Table：多维度的数据 Table3",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253295",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 307,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253295",
        "postTime": "2024-12-04 23:56:44",
        "diggCount": 5,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 8,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253287,
        "title": "Guava Table：多维度的数据 Table5",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253287",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 274,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253287",
        "postTime": "2024-12-04 23:56:06",
        "diggCount": 5,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 8,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253260,
        "title": "Guava Table：多维度的数据 Table2",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253260",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 332,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253260",
        "postTime": "2024-12-04 23:55:29",
        "diggCount": 3,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 10,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253274,
        "title": "Guava Table：多维度的数据 Table6",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253274",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 211,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253274",
        "postTime": "2024-12-04 23:55:18",
        "diggCount": 4,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 9,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253250,
        "title": "Guava Table：多维度的数据 Table7",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253250",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 394,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253250",
        "postTime": "2024-12-04 23:53:37",
        "diggCount": 3,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 3,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253238,
        "title": "Guava Table：多维度的数据 Table8",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253238",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 382,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253238",
        "postTime": "2024-12-04 23:52:31",
        "diggCount": 3,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 3,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253214,
        "title": "Guava Table：多维度的数据 Table9",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253214",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 300,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253214",
        "postTime": "2024-12-04 23:51:34",
        "diggCount": 4,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 8,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253227,
        "title": "Guava Table：多维度的数据 Table10",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253227",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 242,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253227",
        "postTime": "2024-12-04 23:51:31",
        "diggCount": 4,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 3,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253182,
        "title": "Guava Table：多维度的数据 Table1",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253182",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 374,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253182",
        "postTime": "2024-12-04 23:50:16",
        "diggCount": 5,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 3,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253169,
        "title": "Guava Table：多维度的数据 Table4",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253169",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 402,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253169",
        "postTime": "2024-12-04 23:50:08",
        "diggCount": 3,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 5,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253145,
        "title": "Guava Table：多维度的数据 Table11",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253145",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 456,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253145",
        "postTime": "2024-12-04 23:49:53",
        "diggCount": 14,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 8,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253196,
        "title": "Guava Table：多维度的数据 Table12",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253196",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 295,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253196",
        "postTime": "2024-12-04 23:49:45",
        "diggCount": 4,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 3,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253111,
        "title": "Guava Table：多维度的数据 Table15",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/144253111",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 742,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253111",
        "postTime": "2024-12-04 23:48:59",
        "diggCount": 17,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 5,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 142025618,
        "title": "案例分析：如何用设计模式优化性能12",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025618",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1538,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025618",
        "postTime": "2024-09-08 14:04:43",
        "diggCount": 8,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 29,
        "tags": [
          "开源协议"
        ]
      },
      {
        "articleId": 142025635,
        "title": "案例分析：如何用设计模式优化性能10",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025635",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1700,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025635",
        "postTime": "2024-09-08 14:04:35",
        "diggCount": 25,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 18,
        "tags": [
          "gitcode"
        ]
      },
      {
        "articleId": 142025650,
        "title": "案例分析：如何用设计模式优化性能9",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025650",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1548,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025650",
        "postTime": "2024-09-08 14:04:30",
        "diggCount": 13,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 26,
        "tags": [
          "gitee"
        ]
      },
      {
        "articleId": 142025581,
        "title": "案例分析：如何用设计模式优化性能8",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025581",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1455,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025581",
        "postTime": "2024-09-08 14:04:26",
        "diggCount": 18,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 11,
        "tags": [
          "开放原子"
        ]
      },
      {
        "articleId": 142026097,
        "title": "案例分析：如何用设计模式优化性能7",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142026097",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1670,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142026097",
        "postTime": "2024-09-08 14:04:22",
        "diggCount": 26,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 30,
        "tags": [
          "ossinsight"
        ]
      },
      {
        "articleId": 142025625,
        "title": "案例分析：如何用设计模式优化性能6",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025625",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1390,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025625",
        "postTime": "2024-09-08 13:36:35",
        "diggCount": 12,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 9,
        "tags": [
          "pdf"
        ]
      },
      {
        "articleId": 142025613,
        "title": "案例分析：如何用设计模式优化性能5",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025613",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1319,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025613",
        "postTime": "2024-09-08 13:35:25",
        "diggCount": 11,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 12,
        "tags": [
          "vim"
        ]
      },
      {
        "articleId": 142025602,
        "title": "案例分析：如何用设计模式优化性能4",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025602",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1496,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025602",
        "postTime": "2024-09-08 13:34:48",
        "diggCount": 30,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 12,
        "tags": [
          "sublime text"
        ]
      },
      {
        "articleId": 142025599,
        "title": "案例分析：如何用设计模式优化性能3",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025599",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1430,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025599",
        "postTime": "2024-09-08 13:34:33",
        "diggCount": 23,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 29,
        "tags": [
          "墨刀"
        ]
      },
      {
        "articleId": 142025591,
        "title": "案例分析：如何用设计模式优化性能2",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025591",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1231,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025591",
        "postTime": "2024-09-08 13:33:46",
        "diggCount": 28,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 29,
        "tags": [
          "figma"
        ]
      },
      {
        "articleId": 142025573,
        "title": "案例分析：如何用设计模式优化性能1",
        "description": "就是对常用开发技巧进行的总结，它使得程序员之间交流问题，有了更专业、便捷的方式。比如，我们在《02 | 理论分析：性能优化有章可循，谈谈常用的切入点》中提到，I/O 模块使用的是装饰器模式，你就能很容易想到 I/O 模块的代码组织方式。事实上，大多数设计模式并不能增加程序的性能，它只是代码的一种组织方式。本课时，我们将一一举例讲解和性能相关的几个设计模式，包括代理模式、单例模式、享元模式、原型模式等。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/142025573",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1214,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142025573",
        "postTime": "2024-09-08 13:32:39",
        "diggCount": 7,
        "formatTime": "2024.09.08",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4a06ce6f96c41af8a70957790d2710f.png"
        ],
        "collectCount": 9,
        "tags": [
          "wps"
        ]
      },
      {
        "articleId": 141956720,
        "title": "超越常规：斐波那契数列的极速计算技术15",
        "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141956720",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1625,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141956720",
        "postTime": "2024-09-06 12:33:48",
        "diggCount": 6,
        "formatTime": "2024.09.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
        ],
        "collectCount": 19,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141956712,
        "title": "超越常规：斐波那契数列的极速计算技术14",
        "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141956712",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1243,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141956712",
        "postTime": "2024-09-06 12:33:15",
        "diggCount": 20,
        "formatTime": "2024.09.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
        ],
        "collectCount": 16,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141956706,
        "title": "超越常规：斐波那契数列的极速计算技术13",
        "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141956706",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1219,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141956706",
        "postTime": "2024-09-06 12:32:44",
        "diggCount": 7,
        "formatTime": "2024.09.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
        ],
        "collectCount": 19,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141956695,
        "title": "超越常规：斐波那契数列的极速计算技术12",
        "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141956695",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1390,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141956695",
        "postTime": "2024-09-06 12:31:47",
        "diggCount": 13,
        "formatTime": "2024.09.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
        ],
        "collectCount": 12,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141956661,
        "title": "超越常规：斐波那契数列的极速计算技术11",
        "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141956661",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1440,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141956661",
        "postTime": "2024-09-06 12:29:21",
        "diggCount": 13,
        "formatTime": "2024.09.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
        ],
        "collectCount": 18,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141956646,
        "title": "超越常规：斐波那契数列的极速计算技术10",
        "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141956646",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1351,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141956646",
        "postTime": "2024-09-06 12:28:20",
        "diggCount": 22,
        "formatTime": "2024.09.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
        ],
        "collectCount": 15,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141956639,
        "title": "超越常规：斐波那契数列的极速计算技术9",
        "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141956639",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1515,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141956639",
        "postTime": "2024-09-06 12:27:45",
        "diggCount": 10,
        "formatTime": "2024.09.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
        ],
        "collectCount": 11,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141956621,
        "title": "超越常规：斐波那契数列的极速计算技术8",
        "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141956621",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1295,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141956621",
        "postTime": "2024-09-06 12:26:13",
        "diggCount": 6,
        "formatTime": "2024.09.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
        ],
        "collectCount": 16,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141956612,
        "title": "超越常规：斐波那契数列的极速计算技术7",
        "description": "这是因为快速幂算法的时间复杂度为O(log n)，在算法中只需进行log n次乘法运算。也就是说，数列的第三个数是前两个数的和，第四个数是第二个数和第三个数的和，以此类推。因此，空间复杂度为O(1)，即常数级别的空间复杂度。基本思想是利用矩阵乘法的性质，将斐波那契数列的递推关系表示为矩阵形式，然后通过快速幂算法来快速计算矩阵的高次幂，从而得到斐波那契数列的第n项的值。矩阵解法结合快速幂的斐波那契数列算法具有优秀的时间复杂度O(log n)和空间复杂度O(1)，适用于需要高效计算大数值斐波那契数列的场景。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/141956612",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1301,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141956612",
        "postTime": "2024-09-06 12:25:29",
        "diggCount": 10,
        "formatTime": "2024.09.06",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/62d3a68dd0904e0ea77f73727491ab73.png"
        ],
        "collectCount": 16,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140888860,
        "title": "Spring AOP理解与研发使用：mock赋能干预举例",
        "description": "参考进行学习总结。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140888860",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1073,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140888860",
        "postTime": "2024-08-03 12:49:50",
        "diggCount": 5,
        "formatTime": "2024.08.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/712a957fa4954907b473c23884317055.png"
        ],
        "collectCount": 9,
        "tags": [
          "spring",
          "java",
          "后端"
        ]
      },
      {
        "articleId": 140888838,
        "title": "Spring AOP理解与研发使用：mock赋能干预举例",
        "description": "参考进行学习总结。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140888838",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1403,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140888838",
        "postTime": "2024-08-03 12:48:20",
        "diggCount": 22,
        "formatTime": "2024.08.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/0c481b5063d84e209e3ec87c678286c7.png"
        ],
        "collectCount": 24,
        "tags": [
          "spring",
          "java",
          "后端"
        ]
      },
      {
        "articleId": 140888812,
        "title": "Spring AOP理解与研发使用：mock赋能干预举例",
        "description": "参考进行学习总结。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140888812",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1514,
        "commentCount": 3,
        "editUrl": "https://mp.csdn.net/console/editor/html/140888812",
        "postTime": "2024-08-03 12:47:27",
        "diggCount": 20,
        "formatTime": "2024.08.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/9ed90ff512f44cb2a397e3c5cad23522.png"
        ],
        "collectCount": 18,
        "tags": [
          "spring",
          "java",
          "后端"
        ]
      },
      {
        "articleId": 140888806,
        "title": "Spring AOP理解与研发使用：mock赋能干预举例",
        "description": "参考进行学习总结。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140888806",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1449,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140888806",
        "postTime": "2024-08-03 12:46:42",
        "diggCount": 26,
        "formatTime": "2024.08.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/b1d56382868147d8b90eec723c46d381.png"
        ],
        "collectCount": 24,
        "tags": [
          "spring",
          "java",
          "后端"
        ]
      },
      {
        "articleId": 140888798,
        "title": "Spring AOP理解与研发使用：mock赋能干预举例",
        "description": "参考进行学习总结。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140888798",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1608,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140888798",
        "postTime": "2024-08-03 12:46:23",
        "diggCount": 25,
        "formatTime": "2024.08.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/26bc7703b07742d58123a44f8de0c882.png"
        ],
        "collectCount": 28,
        "tags": [
          "spring",
          "java",
          "后端"
        ]
      },
      {
        "articleId": 140888768,
        "title": "Spring AOP理解与研发使用：mock赋能干预举例",
        "description": "参考进行学习总结。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140888768",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1353,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140888768",
        "postTime": "2024-08-03 12:45:50",
        "diggCount": 16,
        "formatTime": "2024.08.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/428b20b6cadd4a4092cb81d964968f47.png"
        ],
        "collectCount": 19,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 140888746,
        "title": "Spring AOP理解与研发使用：mock赋能干预举例",
        "description": "参考进行学习总结。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140888746",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1768,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140888746",
        "postTime": "2024-08-03 12:44:30",
        "diggCount": 17,
        "formatTime": "2024.08.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/db14eb99712c4e36980024890bd8d283.png"
        ],
        "collectCount": 12,
        "tags": [
          "spring",
          "java",
          "后端"
        ]
      },
      {
        "articleId": 140809926,
        "title": "快速掌握CompletableFuture回调机制的设计与实现",
        "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140809926",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1091,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140809926",
        "postTime": "2024-07-31 00:01:35",
        "diggCount": 4,
        "formatTime": "2024.07.31",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 140809912,
        "title": "快速掌握CompletableFuture回调机制的设计与实现",
        "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140809912",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1524,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140809912",
        "postTime": "2024-07-31 00:00:48",
        "diggCount": 18,
        "formatTime": "2024.07.31",
        "picList": [],
        "collectCount": 18,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 140809919,
        "title": "快速掌握CompletableFuture回调机制的设计与实现",
        "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140809919",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1095,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140809919",
        "postTime": "2024-07-31 00:00:37",
        "diggCount": 5,
        "formatTime": "2024.07.31",
        "picList": [],
        "collectCount": 9,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 140809905,
        "title": "快速掌握CompletableFuture回调机制的设计与实现",
        "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140809905",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1103,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140809905",
        "postTime": "2024-07-30 23:59:29",
        "diggCount": 5,
        "formatTime": "2024.07.30",
        "picList": [],
        "collectCount": 9,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 140809902,
        "title": "快速掌握CompletableFuture回调机制的设计与实现",
        "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140809902",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1111,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140809902",
        "postTime": "2024-07-30 23:58:55",
        "diggCount": 5,
        "formatTime": "2024.07.30",
        "picList": [],
        "collectCount": 7,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 140809888,
        "title": "快速掌握CompletableFuture回调机制的设计与实现",
        "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140809888",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1538,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140809888",
        "postTime": "2024-07-30 23:58:05",
        "diggCount": 22,
        "formatTime": "2024.07.30",
        "picList": [],
        "collectCount": 14,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 140809881,
        "title": "快速掌握CompletableFuture回调机制的设计与实现",
        "description": "在实现上，CompletableFuture的回调机制主要依赖于Java的Future接口和CompletableFuture内部的状态机。创建CompletableFuture对象：通过CompletableFuture的静态工厂方法，我们可以创建一个新的CompletableFuture对象，并指定该对象的异步操作。总的来说，CompletableFuture的原理是基于Java的Future接口和内部的状态机实现的，它可以以非阻塞的方式执行异步操作，并通过回调函数来处理异步操作完成后的结果。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140809881",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1200,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140809881",
        "postTime": "2024-07-30 23:57:49",
        "diggCount": 23,
        "formatTime": "2024.07.30",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/b0e5749d6b0375d40eb22a31823d4b8f.png"
        ],
        "collectCount": 9,
        "tags": [
          "python",
          "开发语言"
        ]
      },
      {
        "articleId": 140742351,
        "title": "ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
        "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140742351",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1055,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140742351",
        "postTime": "2024-07-27 22:17:20",
        "diggCount": 4,
        "formatTime": "2024.07.27",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cd452feabfc24798a097d23de2e39f44.png"
        ],
        "collectCount": 8,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 140742330,
        "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
        "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140742330",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1013,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140742330",
        "postTime": "2024-07-27 22:15:42",
        "diggCount": 5,
        "formatTime": "2024.07.27",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/0e4f980a082446a49c4e885cc2de7bd6.png"
        ],
        "collectCount": 5,
        "tags": [
          "java",
          "云计算",
          "开发语言"
        ]
      },
      {
        "articleId": 140742318,
        "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
        "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140742318",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 925,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140742318",
        "postTime": "2024-07-27 22:15:03",
        "diggCount": 5,
        "formatTime": "2024.07.27",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/856be2df0e7f4ff1a02b045ff9353b63.png"
        ],
        "collectCount": 7,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140742306,
        "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
        "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140742306",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 965,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140742306",
        "postTime": "2024-07-27 22:14:00",
        "diggCount": 4,
        "formatTime": "2024.07.27",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/e9ad99a1dc7141c5bbd40240e408d744.png"
        ],
        "collectCount": 9,
        "tags": [
          "java",
          "开发语言",
          "云计算"
        ]
      },
      {
        "articleId": 140742298,
        "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案",
        "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140742298",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1007,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140742298",
        "postTime": "2024-07-27 22:13:16",
        "diggCount": 3,
        "formatTime": "2024.07.27",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/0735bfd7d1eb42d1ab87c6545d250575.png"
        ],
        "collectCount": 8,
        "tags": [
          "云计算",
          "java"
        ]
      },
      {
        "articleId": 140742287,
        "title": "实战展示 ThreadLocal 如何为多线程编程提供一种简洁而高效的上下文管理方案。",
        "description": "实现一个高效的上下文管理组件，以解决多线程环境下的数据共享和上下文管理这些问题。通过具体的代码示例和实战展示。如何为多线程编程提供一种简洁而高效的上下文管理方案。",
        "url": "https://blog.csdn.net/m0_74022498/article/details/140742287",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1045,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140742287",
        "postTime": "2024-07-27 22:12:22",
        "diggCount": 4,
        "formatTime": "2024.07.27",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/834d6bcbd99449528b8235b1cfdf0c2e.png"
        ],
        "collectCount": 10,
        "tags": [
          "java"
        ]
      }
    ]
  },
  {
    "articleCreaterNum": "19284430302",
    "articleInfos": [
      {
        "articleId": 140809474,
        "title": "学以致用Mybatis-TypeHandler",
        "description": "现在，当使用MyBatis进行数据库查询时，会自动将数据库中的列值转换为对应的List<String>对象，使我们能够方便地在Java代码中使用List<String>类型。总的来说，MyBatis的核心原理是基于配置文件和接口定义的，通过解析配置文件、创建工厂、会话管理和数据库操作等步骤来实现与数据库的交互。TypeHandler的作用是在MyBatis执行SQL查询或更新操作时，将数据库中的列值转换为Java对象，并在将Java对象写入数据库时执行相反的转换。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140809474",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1727,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140809474",
        "postTime": "2025-01-19 00:02:03",
        "diggCount": 34,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/56e7e776a0344508b5a5b43fd3ba4196.png"
        ],
        "collectCount": 16,
        "tags": [
          "oracle",
          "数据库"
        ]
      },
      {
        "articleId": 140888409,
        "title": "AOP开发应用与分析：方法自动打印出入参举例",
        "description": "平时的开发中有些特定的接口为了方便后续定位问题，往往需要打印方法的出入参数以及本次处理所消耗的时间信息等内容，在该背景下，我们可以增加切面对于指定的方法进行处理前的参数打印以及返回前的参数结果打印的处理，同时可以去指定机器或环境来打印等基本控制手段，具体流程图如下。/***/@Slf4j@Aspect@Component/***方法以@PrintLogInfo注解作为切面入口*//***方法入参前打印对应的入参信息内容。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140888409",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1558,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140888409",
        "postTime": "2025-01-19 00:01:53",
        "diggCount": 17,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/0d3f09deb7b442779dae4a4abcb4e94b.png"
        ],
        "collectCount": 15,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 141789896,
        "title": "链表中环的入口点",
        "description": "当快指针第一次到达相遇点时，快指针走过的距离为a+nb+x，慢指针走过的距离为a+x，由于快指针走过的距离是慢指针的两倍，因此有2(a+x)=a+nb+x，化简得到a=(n-1)b+c。当快指针回到链表头部时，慢指针距离环的入口节点的距离为a，因此快慢指针分别从链表头部和相遇点开始移动，相遇的节点即为环的入口节点。链表中环的入口节点是指一个有环链表中，环的入口节点。例如，在如下图所示的链表中，环的入口节点是3（注意，这里环的入口节点不是算链表的第3个节点）。from：链表中环的入口点。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789896",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1335,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141789896",
        "postTime": "2025-01-19 00:01:45",
        "diggCount": 8,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/7c53ce0617ebad3a0ea4ab62dfbc4027.png"
        ],
        "collectCount": 11,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141820454,
        "title": "ConfigurableBeanFactory（可配置的 Bean 工厂）",
        "description": "接口提供了一些方法来配置Bean工厂的行为和属性，使得我们可以动态地管理和调整Bean工厂的配置，从而更好地满足应用程序的需求。通过对Bean工厂的配置，可以实现更灵活、更定制化的Bean管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141820454",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1621,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141820454",
        "postTime": "2025-01-19 00:01:37",
        "diggCount": 19,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 8,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 144477625,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践15",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477625",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1076,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477625",
        "postTime": "2025-01-19 00:01:29",
        "diggCount": 20,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 22,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144446160,
        "title": "搜索广告召回技术在美团的实践5",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446160",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1085,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446160",
        "postTime": "2025-01-19 00:01:19",
        "diggCount": 21,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 9,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 140905883,
        "title": "理解Spring BeanFactory：如何高效管理Bean的生命周期",
        "description": "接口提供了一些方法来配置Bean工厂的行为和属性，使得我们可以动态地管理和调整Bean工厂的配置，从而更好地满足应用程序的需求。通过对Bean工厂的配置，可以实现更灵活、更定制化的Bean管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905883",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1440,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140905883",
        "postTime": "2025-01-19 00:01:08",
        "diggCount": 15,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/8864b338aad74146882ea7de91876652.png"
        ],
        "collectCount": 22,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141833604,
        "title": "K 个一组翻转链表8",
        "description": "迭代方法的基本思路是，每k个节点为一组进行翻转，如果剩余节点不足k个，则保持原有顺序不变。具体实现时，需要使用3个指针：pre、end和next，其中pre表示待翻转区域的前驱节点，end表示待翻转区域的后继节点，next则是遍历链表的指针。输入：head=[1,2,3,4,5],k=3输出：[3,2,1,4,5]示例：输入：head=[1,2,3,4,5],k=2.输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833604",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1345,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141833604",
        "postTime": "2025-01-19 00:00:54",
        "diggCount": 28,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
        ],
        "collectCount": 9,
        "tags": [
          "链表",
          "数据结构",
          "开发语言"
        ]
      },
      {
        "articleId": 144337587,
        "title": "信息流广告预估技术在美团外卖的实践1",
        "description": "总的来说，预估的本质上还是要发掘用户的真实需求，我们一方面参考业界，另一方面深入业务，去挖掘更多的用户行为模式，也在探索有没有更自动化的方式将各种用户问题解决掉。还原建模是算法和工程的联合聚力带来的提升，归根结底算法工程的相互结合才能带来更大的改变。大模型与推荐的结合越来越得到大家的关注，但是客观地讲，这依然是属于一个偏长期的工作，这个时候还是要找到一条可行的路径，不断去优化和提升，如果完全指望用一个“大招”去解决掉所有的问题，会非常困难。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144337587",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 801,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144337587",
        "postTime": "2025-01-19 00:00:46",
        "diggCount": 33,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/261eada05054c249dd0224d88ba297db.png"
        ],
        "collectCount": 23,
        "tags": [
          "自然语言处理",
          "人工智能"
        ]
      },
      {
        "articleId": 140862400,
        "title": "决战超越并发瓶颈---解决并发难题",
        "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是CAS操作能够实现原子性的原因。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862400",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1373,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140862400",
        "postTime": "2025-01-19 00:00:37",
        "diggCount": 29,
        "formatTime": "2025.01.19",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/f6f4eb28e1bed090a045758b1967bb5c.png"
        ],
        "collectCount": 10,
        "tags": [
          "服务器",
          "运维"
        ]
      },
      {
        "articleId": 144477844,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践6",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477844",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 904,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477844",
        "postTime": "2024-12-14 22:35:20",
        "diggCount": 31,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 14,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477829,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践3",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477829",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 774,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477829",
        "postTime": "2024-12-14 22:34:49",
        "diggCount": 11,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 10,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477720,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践1",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477720",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 916,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477720",
        "postTime": "2024-12-14 22:34:45",
        "diggCount": 24,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 11,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477766,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477766",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 654,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477766",
        "postTime": "2024-12-14 22:34:40",
        "diggCount": 15,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 19,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477805,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践4",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477805",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 789,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477805",
        "postTime": "2024-12-14 22:34:28",
        "diggCount": 10,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 19,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477693,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践5",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477693",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 519,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477693",
        "postTime": "2024-12-14 22:34:24",
        "diggCount": 18,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 21,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477817,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践7",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477817",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 972,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477817",
        "postTime": "2024-12-14 22:34:15",
        "diggCount": 17,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 22,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477785,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践8",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477785",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 610,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477785",
        "postTime": "2024-12-14 22:34:11",
        "diggCount": 21,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 22,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477749,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践9",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477749",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 795,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477749",
        "postTime": "2024-12-14 22:34:06",
        "diggCount": 12,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 29,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477732,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践10",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477732",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 539,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477732",
        "postTime": "2024-12-14 22:33:54",
        "diggCount": 10,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 21,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477704,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践11",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477704",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 551,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477704",
        "postTime": "2024-12-14 22:33:51",
        "diggCount": 14,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 28,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477671,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践12",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477671",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 563,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477671",
        "postTime": "2024-12-14 22:33:47",
        "diggCount": 19,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 22,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477655,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践13",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477655",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 893,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477655",
        "postTime": "2024-12-14 22:33:42",
        "diggCount": 13,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 13,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144477639,
        "title": "超大规模数据库集群保稳系列：数据库攻防演练建设实践14",
        "description": "而随机无通知演练功能，就是希望建设这样的能力，可以在非特定时间、非特定集群、非特定场景进行故障演练，在一定程度上填补了故障演练的空白，也是故障演练平台向混沌工程演进的一个里程碑。第二部分是演练任务生成，有了演练计划后，我们按演练计划随机搭配生成演练任务并进行周知，和常规演练最大不同是我们不会周知演练的具体时间（会周知演练集群、场景），主要是为了模拟故障发生的随机性。第三部分是演练任务执行，它完全复用我们常规故障演练的功能，也可以在演练前取消、演练中终止，演练后可以自动恢复整个集群的拓扑。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144477639",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 988,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144477639",
        "postTime": "2024-12-14 22:33:38",
        "diggCount": 7,
        "formatTime": "2024.12.14",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/5356629d7267e4a54b234d9ec6217330.png"
        ],
        "collectCount": 8,
        "tags": [
          "数据库"
        ]
      },
      {
        "articleId": 144446161,
        "title": "搜索广告召回技术在美团的实践1",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446161",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 528,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446161",
        "postTime": "2024-12-13 11:44:24",
        "diggCount": 21,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 11,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446191,
        "title": "搜索广告召回技术在美团的实践2",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446191",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 545,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446191",
        "postTime": "2024-12-13 11:44:21",
        "diggCount": 19,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 25,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446329,
        "title": "搜索广告召回技术在美团的实践3",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446329",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 707,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446329",
        "postTime": "2024-12-13 11:44:17",
        "diggCount": 24,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 9,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446375,
        "title": "搜索广告召回技术在美团的实践4",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446375",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 521,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446375",
        "postTime": "2024-12-13 11:44:14",
        "diggCount": 13,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 28,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446220,
        "title": "搜索广告召回技术在美团的实践6",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446220",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 777,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446220",
        "postTime": "2024-12-13 11:44:07",
        "diggCount": 24,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 15,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446276,
        "title": "搜索广告召回技术在美团的实践7",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446276",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 516,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446276",
        "postTime": "2024-12-13 11:44:03",
        "diggCount": 21,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 17,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446253,
        "title": "搜索广告召回技术在美团的实践8",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446253",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 825,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446253",
        "postTime": "2024-12-13 11:44:00",
        "diggCount": 24,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 23,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446138,
        "title": "搜索广告召回技术在美团的实践9",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446138",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 842,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446138",
        "postTime": "2024-12-13 11:43:57",
        "diggCount": 13,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 11,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446137,
        "title": "搜索广告召回技术在美团的实践10",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446137",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 823,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446137",
        "postTime": "2024-12-13 11:43:55",
        "diggCount": 18,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 25,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446221,
        "title": "搜索广告召回技术在美团的实践11",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446221",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 549,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446221",
        "postTime": "2024-12-13 11:43:52",
        "diggCount": 30,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 15,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446114,
        "title": "搜索广告召回技术在美团的实践12",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446114",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 805,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446114",
        "postTime": "2024-12-13 11:43:49",
        "diggCount": 23,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 24,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446081,
        "title": "搜索广告召回技术在美团的实践13",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446081",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 629,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446081",
        "postTime": "2024-12-13 11:43:46",
        "diggCount": 24,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 9,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446049,
        "title": "搜索广告召回技术在美团的实践14",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446049",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 962,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446049",
        "postTime": "2024-12-13 11:43:43",
        "diggCount": 7,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 16,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144446017,
        "title": "搜索广告召回技术在美团的实践15",
        "description": "从美团流量场景角度来看，美团搜索广告分为两大类，一是列表推荐广告；二是搜索广告。推荐广告以展现商家模式为主，通常叫商家流。搜索广告的展现形式比较丰富，有商家模式，即以商家展现为主，会挂上菜品/商品；还有商品模式，即以商品展现为主，以呈现商品大图、商品标题等核心商品信息为主。搜商品意图占据绝大多数份额，搜索商家只占较小的一部分；因此检索以商品为主，看候选规模的话，美团有百万量级的商家和十亿级别的商品，供给规模较庞大。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144446017",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 550,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144446017",
        "postTime": "2024-12-13 11:43:40",
        "diggCount": 22,
        "formatTime": "2024.12.13",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/52400118d3f261176053924565a98b61.png"
        ],
        "collectCount": 18,
        "tags": [
          "人工智能",
          "算法",
          "机器学习"
        ]
      },
      {
        "articleId": 144337536,
        "title": "信息流广告预估技术在美团外卖的实践7",
        "description": "总的来说，预估的本质上还是要发掘用户的真实需求，我们一方面参考业界，另一方面深入业务，去挖掘更多的用户行为模式，也在探索有没有更自动化的方式将各种用户问题解决掉。还原建模是算法和工程的联合聚力带来的提升，归根结底算法工程的相互结合才能带来更大的改变。大模型与推荐的结合越来越得到大家的关注，但是客观地讲，这依然是属于一个偏长期的工作，这个时候还是要找到一条可行的路径，不断去优化和提升，如果完全指望用一个“大招”去解决掉所有的问题，会非常困难。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144337536",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1007,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144337536",
        "postTime": "2024-12-10 09:29:19",
        "diggCount": 11,
        "formatTime": "2024.12.10",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/60a9edc05f994d769d8bb0e92fda6657.png"
        ],
        "collectCount": 8,
        "tags": [
          "自然语言处理",
          "人工智能"
        ]
      },
      {
        "articleId": 144337569,
        "title": "信息流广告预估技术在美团外卖的实践3",
        "description": "总的来说，预估的本质上还是要发掘用户的真实需求，我们一方面参考业界，另一方面深入业务，去挖掘更多的用户行为模式，也在探索有没有更自动化的方式将各种用户问题解决掉。还原建模是算法和工程的联合聚力带来的提升，归根结底算法工程的相互结合才能带来更大的改变。大模型与推荐的结合越来越得到大家的关注，但是客观地讲，这依然是属于一个偏长期的工作，这个时候还是要找到一条可行的路径，不断去优化和提升，如果完全指望用一个“大招”去解决掉所有的问题，会非常困难。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144337569",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 757,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144337569",
        "postTime": "2024-12-10 09:29:02",
        "diggCount": 24,
        "formatTime": "2024.12.10",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/397add1e9429401cae146fd7128c6acb.png"
        ],
        "collectCount": 21,
        "tags": [
          "自然语言处理",
          "人工智能"
        ]
      },
      {
        "articleId": 144309299,
        "title": "AutoConsis：UI内容一致性智能检测12",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144309299",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 623,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309299",
        "postTime": "2024-12-07 14:11:05",
        "diggCount": 26,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 24,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309283,
        "title": "AutoConsis：UI内容一致性智能检测13",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144309283",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 559,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309283",
        "postTime": "2024-12-07 14:11:02",
        "diggCount": 29,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 20,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309265,
        "title": "AutoConsis：UI内容一致性智能检测14",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144309265",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 556,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309265",
        "postTime": "2024-12-07 14:10:59",
        "diggCount": 19,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 23,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144309250,
        "title": "AutoConsis：UI内容一致性智能检测15",
        "description": "在流程上，对于每一个UI目标区域，AutoConsis利用OCR提取所有可识别的字符，随后将分词的结果与CoT示例进行拼合构成Prompt，最后从LLM（AutoConsis的实验部分调用GPT-3.5-Turbo完成）的输出中获取一致性检验所需的关键信息。以下介绍工具的设计过程。对于营销会场页而言，如UI区域识别流程图所示：我们将一个会场页的UI截图送入识别模型，并提供一个商品卡片和对应的文本描述作为检索词，该多模态模型会根据检索词从经UI组件分析处理过的会场页中筛选出近似的商品卡片。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144309250",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 624,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144309250",
        "postTime": "2024-12-07 14:10:56",
        "diggCount": 27,
        "formatTime": "2024.12.07",
        "picList": [
          "https://i-blog.csdnimg.cn/img_convert/3279166c6869f7abd39db40ebc42a533.png"
        ],
        "collectCount": 22,
        "tags": [
          "ui"
        ]
      },
      {
        "articleId": 144278764,
        "title": "Spring Guava数据流转换与处理2",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278764",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 880,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278764",
        "postTime": "2024-12-05 23:56:08",
        "diggCount": 16,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 9,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278735,
        "title": "Spring Guava数据流转换与处理3",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278735",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 945,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278735",
        "postTime": "2024-12-05 23:56:04",
        "diggCount": 17,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 20,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278749,
        "title": "Spring Guava数据流转换与处理4",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278749",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 839,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278749",
        "postTime": "2024-12-05 23:56:00",
        "diggCount": 21,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 13,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278851,
        "title": "Spring Guava数据流转换与处理5",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278851",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 794,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278851",
        "postTime": "2024-12-05 23:55:57",
        "diggCount": 15,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 9,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278812,
        "title": "Spring Guava数据流转换与处理6",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278812",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 684,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278812",
        "postTime": "2024-12-05 23:55:54",
        "diggCount": 12,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 8,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278780,
        "title": "Spring Guava数据流转换与处理7",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278780",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 707,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278780",
        "postTime": "2024-12-05 23:55:51",
        "diggCount": 25,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 5,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278878,
        "title": "Spring Guava数据流转换与处理8",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278878",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 611,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278878",
        "postTime": "2024-12-05 23:55:47",
        "diggCount": 11,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 8,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278860,
        "title": "Spring Guava数据流转换与处理9",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278860",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 865,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278860",
        "postTime": "2024-12-05 23:55:43",
        "diggCount": 11,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 20,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278832,
        "title": "Spring Guava数据流转换与处理10",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278832",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 842,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278832",
        "postTime": "2024-12-05 23:55:39",
        "diggCount": 16,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 11,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278702,
        "title": "Spring Guava数据流转换与处理11",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278702",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 819,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278702",
        "postTime": "2024-12-05 23:55:36",
        "diggCount": 23,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 18,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278688,
        "title": "Spring Guava数据流转换与处理12",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278688",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 409,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278688",
        "postTime": "2024-12-05 23:55:33",
        "diggCount": 10,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 15,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278678,
        "title": "Spring Guava数据流转换与处理13",
        "description": "在现代开发中，数据流的转换与处理是一个非常常见的需求。无论是从文件读取数据、接收用户输入，还是从数据库提取信息，数据往往需要进行一系列转换和处理。Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。通过结合Guava的工具，我们可以实现更加高效和可读的代码。\n\n\n\n1. Guava的 FluentIterable：链式处理数据流\n\nFluentIterable 是 Guava 提供的一种增强版的 Iterable，它通过扩展 Iterable ",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278678",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 573,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278678",
        "postTime": "2024-12-05 23:55:30",
        "diggCount": 8,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 18,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278679,
        "title": "Spring Guava数据流转换与处理14",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278679",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 610,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278679",
        "postTime": "2024-12-05 23:55:26",
        "diggCount": 5,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 13,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278664,
        "title": "Spring Guava数据流转换与处理15",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278664",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 848,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278664",
        "postTime": "2024-12-05 23:55:22",
        "diggCount": 15,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 5,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144278719,
        "title": "Spring Guava数据流转换与处理1",
        "description": "Guava提供了许多工具和类，能够简化这一过程，尤其是在处理数据时，它的链式调用风格使得数据流的处理更加清晰、优雅。数据流的处理在现代开发中无处不在，而 Guava 提供的流式操作和工具类，让数据处理变得更加简洁、优雅。，都非常适合进行流式操作，通过链式调用我们可以实现一系列数据转换和处理，而不需要中间产生额外的临时变量。提供了许多常用的流式操作方法，可以用来处理集合或迭代器中的数据，增强代码的可读性与可维护性。这样，我们就能够轻松处理包含多余空格或多种分隔符的字符串，避免了手动处理这些繁琐的细节。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144278719",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 882,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144278719",
        "postTime": "2024-12-05 23:55:15",
        "diggCount": 7,
        "formatTime": "2024.12.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/00bbd588c7f54813abc8f1a8a37d9e65.png"
        ],
        "collectCount": 10,
        "tags": [
          "spring",
          "guava",
          "数据库"
        ]
      },
      {
        "articleId": 144253043,
        "title": "Guava Table：多维度的数据 Table3",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144253043",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 394,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253043",
        "postTime": "2024-12-04 23:39:44",
        "diggCount": 5,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 9,
        "tags": [
          "junit"
        ]
      },
      {
        "articleId": 144252951,
        "title": "Guava Table：多维度的数据 Table1",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144252951",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 394,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144252951",
        "postTime": "2024-12-04 23:39:23",
        "diggCount": 3,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 10,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253029,
        "title": "Guava Table：多维度的数据 Table2",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144253029",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 371,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253029",
        "postTime": "2024-12-04 23:39:18",
        "diggCount": 5,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 9,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144252980,
        "title": "Guava Table：多维度的数据 Table5",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144252980",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 313,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144252980",
        "postTime": "2024-12-04 23:39:06",
        "diggCount": 4,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 7,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253028,
        "title": "Guava Table：多维度的数据 Table6",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144253028",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 288,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253028",
        "postTime": "2024-12-04 23:39:02",
        "diggCount": 3,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 4,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144252992,
        "title": "Guava Table：多维度的数据 Table7",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144252992",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 402,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/144252992",
        "postTime": "2024-12-04 23:38:56",
        "diggCount": 4,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 8,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144252993,
        "title": "Guava Table：多维度的数据 Table8",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144252993",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 293,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144252993",
        "postTime": "2024-12-04 23:38:50",
        "diggCount": 3,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 8,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253016,
        "title": "Guava Table：多维度的数据 Table9",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144253016",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 379,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253016",
        "postTime": "2024-12-04 23:38:46",
        "diggCount": 3,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 7,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144253008,
        "title": "Guava Table：多维度的数据 Table10",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144253008",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 471,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144253008",
        "postTime": "2024-12-04 23:36:59",
        "diggCount": 9,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 4,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144252964,
        "title": "Guava Table：多维度的数据 Table11",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144252964",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 383,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144252964",
        "postTime": "2024-12-04 23:36:54",
        "diggCount": 3,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 10,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144252930,
        "title": "Guava Table：多维度的数据 Table12",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144252930",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 299,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144252930",
        "postTime": "2024-12-04 23:33:33",
        "diggCount": 5,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 6,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144252916,
        "title": "Guava Table：多维度的数据 Table13",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144252916",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 615,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144252916",
        "postTime": "2024-12-04 23:33:29",
        "diggCount": 14,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 10,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144252904,
        "title": "Guava Table：多维度的数据 Table14",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144252904",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 484,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144252904",
        "postTime": "2024-12-04 23:33:25",
        "diggCount": 7,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 9,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 144252889,
        "title": "Guava Table：多维度的数据 Table15",
        "description": "本身是二维的，但通过合理的设计，能够扩展其功能，支持三维甚至四维的数据存储和查询。这种方法能够让我们在复杂的数据模型中进行更多维度的索引和查询，适合多维数据分析和处理的场景。中进一步进行分组和索引，想要为每一个维度增加一个标识（比如多重索引），那么我们就需要更复杂的。的嵌套和多重索引功能，我们可以轻松实现多维度数据的管理。举个例子，如果我们想表示一个多维度的时间序列数据，我们可以将。如果你想要在多维度的数据结构中进行查询或遍历，可以使用嵌套的。的每个单元格进一步封装和索引，从而实现多维度的数据管理。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/144252889",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 503,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/144252889",
        "postTime": "2024-12-04 23:33:20",
        "diggCount": 14,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/cacba8c23c124c2a8f8764a0ec906611.png"
        ],
        "collectCount": 10,
        "tags": [
          "guava",
          "windows",
          "数据库"
        ]
      },
      {
        "articleId": 140862407,
        "title": "决战超越并发瓶颈---解决并发难题",
        "description": "硬件指令cmpxchgl结合lock前缀保证了在多处理器环境下的原子性，即整个比较和替换操作是不可分割的，这就是 CAS 操作能够实现原子性的原因。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140862407",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 869,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/140862407",
        "postTime": "2024-12-04 10:07:35",
        "diggCount": 19,
        "formatTime": "2024.12.04",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/2ff0428f5921a85e8377a04f590a7d3a.png"
        ],
        "collectCount": 29,
        "tags": [
          "服务器",
          "运维"
        ]
      },
      {
        "articleId": 142070064,
        "title": "案例分析：并行计算让代码“飞”起来12",
        "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142070064",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1279,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142070064",
        "postTime": "2024-09-09 21:41:07",
        "diggCount": 25,
        "formatTime": "2024.09.09",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
        ],
        "collectCount": 24,
        "tags": [
          "servlet"
        ]
      },
      {
        "articleId": 142070036,
        "title": "案例分析：并行计算让代码“飞”起来11",
        "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142070036",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1263,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142070036",
        "postTime": "2024-09-09 21:40:18",
        "diggCount": 8,
        "formatTime": "2024.09.09",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
        ],
        "collectCount": 15,
        "tags": [
          "mybatis"
        ]
      },
      {
        "articleId": 142070008,
        "title": "案例分析：并行计算让代码“飞”起来10",
        "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142070008",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1657,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142070008",
        "postTime": "2024-09-09 21:38:52",
        "diggCount": 23,
        "formatTime": "2024.09.09",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
        ],
        "collectCount": 25,
        "tags": [
          "sentinel"
        ]
      },
      {
        "articleId": 142069977,
        "title": "案例分析：并行计算让代码“飞”起来9",
        "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069977",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1682,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142069977",
        "postTime": "2024-09-09 21:37:21",
        "diggCount": 29,
        "formatTime": "2024.09.09",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
        ],
        "collectCount": 25,
        "tags": [
          "java-consul"
        ]
      },
      {
        "articleId": 142069962,
        "title": "案例分析：并行计算让代码“飞”起来8",
        "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069962",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1424,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/142069962",
        "postTime": "2024-09-09 21:36:41",
        "diggCount": 13,
        "formatTime": "2024.09.09",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
        ],
        "collectCount": 19,
        "tags": [
          "junit"
        ]
      },
      {
        "articleId": 142069939,
        "title": "案例分析：并行计算让代码“飞”起来7",
        "description": "Java 提供了非常丰富的 API，来支持多线程开发。对我们 Java 程序员来说，。但它如何应用到业务场景中？又有哪些注意事项？本课时将从一个并行获取数据的例子开始，逐步讲解这个面试中最频繁的知识点。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/142069939",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1732,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/142069939",
        "postTime": "2024-09-09 21:35:29",
        "diggCount": 26,
        "formatTime": "2024.09.09",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/3320627a1140464e8576b61571e11c7a.png"
        ],
        "collectCount": 16,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 141930420,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图11",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930420",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1666,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930420",
        "postTime": "2024-09-05 14:34:57",
        "diggCount": 23,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 8,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141930406,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图10",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930406",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1678,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930406",
        "postTime": "2024-09-05 14:34:21",
        "diggCount": 20,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 13,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141930363,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图9",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930363",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1428,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930363",
        "postTime": "2024-09-05 14:33:05",
        "diggCount": 19,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 12,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141930319,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图8",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930319",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1274,
        "commentCount": 4,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930319",
        "postTime": "2024-09-05 14:31:54",
        "diggCount": 8,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 9,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141930280,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图7",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930280",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1284,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930280",
        "postTime": "2024-09-05 14:30:40",
        "diggCount": 10,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 9,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141930228,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图6",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930228",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1608,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930228",
        "postTime": "2024-09-05 14:29:32",
        "diggCount": 20,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 19,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141930170,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图5",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930170",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1005,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930170",
        "postTime": "2024-09-05 14:28:01",
        "diggCount": 4,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 4,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141930137,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图4",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930137",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1310,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930137",
        "postTime": "2024-09-05 14:26:57",
        "diggCount": 29,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 14,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141930086,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图3",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930086",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1741,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930086",
        "postTime": "2024-09-05 14:25:31",
        "diggCount": 9,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 18,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141930028,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图2",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930028",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 2656,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930028",
        "postTime": "2024-09-05 14:24:22",
        "diggCount": 38,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 47,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141930014,
        "title": "深入 Spring BeanFactory：高级配置和扩展能力的全景视图1",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141930014",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1658,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/141930014",
        "postTime": "2024-09-05 14:23:52",
        "diggCount": 24,
        "formatTime": "2024.09.05",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 8,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 141833637,
        "title": "K 个一组翻转链表12",
        "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833637",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1195,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141833637",
        "postTime": "2024-09-03 00:57:06",
        "diggCount": 24,
        "formatTime": "2024.09.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
        ],
        "collectCount": 19,
        "tags": [
          "链表"
        ]
      },
      {
        "articleId": 141833629,
        "title": "K 个一组翻转链表11",
        "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833629",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1496,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141833629",
        "postTime": "2024-09-03 00:55:47",
        "diggCount": 5,
        "formatTime": "2024.09.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
        ],
        "collectCount": 5,
        "tags": [
          "链表",
          "数据结构",
          "开发语言"
        ]
      },
      {
        "articleId": 141833621,
        "title": "K 个一组翻转链表10",
        "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833621",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1521,
        "commentCount": 4,
        "editUrl": "https://mp.csdn.net/console/editor/html/141833621",
        "postTime": "2024-09-03 00:54:02",
        "diggCount": 5,
        "formatTime": "2024.09.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
        ],
        "collectCount": 11,
        "tags": [
          "链表",
          "数据结构",
          "开发语言"
        ]
      },
      {
        "articleId": 141833619,
        "title": "K 个一组翻转链表9",
        "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833619",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1601,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141833619",
        "postTime": "2024-09-03 00:53:28",
        "diggCount": 6,
        "formatTime": "2024.09.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
        ],
        "collectCount": 20,
        "tags": [
          "链表",
          "数据结构",
          "开发语言"
        ]
      },
      {
        "articleId": 141833600,
        "title": "K 个一组翻转链表7",
        "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833600",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1441,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141833600",
        "postTime": "2024-09-03 00:49:19",
        "diggCount": 9,
        "formatTime": "2024.09.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
        ],
        "collectCount": 8,
        "tags": [
          "开发语言",
          "链表"
        ]
      },
      {
        "articleId": 141833591,
        "title": "K 个一组翻转链表6",
        "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833591",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1492,
        "commentCount": 4,
        "editUrl": "https://mp.csdn.net/console/editor/html/141833591",
        "postTime": "2024-09-03 00:47:53",
        "diggCount": 13,
        "formatTime": "2024.09.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
        ],
        "collectCount": 12,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141833586,
        "title": "K 个一组翻转链表5",
        "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833586",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1241,
        "commentCount": 3,
        "editUrl": "https://mp.csdn.net/console/editor/html/141833586",
        "postTime": "2024-09-03 00:47:19",
        "diggCount": 8,
        "formatTime": "2024.09.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
        ],
        "collectCount": 6,
        "tags": [
          "链表"
        ]
      },
      {
        "articleId": 141833571,
        "title": "K 个一组翻转链表4",
        "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833571",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1239,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141833571",
        "postTime": "2024-09-03 00:44:37",
        "diggCount": 15,
        "formatTime": "2024.09.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
        ],
        "collectCount": 19,
        "tags": [
          "链表"
        ]
      },
      {
        "articleId": 141833568,
        "title": "K 个一组翻转链表3",
        "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141833568",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1705,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141833568",
        "postTime": "2024-09-03 00:44:00",
        "diggCount": 5,
        "formatTime": "2024.09.03",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a4b1496432aa4a78833438922eaab1c2.png"
        ],
        "collectCount": 12,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141789887,
        "title": "K 个一组翻转链表",
        "description": "迭代方法的基本思路是，每 k 个节点为一组进行翻转，如果剩余节点不足 k 个，则保持原有顺序不变。具体实现时，需要使用 3 个指针：pre、end 和 next，其中 pre 表示待翻转区域的前驱节点，end 表示待翻转区域的后继节点，next 则是遍历链表的指针。输入：head = [1,2,3,4,5], k = 3                     输出：[3,2,1,4,5]示例：输入：head = [1,2,3,4,5], k = 2.         输出：[2,1,4,3,5]",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789887",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1526,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141789887",
        "postTime": "2024-09-01 21:11:06",
        "diggCount": 23,
        "formatTime": "2024.09.01",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/199c91d1c9016a16ca7651d09a3c7448.png"
        ],
        "collectCount": 8,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141790021,
        "title": "删除链表中的重复元素II",
        "description": "示例 3:输入:1->2 ->2 ->2 ->5 ->2 ->3 ->3 ->9,输出1 ->5 ->2 ->9。给定一个排序链表（默认正整数），删除所有含有重复数字的节点，只保留原始链表中没有重复出现的数字。一个指针用于表示当前已处理的部分，另一个指针用于遍历链表。最优解法是使用迭代的方法，在一次遍历中删除连续重复的元素，同时保持空间复杂度为 O(1)。示例 2:输入: 1->1->2->3->3.          输出:  2。示例 1:输入:1->1->2->2->3->4->4 输出：3。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141790021",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1252,
        "commentCount": 3,
        "editUrl": "https://mp.csdn.net/console/editor/html/141790021",
        "postTime": "2024-09-01 21:10:16",
        "diggCount": 4,
        "formatTime": "2024.09.01",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/199c91d1c9016a16ca7651d09a3c7448.png"
        ],
        "collectCount": 9,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141790001,
        "title": "排序链表排序链表",
        "description": "最优解法是使用归并排序（Merge Sort），将链表分成两个子链表进行排序，然后合并两个已排序的子链表。示例 2：输入：head = [-1,5,3,4,0].     输出：[-1,0,3,4,5]示例 1：输入：head = [4,2,1,3].         输出：[1,2,3,4]示例 3：输入：head = [].                    输出：[]进阶：你可以在 O(nlogn) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141790001",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1200,
        "commentCount": 4,
        "editUrl": "https://mp.csdn.net/console/editor/html/141790001",
        "postTime": "2024-09-01 21:10:12",
        "diggCount": 13,
        "formatTime": "2024.09.01",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/199c91d1c9016a16ca7651d09a3c7448.png"
        ],
        "collectCount": 4,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141789984,
        "title": "删除链表中的重复元素I",
        "description": "需要注意的是，因为头节点可能会被删除，因此可以添加一个哨兵节点作为头节点，这样就不用单独考虑头节点的情况。示例 2:输入: 1->1->2->3->3.          输出: 1->2->3。最优的解法是使用双指针，遍历整个链表，如果发现有相邻节点的值相同，就将其中一个节点删除。示例 1:输入: 1->1->2.       输出: 1->2。给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。时间复杂度为O(n)，空间复杂度为O(1)。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789984",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1002,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141789984",
        "postTime": "2024-09-01 21:08:33",
        "diggCount": 10,
        "formatTime": "2024.09.01",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/199c91d1c9016a16ca7651d09a3c7448.png"
        ],
        "collectCount": 5,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141789970,
        "title": "两个链表的第一个公共节点",
        "description": "给定两个单链表，判断两个链表是否相交。若相交，返回相交的起始节点。若不相交，返回 null。可以假定整个链表结构中没有循环。时间复杂度为 O(m+n)，其中m和n分别为两个链表的长度。注意，函数返回结果后，链表必须保持其原始结构。from：两个链表的第一个公共节点。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789970",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 988,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141789970",
        "postTime": "2024-09-01 21:07:52",
        "diggCount": 1,
        "formatTime": "2024.09.01",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/199c91d1c9016a16ca7651d09a3c7448.png"
        ],
        "collectCount": 2,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141789957,
        "title": "合并两个有序链表",
        "description": "首先，我们定义一个新的链表作为合并后的链表，然后设置两个指针分别指向两个原始链表的头节点。我们每次比较两个指针指向节点的值，将较小的节点加入新的链表中，并将指针后移一位。重复这个过程，直到某一个指针为空，此时我们将另一个链表剩下的部分全部加入新链表中即可。示例:输入：1->2->4, 1->3->4.      输出：1->1->2->3->4->4。合并两个有序链表，返回一个新的链表，新链表是这两个链表中的所有节点按照从小到大的顺序排列而成。from：合并两个有序链表。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789957",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1348,
        "commentCount": 4,
        "editUrl": "https://mp.csdn.net/console/editor/html/141789957",
        "postTime": "2024-09-01 21:07:46",
        "diggCount": 19,
        "formatTime": "2024.09.01",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/199c91d1c9016a16ca7651d09a3c7448.png"
        ],
        "collectCount": 6,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141789937,
        "title": "链表的中间节点",
        "description": "使用两个指针，一个快指针和一个慢指针，快指针每次移动两个节点，慢指针每次移动一个节点，当快指针到达链表末尾时，慢指针就指向链表的中间节点。这个算法的时间复杂度为O(n)，其中n为链表的长度，空间复杂度为O(1)，只需要两个指针的空间。的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。提示：给定链表的结点数介于。最优的解法是快慢指针法。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789937",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1040,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141789937",
        "postTime": "2024-09-01 21:06:54",
        "diggCount": 7,
        "formatTime": "2024.09.01",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/199c91d1c9016a16ca7651d09a3c7448.png"
        ],
        "collectCount": 2,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141789921,
        "title": "删除链表中倒数第K个节点",
        "description": "最优的解法是使用快慢指针，快指针先走n步，然后快慢指针一起走，当快指针到达链表末尾时，慢指针就是要删除的节点的前一个节点。接着，通过改变指针的指向，将慢指针指向的节点删除即可。示例：输入：head = [1,2,3,4,5], n = 2.       输出：[1,2,3,5]你一个链表，删除链表中倒数第 n 个节点，并且返回链表的头结点。需要注意的是，如果要删除的是头节点，需要特殊处理。时间复杂度为O(n)，空间复杂度为O(1)。from：删除链表中倒数第K个节点。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789921",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1019,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/141789921",
        "postTime": "2024-09-01 21:05:21",
        "diggCount": 5,
        "formatTime": "2024.09.01",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/199c91d1c9016a16ca7651d09a3c7448.png"
        ],
        "collectCount": 2,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141789875,
        "title": "链表中环的检测",
        "description": "在这个算法中，时间复杂度是 O(n)，空间复杂度是 O(1)，因为只使用了两个指针来遍历链表，没有使用额外的数据结构来存储中间结果。判断链表中是否有环的高效最优解法是使用快慢指针，也称为龟兔赛跑算法。进阶：你能否不使用额外空间解决此题？给定一个链表，判断链表中是否有环。from：链表中环的检测。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789875",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1093,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141789875",
        "postTime": "2024-09-01 21:03:25",
        "diggCount": 15,
        "formatTime": "2024.09.01",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/199c91d1c9016a16ca7651d09a3c7448.png"
        ],
        "collectCount": 4,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 141789840,
        "title": "反转链表（Reverse Linked List）",
        "description": "该算法的时间复杂度为 O(n)，其中 n 是链表的长度，空间复杂度为 O(1)。输出: 5->4->3->2->1->NULL。对于反转链表这道题目，其高效最优解法是使用迭代实现。进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？示例：输入: 1->2->3->4->5->NULL。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/141789840",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1048,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/141789840",
        "postTime": "2024-09-01 21:01:24",
        "diggCount": 3,
        "formatTime": "2024.09.01",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/cover/199c91d1c9016a16ca7651d09a3c7448.png"
        ],
        "collectCount": 3,
        "tags": [
          "链表",
          "数据结构"
        ]
      },
      {
        "articleId": 140906011,
        "title": "深入Spring BeanFactory：构建健壮的Spring应用架构",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140906011",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1495,
        "commentCount": 4,
        "editUrl": "https://mp.csdn.net/console/editor/html/140906011",
        "postTime": "2024-08-04 14:40:25",
        "diggCount": 14,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/5c5077c5c17445adb170a83464bf6207.png"
        ],
        "collectCount": 29,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140906002,
        "title": "探索Spring BeanFactory：高级配置与扩展能力",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140906002",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1414,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140906002",
        "postTime": "2024-08-04 14:39:44",
        "diggCount": 22,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/979e46784dd84273b26add8cb0d8ee4d.png"
        ],
        "collectCount": 20,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140905994,
        "title": "理解Spring BeanFactory：从实例创建到依赖注入",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905994",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1480,
        "commentCount": 3,
        "editUrl": "https://mp.csdn.net/console/editor/html/140905994",
        "postTime": "2024-08-04 14:38:57",
        "diggCount": 23,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/e0d59f35ca2242eeb3ed71ef4a4e9fac.png"
        ],
        "collectCount": 15,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140905837,
        "title": "深入解析Spring BeanFactory：核心概念与最佳实践",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905837",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1249,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140905837",
        "postTime": "2024-08-04 14:37:48",
        "diggCount": 16,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/e414f443afb747049bb95942b76ecc54.png"
        ],
        "collectCount": 14,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140905983,
        "title": "Spring BeanFactory内幕：深入探讨其架构与设计模式",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905983",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1353,
        "commentCount": 3,
        "editUrl": "https://mp.csdn.net/console/editor/html/140905983",
        "postTime": "2024-08-04 14:37:35",
        "diggCount": 22,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/dbf7817060a8450eaeb8699803b79e03.png"
        ],
        "collectCount": 9,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140905881,
        "title": "掌握Spring BeanFactory：从基础到高级应用",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905881",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1418,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140905881",
        "postTime": "2024-08-04 14:37:20",
        "diggCount": 24,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/d23006cc55b248778e02da546bbf34d2.png"
        ],
        "collectCount": 10,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140905889,
        "title": "揭秘Spring BeanFactory：理解其工作原理与使用技巧",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905889",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1334,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140905889",
        "postTime": "2024-08-04 14:36:54",
        "diggCount": 30,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/8efdb489d8ca47cd85e49ab62b2f5835.png"
        ],
        "collectCount": 26,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140905901,
        "title": "Spring框架核心：BeanFactory的深度剖析与实战指南",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905901",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1557,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140905901",
        "postTime": "2024-08-04 14:36:29",
        "diggCount": 14,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/8751d6f3d47143ef83f2605ffe0764c4.png"
        ],
        "collectCount": 11,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140905965,
        "title": "Spring BeanFactory全解析：如何优化你的Spring应用",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905965",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1488,
        "commentCount": 1,
        "editUrl": "https://mp.csdn.net/console/editor/html/140905965",
        "postTime": "2024-08-04 14:36:00",
        "diggCount": 28,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/b4327c5a6b574f4488696ea1feeb03e4.png"
        ],
        "collectCount": 29,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 140905958,
        "title": "从零开始学Spring BeanFactory：快速上手与高效应用",
        "description": "接口提供了一些方法来配置 Bean 工厂的行为和属性，使得我们可以动态地管理和调整 Bean 工厂的配置，从而更好地满足应用程序的需求。通过对 Bean 工厂的配置，可以实现更灵活、更定制化的 Bean 管理方式。",
        "url": "https://blog.csdn.net/tianshu11tianshu/article/details/140905958",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1444,
        "commentCount": 2,
        "editUrl": "https://mp.csdn.net/console/editor/html/140905958",
        "postTime": "2024-08-04 14:35:07",
        "diggCount": 28,
        "formatTime": "2024.08.04",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a7b0051914ca46f8a136769ccfd90799.png"
        ],
        "collectCount": 23,
        "tags": [
          "java",
          "开发语言"
        ]
      }
    ]
  },
  {
    "articleCreaterNum": "19284430302",
    "articleInfos": [
      {
        "articleId": 146438056,
        "title": "电商敏感词技术：筑牢合规经营的防线",
        "description": "在电商行业蓬勃发展的当下，网络购物成为人们日常生活中不可或缺的一部分。据相关数据显示，过去一年我国网络零售额达到了 [X] 万亿元，同比增长 [X]%。然而，在这片繁荣背后，电商平台面临着诸多挑战，其中敏感词管理便是一个不容忽视的重要问题。电商敏感词技术作为维护平台秩序、保障合规经营的关键手段，正发挥着日益重要的作用。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146438056",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 0,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146438056",
        "postTime": "2025-03-22 12:46:30",
        "diggCount": 0,
        "formatTime": "6 分钟前",
        "picList": [],
        "collectCount": 0,
        "tags": [
          "需求分析"
        ]
      },
      {
        "articleId": 146438046,
        "title": "深度剖析电商敏感词技术的核心算法与原理",
        "description": "在电商行业，信息传播的准确性与合规性至关重要。电商敏感词技术作为维护平台生态的重要工具，其背后复杂而精妙的核心算法与原理，如同精密齿轮推动着整个系统的有序运转。深入探究这些算法与原理，有助于我们理解电商平台如何在海量数据中精准识别敏感词汇，保障平台的健康发展。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146438046",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 0,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146438046",
        "postTime": "2025-03-22 12:45:56",
        "diggCount": 0,
        "formatTime": "6 分钟前",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/671f42ab07fd990f949a1c903140dd83.png"
        ],
        "collectCount": 0,
        "tags": [
          "大数据",
          "人工智能"
        ]
      },
      {
        "articleId": 146438041,
        "title": "电商敏感词技术在不同平台的应用差异对比",
        "description": "在数字化商业浪潮中，电商平台已成为经济发展的重要驱动力。然而，维护平台内容的合规性与健康生态始终是各大平台面临的关键挑战，电商敏感词技术因此成为平台运营的重要保障。但由于不同平台的业务模式、用户群体、市场定位等存在差异，敏感词技术在应用过程中也呈现出诸多不同之处。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146438041",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 153,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146438041",
        "postTime": "2025-03-22 12:45:23",
        "diggCount": 6,
        "formatTime": "7 分钟前",
        "picList": [],
        "collectCount": 1,
        "tags": [
          "需求分析"
        ]
      },
      {
        "articleId": 146438030,
        "title": "新兴趋势：AI 驱动下电商敏感词技术的革新",
        "description": "在当今电商行业蓬勃发展的时代，海量信息在平台上高速流转。从商品描述、用户评价到广告推广，每一个环节都可能隐藏着敏感词，威胁着平台的合规运营、用户体验以及品牌声誉。随着人工智能（AI）技术的迅猛发展，它正深刻地革新着电商敏感词技术，为电商行业带来前所未有的变革与机遇。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146438030",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 0,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146438030",
        "postTime": "2025-03-22 12:44:32",
        "diggCount": 0,
        "formatTime": "8 分钟前",
        "picList": [],
        "collectCount": 0,
        "tags": [
          "需求分析"
        ]
      },
      {
        "articleId": 146438020,
        "title": "电商敏感词技术如何助力品牌形象维护",
        "description": "在竞争激烈的电商领域，品牌形象宛如企业的生命线，是吸引消费者、建立忠诚度的关键因素。然而，电商平台上信息的快速传播与海量特性，给品牌形象维护带来诸多挑战。电商敏感词技术犹如一位忠诚的卫士，通过对平台内容的严格把控，在多个关键维度助力企业维护良好的品牌形象。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146438020",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 0,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146438020",
        "postTime": "2025-03-22 12:43:51",
        "diggCount": 0,
        "formatTime": "8 分钟前",
        "picList": [],
        "collectCount": 0,
        "tags": [
          "需求分析"
        ]
      },
      {
        "articleId": 146438013,
        "title": "应对海量数据：电商敏感词技术的效率优化策略",
        "description": "在电商行业，数据量呈爆炸式增长。每天，各大电商平台产生数以亿计的商品描述、用户评论、广告文案等文本信息。在这些海量数据中准确且高效地识别敏感词，成为电商敏感词技术面临的重大挑战。为保障平台合规运营、维护良好用户体验，一系列效率优化策略应运而生。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146438013",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 119,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146438013",
        "postTime": "2025-03-22 12:43:20",
        "diggCount": 3,
        "formatTime": "9 分钟前",
        "picList": [],
        "collectCount": 2,
        "tags": [
          "需求分析"
        ]
      },
      {
        "articleId": 146438010,
        "title": "电商敏感词技术对消费者体验的潜在影响",
        "description": "在电商行业蓬勃发展的当下，消费者体验已成为决定平台竞争力的关键因素。电商敏感词技术作为平台运营的重要保障，虽主要目的在于维护平台秩序与合规性，但其对消费者体验亦有着不可忽视的潜在影响，从搜索结果呈现、商品信息获取到互动交流，全方位塑造着消费者在电商平台的购物旅程。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146438010",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 25,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146438010",
        "postTime": "2025-03-22 12:42:49",
        "diggCount": 0,
        "formatTime": "9 分钟前",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/3910fb44ecc92552611c1f642b4625fc.png"
        ],
        "collectCount": 1,
        "tags": [
          "大数据"
        ]
      },
      {
        "articleId": 146438004,
        "title": "跨境电商中的敏感词技术：挑战与应对",
        "description": "在全球化电商浪潮的推动下，跨境电商蓬勃发展，为各国消费者与商家搭建起便捷的交易桥梁。然而，与国内电商相比，跨境电商面临着更为复杂的语言、文化及法规环境，敏感词技术在其中遭遇诸多独特挑战，亟需针对性的应对策略。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146438004",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 68,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146438004",
        "postTime": "2025-03-22 12:42:16",
        "diggCount": 3,
        "formatTime": "10 分钟前",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/671f42ab07fd990f949a1c903140dd83.png"
        ],
        "collectCount": 1,
        "tags": [
          "人工智能"
        ]
      },
      {
        "articleId": 146437995,
        "title": "从法律视角解读电商敏感词技术的必要性",
        "description": "在电商行业蓬勃发展的当下，网络交易成为经济增长的重要驱动力。然而，随着电商业务的扩张，各类法律风险也随之而来。电商敏感词技术作为维护电商平台合规运营的关键手段，从法律视角来看，具有不可忽视的必要性。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146437995",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 145,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146437995",
        "postTime": "2025-03-22 12:41:38",
        "diggCount": 1,
        "formatTime": "11 分钟前",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/3910fb44ecc92552611c1f642b4625fc.png"
        ],
        "collectCount": 6,
        "tags": [
          "大数据"
        ]
      },
      {
        "articleId": 146437991,
        "title": "电商敏感词技术与精准营销的微妙平衡",
        "description": "在电商领域，精准营销已成为企业提升竞争力、扩大市场份额的重要手段。它通过对消费者数据的深入分析，精准推送符合消费者需求的商品和服务，提高营销效果和转化率。然而，电商敏感词技术作为保障平台合规运营的关键工具，在与精准营销协同作用时，呈现出一种微妙的平衡关系。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146437991",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 50,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146437991",
        "postTime": "2025-03-22 12:41:05",
        "diggCount": 1,
        "formatTime": "11 分钟前",
        "picList": [],
        "collectCount": 4,
        "tags": [
          "需求分析"
        ]
      },
      {
        "articleId": 146437985,
        "title": "传统与现代电商敏感词技术的发展脉络梳理",
        "description": "在电商行业的发展历程中，敏感词技术从基础起步逐步迈向智能化、高效化，其发展脉络紧密贴合电商业务的扩张以及信息技术的革新。清晰梳理这一发展脉络，有助于深入理解敏感词技术在不同阶段的特点、应用成效及面临的挑战，为把握未来发展方向提供参考。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146437985",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 161,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146437985",
        "postTime": "2025-03-22 12:40:34",
        "diggCount": 1,
        "formatTime": "12 分钟前",
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/671f42ab07fd990f949a1c903140dd83.png"
        ],
        "collectCount": 1,
        "tags": [
          "人工智能",
          "大数据"
        ]
      },
      {
        "articleId": 146437976,
        "title": "基于大数据分析的电商敏感词动态监测技术",
        "description": "在电商行业蓬勃发展的当下，信息传播的速度与规模达到了前所未有的程度。从海量的商品描述、用户评论到铺天盖地的广告宣传，每一个环节都可能隐藏着敏感词，对平台的合规运营、品牌形象以及用户体验构成潜在威胁。基于大数据分析的电商敏感词动态监测技术应运而生，成为电商平台维护健康生态的有力武器。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146437976",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 109,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146437976",
        "postTime": "2025-03-22 12:40:03",
        "diggCount": 1,
        "formatTime": "12 分钟前",
        "picList": [],
        "collectCount": 1,
        "tags": [
          "需求分析"
        ]
      },
      {
        "articleId": 146437967,
        "title": "电商敏感词技术在防范舆情风险中的关键作用",
        "description": "在当今数字化的电商环境中，信息传播的速度和广度超乎想象，舆情风险如影随形，时刻威胁着电商平台和商家的声誉与利益。电商敏感词技术作为一种高效且精准的监测与防控手段，在防范舆情风险方面发挥着不可替代的关键作用。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146437967",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 182,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146437967",
        "postTime": "2025-03-22 12:39:32",
        "diggCount": 1,
        "formatTime": "13 分钟前",
        "picList": [],
        "collectCount": 3,
        "tags": [
          "需求分析"
        ]
      },
      {
        "articleId": 146437963,
        "title": "中小企业应用电商敏感词技术的难点与突破",
        "description": "在电商领域蓬勃发展的浪潮中，中小企业纷纷投身其中，期望借助互联网拓展业务版图。然而，随着电商平台对内容合规性要求日益严格，敏感词管理成为中小企业面临的重要挑战。电商敏感词技术虽能有效保障平台秩序，但中小企业在应用过程中遭遇诸多难点，亟需探索突破之道。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146437963",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 141,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146437963",
        "postTime": "2025-03-22 12:39:01",
        "diggCount": 1,
        "formatTime": "13 分钟前",
        "picList": [],
        "collectCount": 1,
        "tags": [
          "需求分析"
        ]
      },
      {
        "articleId": 146437948,
        "title": "未来展望：电商敏感词技术的发展方向与前景",
        "description": "在数字化浪潮的席卷下，电商行业持续高速发展，电商敏感词技术作为维护行业秩序与健康生态的关键力量，也将迎来一系列深刻变革。展望未来，电商敏感词技术在技术创新、应用场景拓展以及行业协作等方面将展现出令人期待的发展方向与广阔前景。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146437948",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 151,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146437948",
        "postTime": "2025-03-22 12:38:12",
        "diggCount": 1,
        "formatTime": "14 分钟前",
        "picList": [],
        "collectCount": 2,
        "tags": [
          "单例模式"
        ]
      },
      {
        "articleId": 146359854,
        "title": "深入剖析单例模式：基础概念与核心原理",
        "description": "单例模式，简单来说，就是保证一个类在整个系统中只有一个实例，并提供一个全局访问点来获取这个实例。想象一下，在一个城市中，消防指挥中心是独一无二的，无论火灾发生在何处，所有的消防资源调配指令都从这个中心发出。在软件系统里，单例模式就如同这个消防指挥中心，它确保特定的类只有一个实例存在，避免了资源的重复创建和不必要的开销。从实现角度看，单例模式主要包含两个关键要点：一是构造函数必须是私有的，这就好比给类的实例化大门上了一把锁，防止外部随意创建对象；",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359854",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 218,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359854",
        "postTime": "2025-03-19 09:03:47",
        "diggCount": 3,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 4,
        "tags": [
          "单例模式"
        ]
      },
      {
        "articleId": 146359834,
        "title": "单例模式在不同编程语言中的实现差异对比",
        "description": "线程安全：Java 中饿汉式天生线程安全，懒汉式需额外处理；Python 使用模块和元类实现单例天然线程安全，装饰器实现需注意线程安全问题；C++11 的局部静态变量实现饿汉式线程安全，懒汉式线程安全实现需借助锁机制。实现复杂度：Java 实现方式多样，各有优劣，DCL 实现相对复杂；Python 使用模块实现最简单，元类和装饰器实现稍复杂；C++ 实现需处理内存管理和拷贝构造、赋值操作，代码量相对较多。应用场景：Java 适合大型企业级应用开发，根据不同场景选择合适实现；",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359834",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 593,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359834",
        "postTime": "2025-03-19 09:02:51",
        "diggCount": 15,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 17,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 146359819,
        "title": "单例模式的线程安全问题全解析与解决方案",
        "description": "在软件开发中，单例模式因能确保类仅有一个实例并提供全局访问点而被广泛应用。但在多线程环境下，单例模式的线程安全问题凸显，处理不当会导致程序出现多个实例，破坏单例模式的初衷，进而引发数据不一致等严重问题。本文将深入剖析单例模式的线程安全问题，并给出全面的解决方案。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359819",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 632,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359819",
        "postTime": "2025-03-19 09:02:11",
        "diggCount": 15,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 7,
        "tags": [
          "单例模式"
        ]
      },
      {
        "articleId": 146359800,
        "title": "从实际案例看单例模式如何优化软件架构",
        "description": "在软件开发领域，设计模式是提升软件质量、优化架构的有力工具，单例模式便是其中之一。它看似简单，却能在实际项目中发挥巨大作用，有效优化软件架构，提升系统的稳定性、可维护性与性能。接下来，我们将通过几个具体案例，深入探讨单例模式如何优化软件架构。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359800",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 238,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359800",
        "postTime": "2025-03-19 09:01:36",
        "diggCount": 5,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 6,
        "tags": [
          "单例模式"
        ]
      },
      {
        "articleId": 146359788,
        "title": "单例模式的懒汉式与饿汉式：优缺点深度剖析",
        "description": "在设计模式的领域中，单例模式作为一种常用的创建型模式，有着多种实现方式，其中懒汉式和饿汉式最为典型。这两种方式在创建单例实例的时机和特性上存在明显差异，各自具备独特的优缺点。深入了解它们，有助于开发者在不同场景下做出更合适的技术选型。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359788",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 596,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359788",
        "postTime": "2025-03-19 09:00:45",
        "diggCount": 8,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 6,
        "tags": [
          "单例模式"
        ]
      },
      {
        "articleId": 146359781,
        "title": "单例模式在大型项目中的应用场景与最佳实践",
        "description": "在大型项目开发中，软件架构的合理性与高效性至关重要。单例模式作为一种经典设计模式，凭借其独特优势，在诸多关键领域发挥着重要作用，为大型项目的稳定运行和高效开发提供了有力支持。本文将深入探讨单例模式在大型项目中的应用场景与最佳实践。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359781",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 320,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359781",
        "postTime": "2025-03-19 09:00:06",
        "diggCount": 4,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 6,
        "tags": [
          "开发语言",
          "单例模式"
        ]
      },
      {
        "articleId": 146359762,
        "title": "如何通过反射机制打破单例模式及应对策略",
        "description": "在软件开发中，单例模式致力于确保一个类仅有唯一实例，并提供全局访问点。然而，强大的反射机制却能打破这种看似坚固的限制，对单例模式的完整性构成挑战。了解如何利用反射打破单例以及相应的应对策略，对于保障程序的稳定性和安全性至关重要。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359762",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 125,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359762",
        "postTime": "2025-03-19 08:59:25",
        "diggCount": 4,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 3,
        "tags": [
          "javascript",
          "开发语言",
          "ecmascript"
        ]
      },
      {
        "articleId": 146359750,
        "title": "单例模式与依赖注入：协同工作的奥秘",
        "description": "依赖注入是一种设计模式，它通过将对象的依赖关系外部化，使对象无需自己创建依赖对象，而是由外部容器或框架提供。例如，在一个简单的 Java 应用中，有一个依赖于java// 传统方式，在类内部实例化依赖对象// 使用依赖注入，通过构造函数注入依赖对象System.out.println(\"保存用户数据\");在依赖注入的构造函数方式中，不再自己创建实例，而是通过构造函数接收外部传入的实例，这使得和之间的耦合度降低，便于测试和维护。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359750",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 248,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359750",
        "postTime": "2025-03-19 08:58:46",
        "diggCount": 3,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 6,
        "tags": [
          "单例模式"
        ]
      },
      {
        "articleId": 146359735,
        "title": "单例模式在移动应用开发中的独特优势",
        "description": "在移动应用开发领域，资源的高效利用、程序的稳定运行以及用户体验的优化是至关重要的目标。单例模式凭借其独特的特性，在移动应用开发中发挥着不可或缺的作用，为开发者解决了许多实际问题，带来了显著的优势。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359735",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 243,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359735",
        "postTime": "2025-03-19 08:58:01",
        "diggCount": 5,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 7,
        "tags": [
          "单例模式"
        ]
      },
      {
        "articleId": 146359721,
        "title": "单例模式的序列化与反序列化难题破解",
        "description": "在软件开发里，单例模式保证一个类仅有一个实例，在很多场景下都很实用。不过，当涉及对象的序列化与反序列化时，单例模式会遭遇特殊难题，处理不好就会破坏单例特性。本文会深入分析这些难题，并给出有效的破解方法。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359721",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 311,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359721",
        "postTime": "2025-03-19 08:57:20",
        "diggCount": 3,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 3,
        "tags": [
          "javascript",
          "开发语言",
          "ecmascript"
        ]
      },
      {
        "articleId": 146359706,
        "title": "基于枚举实现单例模式的独特魅力与优势",
        "description": "在设计模式的范畴中，单例模式旨在确保一个类在系统中仅有一个实例，并提供全局访问点。实现单例模式的方法众多，而基于枚举实现的单例模式以其独特的特性脱颖而出，展现出其他方式难以比拟的魅力与优势。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359706",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 278,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359706",
        "postTime": "2025-03-19 08:56:48",
        "diggCount": 5,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 4,
        "tags": [
          "javascript",
          "开发语言",
          "ecmascript"
        ]
      },
      {
        "articleId": 146359695,
        "title": "单例模式在游戏开发中的巧妙运用技巧",
        "description": "在游戏开发领域，高效的资源管理、统一的状态控制以及流畅的游戏体验是至关重要的目标。单例模式凭借其独特的特性，在游戏开发中发挥着不可替代的作用，为开发者提供了诸多巧妙的运用技巧，助力打造出更优质的游戏。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359695",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 268,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359695",
        "postTime": "2025-03-19 08:56:13",
        "diggCount": 4,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "单例模式"
        ]
      },
      {
        "articleId": 146359679,
        "title": "设计模式之单例：代码优化与性能提升策略",
        "description": "在软件开发中，单例模式虽然基础且常用，但随着项目规模扩大与业务复杂度提升，如何优化单例模式的代码、提升其性能成为关键问题。高效的单例模式能减少资源开销、增强系统稳定性，以下将详细探讨相关优化与性能提升策略。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359679",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 254,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359679",
        "postTime": "2025-03-19 08:55:30",
        "diggCount": 4,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 8,
        "tags": [
          "单例模式"
        ]
      },
      {
        "articleId": 146359667,
        "title": "单例模式在分布式系统中的挑战与应对方案",
        "description": "在分布式系统架构下，各个组件分布在不同的节点上协同工作，这给传统的单例模式带来了诸多挑战。单例模式原本确保在单个进程内一个类仅有一个实例，但在分布式环境中，要维持这种唯一性变得复杂。理解这些挑战并找到有效的应对方案，对构建稳定、高效的分布式系统至关重要。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359667",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 690,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359667",
        "postTime": "2025-03-19 08:54:52",
        "diggCount": 9,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 17,
        "tags": [
          "单例模式"
        ]
      },
      {
        "articleId": 146359650,
        "title": "未来技术趋势下，单例模式的变革与发展方向",
        "description": "在科技飞速发展的当下，软件技术领域持续革新，新兴技术不断涌现。单例模式作为经典设计模式，也会受到未来技术趋势的影响，发生变革并朝着新方向发展，以契合日益复杂的软件开发需求。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146359650",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 340,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359650",
        "postTime": "2025-03-19 08:54:11",
        "diggCount": 5,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 4,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146338307,
        "title": "K8s网络的可观测性：监控与日志分析策略",
        "description": "例如，在每个节点上部署Fluent Bit代理，它会自动发现并收集该节点上所有容器的日志，通过配置输出插件，将日志数据传输到Elasticsearch集群中进行存储和后续分析。K8s网络的可观测性依赖于有效的监控与日志分析策略。通过全面采集网络指标并进行可视化展示，以及深入分析容器日志，运维人员能够及时发现网络中的潜在问题，提前预警并快速解决故障。比如，对于一个在线游戏应用，重点关注游戏服务器与玩家客户端之间的网络延迟和丢包率，将这些指标单独展示在自定义面板上，方便运维人员实时监控游戏体验相关的网络状况。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146338307",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 247,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146338307",
        "postTime": "2025-03-18 12:25:44",
        "diggCount": 4,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/11a0f0a3457d400d8a0c9c66da98a4ed.png"
        ],
        "collectCount": 10,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146338293,
        "title": "K8s网络的IPv6支持：迈向未来网络的关键一步",
        "description": "应对策略是在部署应用前，对其进行全面的IPv6兼容性测试，对于不兼容的部分，可采用技术手段进行适配，如使用代理服务器将IPv6流量转换为IPv4流量，或者对应用代码进行修改，使其原生支持IPv6。K8s网络对IPv6的支持是迈向未来网络的重要一步，通过双栈网络模型和CNI插件适配，实现了节点、Pod和Service在IPv6网络中的通信与协同工作。同时，需要加强对IPv6网络的安全监测，利用支持IPv6的入侵检测系统（IDS）和入侵防御系统（IPS），实时监控网络流量，及时发现并应对安全威胁。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146338293",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 243,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146338293",
        "postTime": "2025-03-18 12:24:44",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/790e0c47eca74a07b18f3b0b8d5ca3d8.png"
        ],
        "collectCount": 10,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146338171,
        "title": "K8s网络与云平台的集成：AWS、Azure、GCP的实践",
        "description": "ALB自动发现后端Service关联的Pod，依据负载均衡算法转发请求，保障服务高可用，如电商网站流量高峰时，ALB高效分配流量，避免服务拥塞。而且，ENI支持多IP和多网络接口，满足复杂网络场景，像一个节点上不同服务的Pod可通过不同ENI IP通信，减少网络冲突。同时，借助GCP的网络策略功能，可对Pod间通信进行精细控制，如限制特定服务Pod间的访问，增强集群网络安全性。它直接利用Azure虚拟网络功能，为Pod分配与节点相同网段IP，实现Pod与外部网络直接通信，提升网络性能。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146338171",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 218,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146338171",
        "postTime": "2025-03-18 12:16:24",
        "diggCount": 3,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/d16cb7e4bd484132963620c400fdddb7.png"
        ],
        "collectCount": 8,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146335181,
        "title": "K8s网络与云平台的集成：AWS、Azure、GCP的实践",
        "description": "ALB自动发现后端Service关联的Pod，依据负载均衡算法转发请求，保障服务高可用，如电商网站流量高峰时，ALB高效分配流量，避免服务拥塞。而且，ENI支持多IP和多网络接口，满足复杂网络场景，像一个节点上不同服务的Pod可通过不同ENI IP通信，减少网络冲突。同时，借助GCP的网络策略功能，可对Pod间通信进行精细控制，如限制特定服务Pod间的访问，增强集群网络安全性。它直接利用Azure虚拟网络功能，为Pod分配与节点相同网段IP，实现Pod与外部网络直接通信，提升网络性能。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146335181",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 390,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146335181",
        "postTime": "2025-03-18 10:36:18",
        "diggCount": 3,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/494b9f3c083f4c36ba5005a3c0e34e21.png"
        ],
        "collectCount": 5,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146334862,
        "title": "K8s网络的多集群互联：实现跨集群通信的方案",
        "description": "以IPsec VPN为例，在每个集群的边界网关设备上配置IPsec隧道，将不同集群的网络连接起来，使得集群间的Pod和Service可以通过私有IP地址进行通信，就像在同一个局域网内一样。通过云提供商的控制台或API，用户可以方便地配置和管理集群间的网络连接，利用云平台的网络基础设施和服务，实现高效的跨集群通信。无论采用哪种方案，都需要精心规划和部署，以克服多集群互联过程中面临的挑战，实现高效、安全的跨集群通信，为企业的数字化业务发展提供有力支持。K8s网络的多集群互联：实现跨集群通信的方案。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334862",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 353,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334862",
        "postTime": "2025-03-18 10:26:00",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/59e8fa61955d4d0790a6c9cf61186dcc.png"
        ],
        "collectCount": 3,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146334833,
        "title": "K8s网络带宽管理：保障资源合理分配的技巧",
        "description": "比如，在一个混合部署的集群中，将开发测试用的Pod设置为BestEffort类别，在生产高峰期，当网络带宽紧张时，限制这些测试Pod的带宽，确保生产业务不受影响。通过有效的带宽管理，为这类关键应用分配足够的带宽资源，能确保其稳定运行，避免因带宽不足导致分析任务卡顿或超时，从而保障业务的正常运转。通过基于Pod的带宽限制、基于QoS的带宽管理以及网络策略与带宽管理的协同等技巧，可以有效地优化网络资源使用，满足不同应用对网络带宽的需求，提升K8s集群的整体性能和可靠性，为企业的数字化业务提供坚实的网络支撑。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334833",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 274,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334833",
        "postTime": "2025-03-18 10:25:08",
        "diggCount": 3,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/ce3712d829244b578ed3d6e50e5dcdd2.png"
        ],
        "collectCount": 10,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146334805,
        "title": "K8s网络故障排查实战：常见问题与解决方法",
        "description": "通过熟悉常见问题的排查思路和解决方法，结合实际案例积累经验，运维人员能够在面对K8s网络故障时迅速做出响应，高效解决问题，确保K8s集群网络的稳定可靠，为业务的持续运行提供坚实保障。例如，在使用Calico作为CNI插件时，如果BGP路由配置不正确，会导致跨节点Pod无法通信。1. kubectl：通过kubectl命令可以获取K8s集群内各种资源的信息，如kubectl get pods查看Pod状态，kubectl describe pod获取Pod详细描述信息，包括网络配置、事件等，帮助排查问题。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334805",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 387,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334805",
        "postTime": "2025-03-18 10:24:14",
        "diggCount": 4,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/824d76f1121b422f97820a891d94c07f.png"
        ],
        "collectCount": 9,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146334767,
        "title": "探索K8s Ingress：外部流量如何接入集群服务",
        "description": "同时，Ingress Controller作为Ingress的实际执行者，运行在K8s集群节点上，负责监听Ingress资源的变化，并根据配置更新负载均衡器（如Nginx、Traefik等）的规则，实现流量的动态转发。在这个配置中，定义了一个名为“example - ingress”的Ingress资源，关联到“example.com”域名，当访问该域名的根路径时，流量会被转发到名为“web - service”的Service的80端口。Ingress资源对象是K8s中定义路由规则的核心。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334767",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 293,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334767",
        "postTime": "2025-03-18 10:23:10",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/a8543710aefd4a54baed9aebd3a99f10.png"
        ],
        "collectCount": 9,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146334730,
        "title": "K8s网络安全防护：从基础到高级的安全措施",
        "description": "例如，给数据库Pod打上“app=database”标签，给应用服务Pod打上“app=backend”标签，然后创建网络策略，只允许“app=backend”的Pod访问“app=database”Pod的特定端口，如3306（MySQL默认端口），以此限制非法访问，保障数据库安全。例如，在一个电商系统中，针对用户服务、订单服务、支付服务等不同微服务，分别制定独立的网络策略，严格限制服务间的访问路径和端口，即使某个微服务被攻陷，攻击者也难以横向移动到其他微服务。（二）网络隔离与分段。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334730",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 386,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334730",
        "postTime": "2025-03-18 10:22:12",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/200fc94acc944d40810d678a460a60e5.png"
        ],
        "collectCount": 7,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146334685,
        "title": "在K8s集群中构建高性能网络：优化策略与实践",
        "description": "在K8s集群中构建高性能网络：优化策略与实践一、引言随着Kubernetes（K8s）在企业级应用中的广泛普及，构建高性能的K8s集群网络成为保障容器化应用高效运行的关键。高性能网络不仅能提升应用的响应速度，还能增强集群的稳定性和扩展性。本文将深入探讨在K8s集群中构建高性能网络的优化策略与实践方法。二、优化策略（一）合理选择CNI插件1. 性能考量：不同的CNI插件在性能上有显著差异。Calico基于BGP的原生IP路由模式，避免了Overlay网络的额外开销，在网络延迟和带宽利用率方面表现出色，尤其适合",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334685",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 333,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334685",
        "postTime": "2025-03-18 10:21:12",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/ae1b704e9f1e49e89bd8d9de7445bf07.png"
        ],
        "collectCount": 9,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146299065,
        "title": "深入解析 K8s 存储之 Volume 基础概念与核心类型",
        "description": "在 Kubernetes（K8s）的复杂生态系统中，存储管理是保障应用稳定运行、数据持久保存的关键环节。其中，Volume（卷）作为 K8s 存储体系的基础组件，承担着连接容器与存储资源的重要职责。理解 Volume 的概念与核心类型，是构建高效、可靠 K8s 存储架构的基石。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146299065",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 526,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146299065",
        "postTime": "2025-03-16 18:41:16",
        "diggCount": 18,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 20,
        "tags": [
          "java",
          "dubbo",
          "rpc"
        ]
      },
      {
        "articleId": 146299053,
        "title": "K8s 存储实战：如何高效配置和管理 PersistentVolume",
        "description": "通过合理规划 PV 配置、正确创建和使用 PV 与 PVC、有效管理 PV 的生命周期以及利用动态 PV 供应等技术，可以提升 K8s 存储系统的性能和可维护性，为企业级应用提供可靠的存储支持。根据 PV 的回收策略，当 PVC 释放时，PV 会进行相应的处理。在配置 PV 之前，需要根据应用程序的需求和集群的基础设施来选择合适的存储类型。同时，要考虑到集群中多个 PVC 对 PV 的竞争，避免出现存储资源不足的情况。对于支持动态扩展的存储类型（如一些云存储），可以通过修改 PV 的容量配置来实现。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146299053",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 996,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146299053",
        "postTime": "2025-03-16 18:40:45",
        "diggCount": 30,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 22,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146299046,
        "title": "探索 K8s 中存储卷的生命周期与动态供应机制",
        "description": "在 Kubernetes（K8s）环境里，存储卷对于容器化应用的稳定运行至关重要。理解存储卷的生命周期以及动态供应机制，有助于优化资源管理，确保数据的可靠存储与应用的高效运行。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146299046",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 987,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146299046",
        "postTime": "2025-03-16 18:39:58",
        "diggCount": 28,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 28,
        "tags": [
          "kubernetes",
          "docker",
          "容器"
        ]
      },
      {
        "articleId": 146299039,
        "title": "K8s 存储插件剖析：从本地存储到网络存储的实现差异",
        "description": "目录本地存储插件EmptyDir 插件HostPath 插件网络存储插件NFS 插件在 Kubernetes（K8s）生态系统中，存储插件扮演着连接应用程序与底层存储系统的关键角色。K8s 支持多种存储类型，从简单的本地存储到复杂的网络存储，而这些存储类型的实现依赖于不同的存储插件。深入理解这些插件及其在不同存储场景下的实现差异，对于构建高效、可靠的 K8s 存储架构至关重要。EmptyDir 是 K8s 中最基础的本地存储插件之一。当一个 Pod 被分配到节点上时，EmptyDir 卷会在该节点上被创建，",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146299039",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 402,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146299039",
        "postTime": "2025-03-16 18:39:21",
        "diggCount": 3,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146299029,
        "title": "基于 K8s 的分布式存储系统选型与部署策略",
        "description": "在 Kubernetes（K8s）集群中，随着应用规模的扩大和数据量的增长，选择合适的分布式存储系统并进行有效部署成为保障系统性能与数据可靠性的关键。分布式存储系统能够提供高扩展性、高可用性和高性能的存储服务，满足 K8s 集群中各类应用的多样化存储需求。本文将深入探讨基于 K8s 的分布式存储系统选型要点及部署策略。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146299029",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 830,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146299029",
        "postTime": "2025-03-16 18:38:49",
        "diggCount": 20,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 18,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146299009,
        "title": "K8s 存储安全：权限管理、加密及访问控制详解",
        "description": "在 Kubernetes（K8s）生态系统中，存储安全是保障数据完整性、保密性和可用性的核心要素。随着企业越来越多地将关键业务应用迁移至 K8s 集群，确保存储层面的安全至关重要。本文将深入探讨 K8s 存储安全中的权限管理、加密及访问控制等关键机制。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146299009",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 304,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146299009",
        "postTime": "2025-03-16 18:37:31",
        "diggCount": 7,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "kubernetes",
          "安全",
          "java"
        ]
      },
      {
        "articleId": 146298995,
        "title": "在 K8s 集群中优化存储性能的关键技术与方法",
        "description": "在 Kubernetes（K8s）集群环境下，存储性能对于应用程序的高效运行起着决定性作用。无论是处理大规模数据的在线业务系统，还是对响应速度要求极高的实时分析应用，优化 K8s 集群的存储性能都是提升整体系统性能的关键一环。本文将深入探讨在 K8s 集群中优化存储性能的一系列关键技术与实用方法。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146298995",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 913,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298995",
        "postTime": "2025-03-16 18:36:56",
        "diggCount": 26,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 12,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146298984,
        "title": "K8s 存储与应用程序的集成：案例分析与最佳实践",
        "description": "在这个案例中，WordPress 作为流行的内容管理系统，负责网站的前端展示和内容编辑。MySQL 数据库则用于存储网站的文章、用户信息、评论等数据。K8s 集群被用于部署和管理这两个组件，实现应用的高可用性和弹性伸缩。存储资源规划：根据应用的实际数据存储需求，合理规划 PV 的容量和访问模式。对于数据库等对数据一致性要求高的应用，选择合适的访问模式（如 ReadWriteOnce），并预留足够的存储容量以应对未来的数据增长。服务与网络配置。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146298984",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 831,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298984",
        "postTime": "2025-03-16 18:36:10",
        "diggCount": 12,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146298864,
        "title": "K8s 存储的故障排查与恢复策略全解析",
        "description": "在 Kubernetes（K8s）集群中，存储系统的稳定运行对保障应用程序的正常工作至关重要。然而，由于存储涉及多个组件和复杂的网络交互，难免会出现各种故障。快速有效地排查和解决这些故障，以及制定合理的恢复策略，对于维持 K8s 集群的高可用性和数据完整性具有关键意义。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146298864",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 528,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298864",
        "postTime": "2025-03-16 18:25:10",
        "diggCount": 13,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 16,
        "tags": [
          "java"
        ]
      },
      {
        "articleId": 146298853,
        "title": "多租户环境下 K8s 存储的隔离与资源分配方案",
        "description": "在现代云计算和容器化应用蓬勃发展的背景下，Kubernetes（K8s）凭借其强大的容器编排与管理能力，成为构建多租户环境的热门选择。在多租户场景中，确保存储的隔离性与合理的资源分配，对于保障各租户数据安全、提升资源利用效率以及维护系统整体稳定性至关重要。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146298853",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 904,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298853",
        "postTime": "2025-03-16 18:24:32",
        "diggCount": 9,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 14,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 146298848,
        "title": "K8s 存储扩展：如何应对大规模集群的存储需求增长",
        "description": "在大规模 Kubernetes（K8s）集群的运营过程中，存储需求往往随着业务的迅猛发展而持续攀升。如何有效地扩展存储，以满足不断增长的数据存储和处理需求，成为保障集群稳定运行与业务连续性的关键挑战。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146298848",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 515,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298848",
        "postTime": "2025-03-16 18:24:02",
        "diggCount": 24,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 12,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146298841,
        "title": "K8s 存储的成本优化：从资源利用到存储选型的考量",
        "description": "在 Kubernetes（K8s）集群的运维中，存储成本是一项不可忽视的开支。随着数据量的增长和应用复杂度的提升，如何在保障存储性能与可靠性的前提下实现成本优化，成为众多企业关注的焦点。本文将从资源利用效率和存储选型等关键方面，探讨 K8s 存储成本优化的有效策略。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146298841",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 557,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298841",
        "postTime": "2025-03-16 18:23:30",
        "diggCount": 5,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 15,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146298816,
        "title": "新兴 K8s 存储技术趋势：云原生存储与边缘存储展望",
        "description": "在 Kubernetes（K8s）不断演进的生态体系中，存储技术作为支撑应用高效运行与数据管理的关键要素，正持续迎来创新变革。当下，云原生存储与边缘存储展现出强劲的发展势头，成为推动 K8s 存储领域前行的重要力量，深刻影响着未来的技术走向。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146298816",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 826,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298816",
        "postTime": "2025-03-16 18:21:22",
        "diggCount": 17,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 8,
        "tags": [
          "云原生"
        ]
      },
      {
        "articleId": 146298809,
        "title": "K8s 存储与容器编排协同工作的深度揭秘",
        "description": "在 Kubernetes（K8s）的生态体系中，存储与容器编排并非孤立存在，而是通过紧密且复杂的协同机制，为容器化应用提供高效、可靠的运行环境。理解二者如何协同工作，对于充分发挥 K8s 的优势，构建强大的应用架构至关重要。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146298809",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 629,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298809",
        "postTime": "2025-03-16 18:20:45",
        "diggCount": 26,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 13,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 146298788,
        "title": "迁移至 K8s 存储：传统存储架构面临的挑战与解决方案",
        "description": "在数字化转型的浪潮中，越来越多企业选择将传统存储架构迁移至 Kubernetes（K8s）存储体系，期望借此提升存储管理效率、增强应用的弹性与可扩展性。然而，这一迁移过程并非一帆风顺，传统存储架构在融入 K8s 生态时面临诸多挑战。深入剖析这些挑战，并探寻有效的解决方案，是确保迁移成功的关键。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146298788",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 532,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298788",
        "postTime": "2025-03-16 18:19:44",
        "diggCount": 25,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 7,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146281302,
        "title": "K8s 的未来发展趋势：新技术与新应用场景展望",
        "description": "K8s 的未来充满机遇与挑战，新技术的不断融入将使其功能更加强大、智能和安全，新应用场景的拓展将进一步扩大其应用范围和影响力。无论是与人工智能的融合、对边缘计算的支持，还是在大规模分布式应用和行业特定应用场景中的发展，K8s 都将持续引领容器编排和云原生技术的发展潮流。企业和开发者需要密切关注这些发展趋势，提前做好技术储备和应用规划，以充分利用 K8s 带来的技术优势，在不断变化的数字化时代中保持竞争力。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146281302",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 506,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146281302",
        "postTime": "2025-03-15 16:27:20",
        "diggCount": 23,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 9,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146281279,
        "title": "K8s 性能优化：提升集群运行效率的方法与实践",
        "description": "K8s 性能优化是一个系统性工程，涉及资源分配、网络配置、存储管理等多个方面。通过合理设置资源请求与限制、优化节点资源利用率、选择合适的网络插件和存储类型、实施有效的网络策略和存储资源监控等方法，能够显著提升 K8s 集群的运行效率，确保应用在 K8s 环境中稳定高效运行。在实际应用中，需根据集群的具体情况和应用需求，有针对性地实施性能优化措施，并持续监控和调整，以实现 K8s 集群性能的最大化。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146281279",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 732,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146281279",
        "postTime": "2025-03-15 16:26:09",
        "diggCount": 24,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 19,
        "tags": [
          "kubernetes",
          "性能优化",
          "容器"
        ]
      },
      {
        "articleId": 146281242,
        "title": "K8s 与云原生：构建云原生应用架构的关键支撑",
        "description": "云原生是一种构建和运行应用的方法，它充分利用云计算的优势，包括弹性伸缩、分布式存储、自动化运维等。云原生应用由多个微服务组成，这些微服务独立开发、部署和扩展，通过轻量级通信机制相互协作。同时，云原生应用采用容器化技术进行封装，借助容器编排工具实现自动化管理。K8s 作为云原生生态系统的核心，为构建云原生应用架构提供了全方位的关键支撑。从容器编排与管理、服务发现与负载均衡，到存储管理和配置管理，K8s 的各种特性和功能使得云原生应用能够充分发挥弹性伸缩、分布式架构和自动化运维的优势。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146281242",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1189,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146281242",
        "postTime": "2025-03-15 16:24:08",
        "diggCount": 32,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 14,
        "tags": [
          "云原生",
          "kubernetes",
          "架构"
        ]
      },
      {
        "articleId": 146281213,
        "title": "多集群管理：K8s 跨集群部署与管理的策略和工具",
        "description": "多集群管理对于现代企业的 K8s 应用部署和运维至关重要。通过选择合适的跨集群部署策略，如集中式、分布式或混合式部署，可以满足不同业务场景的需求。同时，借助 KubeFed、ClusterAPI、ArgoCD 等强大的多集群管理工具，能够更高效地实现跨集群的应用部署、集群生命周期管理以及持续交付。在实际应用中，需要根据企业的具体情况和需求，综合运用这些策略和工具，构建一个稳定、高效的多集群 K8s 管理体系。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146281213",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1141,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146281213",
        "postTime": "2025-03-15 16:22:39",
        "diggCount": 28,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 23,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146281178,
        "title": "K8s 中的 Helm 包管理：简化应用部署与管理流程",
        "description": "Helm 为 K8s 应用的部署和管理带来了极大的便利，通过包管理的方式简化了复杂的 K8s 资源配置和管理过程。从 Helm 的安装、使用已有的 Chart，到创建和分享自己的 Chart，掌握 Helm 的使用方法能够显著提高在 K8s 环境中开发、部署和维护应用的效率。在实际项目中，合理运用 Helm 可以降低运维成本，提升应用的可管理性和可重复性。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146281178",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 933,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146281178",
        "postTime": "2025-03-15 16:21:02",
        "diggCount": 11,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 18,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 146281139,
        "title": "K8s 应用故障排查：常见问题及解决思路汇总",
        "description": "K8s 应用故障排查需要对 K8s 的各个组件和运行机制有深入理解。通过对 Pod 启动失败、网络通信问题、资源不足等常见故障的分类排查，结合具体的错误信息和排查方法，能够逐步定位并解决问题。在实际工作中，建立完善的监控体系和故障排查流程，有助于更快速地应对和解决 K8s 应用故障，保障业务的连续性和稳定性。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146281139",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 915,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146281139",
        "postTime": "2025-03-15 16:19:25",
        "diggCount": 23,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 15,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146281114,
        "title": "K8s 集群监控：从指标采集到可视化展示的完整方案",
        "description": "构建一套完整的 K8s 集群监控方案，从指标采集到可视化展示的每个环节都至关重要。通过合理选择指标采集工具（如 Prometheus 及其相关 Exporter）、数据存储方案（本地存储或远程存储）以及可视化工具（Grafana），能够全面、实时地了解 K8s 集群的运行状况，及时发现并解决潜在问题，保障集群的稳定、高效运行。在实际应用中，需要根据集群规模、业务需求等因素，灵活配置和优化监控方案，以满足不同场景下的监控需求。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146281114",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 624,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146281114",
        "postTime": "2025-03-15 16:18:15",
        "diggCount": 30,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146281083,
        "title": "K8s 与容器编排：如何高效管理容器化应用",
        "description": "K8s 在容器编排中发挥着至关重要的作用，它为开发者和运维人员提供了一套完整的解决方案，用于高效地管理容器化应用。通过利用 K8s 的各种资源对象和机制，如 Pod、Deployment、Service 等，可以实现容器化应用的自动化部署、扩缩容、容器间通信、监控和故障恢复等功能。在实际应用中，需要深入理解 K8s 的工作原理和使用方法，结合具体的业务需求，充分发挥 K8s 的优势，构建稳定、高效的容器化应用系统。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146281083",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 863,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146281083",
        "postTime": "2025-03-15 16:16:52",
        "diggCount": 19,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 6,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146281031,
        "title": "K8s 安全防护：认证、授权与网络策略保障集群安全",
        "description": "认证、授权和网络策略是保障 K8s 集群安全的重要手段。通过合理配置认证机制，可以确保只有合法的用户和客户端能够访问集群；利用授权机制，可以精确控制用户和客户端对集群资源的操作权限；应用网络策略，可以有效隔离 Pod 之间的网络通信，防范网络攻击。在实际应用中，需要根据企业的安全需求和业务场景，综合运用这些安全防护措施，构建一个安全可靠的 K8s 集群环境。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146281031",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 772,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146281031",
        "postTime": "2025-03-15 16:14:24",
        "diggCount": 14,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 17,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146280981,
        "title": "K8s 部署策略：滚动更新、蓝绿部署等方式对比与实操",
        "description": "不同的 K8s 部署策略各有优缺点，适用于不同的场景。滚动更新适用于对更新速度要求不高、对资源利用率要求较高的场景；蓝绿部署适用于对服务可用性要求极高、能够承担较高资源成本的场景；金丝雀部署适用于对风险控制要求较高、希望逐步引入新版本应用的场景。在实际应用中，需要根据应用的特点、业务需求和风险承受能力等因素，选择合适的部署策略。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146280981",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 705,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146280981",
        "postTime": "2025-03-15 16:12:32",
        "diggCount": 9,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 17,
        "tags": [
          "kubernetes",
          "docker",
          "容器"
        ]
      },
      {
        "articleId": 146280957,
        "title": "K8s 中的资源管理：资源配额与限制的设置及应用",
        "description": "资源限制是针对单个 Pod 或容器的资源使用进行控制，而资源配额是针对整个命名空间的资源使用总量进行控制。它们可以协同工作，共同确保集群资源的合理使用。资源配额和资源限制是 K8s 中重要的资源管理机制。资源限制用于控制单个 Pod 或容器的资源使用上限，资源配额用于限制命名空间内的资源使用总量。通过合理设置资源配额和资源限制，可以实现资源的公平分配、防止资源过度使用、提高集群的稳定性和可靠性。在实际应用中，需要根据不同的环境和业务需求，灵活运用这两个机制，以达到最佳的资源管理效果。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146280957",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 620,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146280957",
        "postTime": "2025-03-15 16:11:42",
        "diggCount": 5,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 20,
        "tags": [
          "kubernetes",
          "docker",
          "容器"
        ]
      },
      {
        "articleId": 146280935,
        "title": "存储在 K8s 中的运用：持久化卷（PV）与持久化卷声明（PVC）详解",
        "description": "持久化卷（PV）是 K8s 集群中由管理员预先创建的存储资源，它是集群中的一种抽象的存储单元，独立于 Pod 的生命周期。PV 可以是各种类型的存储，如 NFS（网络文件系统）、iSCSI、Ceph 等，不同的存储类型提供了不同的性能和功能特点。持久化卷声明（PVC）是用户向集群请求存储资源的一种声明，它是 Pod 与 PV 之间的桥梁。PVC 描述了 Pod 对存储资源的需求，如存储容量、访问模式等，K8s 会根据 PVC 的请求自动为其绑定一个合适的 PV。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146280935",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 535,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146280935",
        "postTime": "2025-03-15 16:11:02",
        "diggCount": 9,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 28,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146280913,
        "title": "K8s 网络剖析：Service 如何实现服务发现与负载均衡",
        "description": "Service 是 K8s 中的一种抽象层，它定义了一组 Pod 的逻辑集合以及访问这些 Pod 的策略。通过 Service，我们可以为一组 Pod 提供一个稳定的 IP 地址和端口号，使得其他应用可以通过这个稳定的地址来访问这些 Pod，而不需要关心具体的 Pod 实例在哪里。K8s 的 Service 是实现服务发现和负载均衡的关键组件。通过基于 DNS 的服务发现和环境变量注入，应用可以方便地找到其他服务的访问地址；",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146280913",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 1275,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146280913",
        "postTime": "2025-03-15 16:10:09",
        "diggCount": 30,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 15,
        "tags": [
          "kubernetes",
          "网络",
          "服务发现"
        ]
      },
      {
        "articleId": 146280900,
        "title": "深入 K8s 核心：Pod 的工作原理与调度机制",
        "description": "Pod 是一组紧密相关的容器集合，这些容器共享网络命名空间、存储卷等资源。一个 Pod 可以包含一个或多个容器，它们通常是为了共同完成某个特定的任务而组合在一起。例如，一个 Web 应用程序 Pod 可能包含一个 Web 服务器容器和一个日志收集容器。Pod 作为 K8s 中最基础的计算单元，其工作原理和调度机制是理解 K8s 核心功能的关键。通过深入了解 Pod 的创建过程、网络和存储模型、生命周期以及调度机制，我们可以更好地使用 K8s 来管理和运行容器化应用，提高应用的可靠性和性能。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146280900",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 997,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146280900",
        "postTime": "2025-03-15 16:09:25",
        "diggCount": 23,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 10,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146280874,
        "title": "K8s 基础入门：集群搭建全流程解析",
        "description": "通过以上步骤，我们完成了 K8s 集群的搭建。从环境准备、主节点初始化、网络插件安装到工作节点加入以及最后的集群验证，每个环节都至关重要。在实际搭建过程中，可能会遇到各种问题，如网络问题、镜像下载失败等，需要根据具体错误信息进行排查和解决。搭建好 K8s 集群后，我们就可以进一步探索 K8s 在应用部署、管理等方面的强大功能，开启云原生应用开发与运维的新篇章。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146280874",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 599,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146280874",
        "postTime": "2025-03-15 16:08:05",
        "diggCount": 22,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 8,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146334589,
        "title": "K8s网络通信原理：Pod间、Pod与Service的通信机制",
        "description": "K8s的kube - proxy组件负责监听Service和Endpoint（Endpoint是与Service关联的Pod的集合，包含Pod的IP地址和端口信息）的变化，并根据这些信息在节点上设置相应的iptables规则或IPVS规则。当节点A上的Pod要与节点B上的Pod通信时，首先在节点A上，数据会被封装在一个Overlay隧道协议（如VXLAN）的数据包中，这个数据包的外层IP地址是节点B的IP地址。其中，Pod间以及Pod与Service的通信机制是K8s网络体系的核心内容。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334589",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 209,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334589",
        "postTime": "2025-03-18 10:18:48",
        "diggCount": 4,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/08ec5c07693f449b9df2d17870dbc693.png"
        ],
        "collectCount": 7,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146334552,
        "title": "理解K8s Service：服务发现与负载均衡的奥秘",
        "description": "DNS服务器会将Service的域名解析为其对应的ClusterIP（对于ClusterIP类型的Service），从而实现服务发现。例如，Pod1的权重设置为2，Pod2和Pod3的权重设置为1，那么在负载均衡时，Service将按照2:1:1的比例将请求分发给Pod1、Pod2和Pod3，这种方式适用于不同Pod处理能力不同的场景。对于运行在K8s集群中的众多容器化应用而言，Service就像是一个智能的“交通枢纽”，负责将外部或内部的请求准确无误地路由到对应的Pod上，确保应用的高可用性和高性能。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334552",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 375,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334552",
        "postTime": "2025-03-18 10:17:44",
        "diggCount": 3,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/f015cb3c71044ae5b98fd27dc77d182d.png"
        ],
        "collectCount": 4,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146334524,
        "title": "K8s中CNI插件对比分析：选择最适合你的网络方案",
        "description": "Calico在网络策略方面最为强大，它提供了丰富的策略规则选项，不仅可以基于IP地址、端口进行访问控制，还能结合K8s的标签机制，实现基于应用服务的复杂策略配置，如允许某个命名空间内的所有服务访问另一个特定服务的特定端口。在Kubernetes（K8s）的生态体系里，容器网络接口（CNI）插件是构建集群网络的关键组件，它负责为容器分配IP地址，管理网络连接，实现容器与容器、容器与外部网络之间的通信。其强大的网络策略功能和高效的原生IP路由机制，能为复杂的应用架构提供可靠的网络保障。（三）部署与管理复杂度。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334524",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 240,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334524",
        "postTime": "2025-03-18 10:16:42",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/f76926ac7ea14868b79eddaa571d3436.png"
        ],
        "collectCount": 10,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146334492,
        "title": "K8s网络策略详解：如何实现精细的流量管控",
        "description": "例如，假设有一组运行数据库服务的Pod，都被打上了“app=database”的标签，那么可以创建一个网络策略，只允许带有“app=backend”标签的Pod访问这些数据库Pod。例如，一个电商系统中的订单服务和支付服务，虽然都运行在同一集群中，但为了保障支付安全，订单服务的Pod只能与支付服务的特定端口进行通信，而不能随意访问支付服务的其他端口。K8s网络策略作为实现这一目标的关键机制，允许用户定义Pod之间以及Pod与外部网络的访问规则，极大地增强了集群网络的安全性和可管理性。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334492",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 215,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334492",
        "postTime": "2025-03-18 10:15:44",
        "diggCount": 3,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/06370a6b9f6f4851ad1a1d7dd87edd8d.png"
        ],
        "collectCount": 10,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146334450,
        "title": "深入剖析K8s网络模型：基础架构与核心概念",
        "description": "例如，一个电商应用中的用户服务，可能由多个运行相同代码的Pod组成，通过Service，前端应用无需关心具体是哪个Pod提供服务，只需要访问Service的地址即可。从Pod的网络共享机制，到节点网络、集群网络的构建，再到Service、网络策略和Ingress等关键概念，它们相互协作，为容器化应用提供了强大、灵活且安全的网络通信能力。例如，一个公司的网站可能有多个子服务，如首页、产品页、用户中心等，通过Ingress可以将不同的URL路径分别指向对应的Service，实现统一的对外服务入口。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146334450",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 354,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334450",
        "postTime": "2025-03-18 10:14:41",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/6e82d08ad06a4c439f52ba135989b485.png"
        ],
        "collectCount": 10,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146328401,
        "title": "深入剖析 K8s Pod：基础概念与核心原理",
        "description": "Pod 作为 K8s 的基础核心概念，是构建复杂容器化应用的基石。理解 Pod 的概念、原理和操作，能够帮助我们更好地利用 K8s 进行应用的部署、管理和运维。随着对 K8s 学习的深入，我们还将探索更多与 Pod 相关的高级特性，如 Pod 的网络策略、存储配置等，为构建高性能、高可靠的云原生应用打下坚实的基础。希望本文能为你深入了解 K8s Pod 提供有益的帮助，开启你在 K8s 技术领域的探索之旅。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328401",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 600,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328401",
        "postTime": "2025-03-17 23:14:49",
        "diggCount": 13,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 6,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146328377,
        "title": "K8s Pod 生命周期全解析：从创建到终结",
        "description": "K8s Pod 的生命周期是一个复杂而有序的过程，从 Pending 到 Running，再到可能的 Succeeded、Failed 或 Unknown 状态，最后到终止，每个阶段都涉及 K8s 系统多个组件的协同工作以及各种策略的应用。深入掌握 Pod 生命周期的细节，能够帮助运维人员更好地管理容器化应用，确保应用的稳定运行，高效排查和解决问题，充分发挥 K8s 在容器编排和管理方面的强大优势。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328377",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 808,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328377",
        "postTime": "2025-03-17 23:14:46",
        "diggCount": 28,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 25,
        "tags": [
          "kubernetes",
          "docker",
          "容器"
        ]
      },
      {
        "articleId": 146328388,
        "title": "K8s Pod 资源管理：CPU 与内存的高效调配",
        "description": "在 K8s 中，通过在 Pod 的 YAML 文件中为每个容器设置resources字段，来定义容器对 CPU 和内存的请求（requests）与限制（limits）。请求表示容器运行时需要的最小资源量，调度器根据请求量来分配节点资源；限制则规定了容器可使用资源的最大值，防止容器过度占用资源影响其他应用。yamlkind: Podmetadata:spec:resources:requests:cpu: \"200m\" # 200 millicpu，即0.2个CPU核心。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328388",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 671,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328388",
        "postTime": "2025-03-17 23:14:42",
        "diggCount": 22,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 8,
        "tags": [
          "kubernetes",
          "java",
          "docker"
        ]
      },
      {
        "articleId": 146328369,
        "title": "K8s Pod 网络策略：保障通信安全与隔离",
        "description": "K8s 网络策略通过 NetworkPolicy 资源对象定义，以 YAML 文件形式呈现，明确允许或拒绝的网络流量规则。这些规则基于 Pod 标签选择器、命名空间以及端口等要素制定，实现对流量的细粒度控制。K8s Pod 网络策略是构建安全、隔离网络环境的重要工具，通过对网络流量的精准控制，为容器化应用提供了可靠的安全保障。合理配置和应用网络策略，能有效应对复杂的网络安全挑战，满足不同场景下的安全需求。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328369",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 765,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328369",
        "postTime": "2025-03-17 23:14:39",
        "diggCount": 17,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 18,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146328458,
        "title": "多容器 K8s Pod：协同工作机制探秘",
        "description": "多容器 K8s Pod 为容器化应用的部署和管理提供了强大的灵活性和高效性。通过合理利用多容器 Pod 的协同工作机制，开发人员和运维人员可以将复杂的应用拆分成多个相互协作的容器，实现更细粒度的功能划分和更好的资源利用。同时，深入理解多容器 Pod 的资源共享、生命周期管理以及配置方法，有助于构建更加稳定、可靠的容器化应用系统，充分发挥 K8s 在容器编排和管理方面的优势。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328458",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 905,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328458",
        "postTime": "2025-03-17 23:14:32",
        "diggCount": 10,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 13,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146328353,
        "title": "K8s Pod 调度策略：理解节点选择与分配逻辑",
        "description": "K8s 调度器是集群控制平面的重要组件，持续监控新创建且尚未分配节点的 Pod，依据一系列调度策略和算法，为每个 Pod 选择最佳的运行节点。调度器的决策过程涉及多方面因素，包括节点资源状况、Pod 资源需求、节点与 Pod 的亲和性等。K8s Pod 的调度策略是一个复杂而精妙的系统，综合考虑资源、亲和性、污点容忍等多方面因素，实现节点的合理选择与 Pod 的高效分配。深入理解这些调度策略，有助于集群管理员优化资源利用，提升应用性能与可靠性，充分发挥 K8s 集群的强大功能，满足多样化的业务需求。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328353",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 557,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328353",
        "postTime": "2025-03-17 23:14:24",
        "diggCount": 24,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 19,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146328430,
        "title": "K8s Pod 健康检查：确保应用持续可用",
        "description": "K8s Pod 健康检查是保障容器化应用持续可用的关键机制，通过存活探针和就绪探针，从不同角度实时监控 Pod 状态，及时发现并处理异常。合理配置健康检查参数，能有效提升应用的稳定性和可靠性，确保业务不受故障影响。在实际应用中，需根据应用特性和业务需求，精细调整健康检查策略，充分发挥 K8s 健康检查机制的优势。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328430",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 475,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328430",
        "postTime": "2025-03-17 23:14:16",
        "diggCount": 10,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146328429,
        "title": "K8s Pod 配置管理：环境变量与配置文件的运用",
        "description": "在 K8s 中，为 Pod 内的容器定义环境变量非常简单，只需在 Pod 的 YAML 文件中的containers字段下进行设置。例如：yamlkind: Podmetadata:spec:env:上述配置为容器注入了两个环境变量APP_ENV和DB_HOST，应用程序在容器内可以通过标准的环境变量读取方式获取这些值，从而根据不同的环境配置执行相应的逻辑。比如，当APP_ENV为production时，应用可能会开启更严格的日志记录和性能优化设置。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328429",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 560,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328429",
        "postTime": "2025-03-17 23:14:07",
        "diggCount": 15,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 9,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146328490,
        "title": "K8s Pod 故障排查实战：常见问题与解决方法",
        "description": "K8s Pod 故障排查是个复杂过程，需综合运用多种工具和方法，结合详细日志与事件分析定位问题。从资源管理到镜像拉取，从应用健康到网络通信，每个环节都可能出现故障。掌握常见问题排查思路与解决方法，能提升运维效率，快速恢复服务，保障 K8s 集群稳定高效运行，为业务持续发展提供坚实支撑。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328490",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 775,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328490",
        "postTime": "2025-03-17 23:13:59",
        "diggCount": 11,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 13,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146328428,
        "title": "K8s Pod 与服务发现：如何实现高效的服务连接",
        "description": "K8s 中的服务发现机制，通过 Service 资源对象和 DNS、环境变量等方式，为 Pod 之间的高效通信提供了有力支持。基于 DNS 的服务发现简洁灵活，是 K8s 推荐的方式；环境变量方式则在某些特定场景下也能发挥作用。理解并合理运用服务发现机制，能够帮助开发者和运维人员构建更加稳定、可靠、可扩展的微服务架构应用，充分发挥 K8s 在容器编排和管理方面的优势。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328428",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 752,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328428",
        "postTime": "2025-03-17 23:13:56",
        "diggCount": 15,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 25,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146328337,
        "title": "K8s Pod 的存储挂载：本地与网络存储的使用",
        "description": "K8s Pod 的本地与网络存储挂载为应用提供了灵活的数据持久化和共享方案。本地存储适用于临时数据和特定节点文件访问场景，网络存储则满足跨节点数据共享和大规模数据存储需求。根据应用特性和业务需求，合理选择存储类型并正确配置，是保障 K8s 集群中应用稳定运行和数据安全的重要环节。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328337",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 419,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328337",
        "postTime": "2025-03-17 23:13:52",
        "diggCount": 16,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 7,
        "tags": [
          "kubernetes"
        ]
      },
      {
        "articleId": 146328308,
        "title": "K8s Pod 安全上下文：权限控制与安全加固",
        "description": "安全上下文是 K8s 中定义 Pod 或容器安全相关属性的配置集合，涵盖用户 ID（UID）、组 ID（GID）、特权模式、SELinux 标签等设置。这些设置决定了容器运行时的权限级别和安全约束，确保容器在安全的环境中执行任务。K8s Pod 安全上下文提供了全面的权限控制和安全加固手段，从用户与组权限管理，到特权模式和能力控制，再到 SELinux 与 AppArmor 支持，有效提升了 Pod 的安全性。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328308",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 455,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328308",
        "postTime": "2025-03-17 23:13:44",
        "diggCount": 13,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 14,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146328325,
        "title": "K8s Pod 扩缩容策略：灵活应对业务负载变化",
        "description": "K8s Pod 扩缩容策略为应对业务负载变化提供了高效灵活的解决方案。HPA 和 VPA 从水平和垂直方向实现 Pod 资源的动态调整，确保应用性能，降低成本。理解并合理运用扩缩容策略，关注执行过程和注意事项，能使 K8s 集群更好地支撑业务发展，适应复杂多变的业务场景。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328325",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 594,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328325",
        "postTime": "2025-03-17 23:13:41",
        "diggCount": 16,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 18,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      },
      {
        "articleId": 146328291,
        "title": "K8s Pod 的日志管理与监控：洞察应用运行状态",
        "description": "在 Kubernetes（K8s）环境中，有效管理和监控 Pod 的日志，对深入了解应用运行状态、快速排查故障以及优化性能十分关键。通过完善的日志管理与监控体系，运维人员和开发者能够及时发现问题，保障应用的稳定可靠运行。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328291",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 269,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328291",
        "postTime": "2025-03-17 23:13:37",
        "diggCount": 3,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 7,
        "tags": [
          "kubernetes",
          "docker",
          "容器"
        ]
      },
      {
        "articleId": 146328279,
        "title": "K8s Pod 在生产环境中的优化技巧与最佳实践",
        "description": "在生产环境中优化 K8s Pod 是一个综合性的工作，涉及资源、网络、存储、监控和运维等多个方面。通过精准的资源配置、合理的网络和存储策略、完善的监控与日志管理以及高效的部署和运维手段，可以使 Pod 在生产环境中稳定、高效地运行，为业务的持续发展提供坚实的技术保障。不断总结和应用这些优化技巧与最佳实践，是 K8s 集群管理员和开发者提升系统性能和可靠性的关键所在。",
        "url": "https://blog.csdn.net/wdfdgygg77/article/details/146328279",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 568,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328279",
        "postTime": "2025-03-17 23:13:33",
        "diggCount": 13,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "kubernetes",
          "容器",
          "云原生"
        ]
      }
    ]
  },
  {
    "articleCreaterNum": "19260193307",
    "articleInfos": [
      {
        "type": "blog",
        "formatTime": "46 分钟前",
        "title": "Go 语言在人工智能场景下的性能优化策略",
        "description": "在人工智能领域，Go 语言凭借其独特优势为开发者提供了强大的技术支撑。通过优化计算资源利用、数据处理以及模型部署与推理等方面的策略，能够显著提升 Go 语言在人工智能场景下的性能表现。在实际项目中，这些优化策略已在智能图像识别系统、自然语言处理聊天机器人等各类人工智能应用中取得了良好效果，有效提升了人工智能应用的竞争力。展望未来，随着人工智能技术的不断发展和 Go 语言生态的持续完善，Go 语言在人工智能开发中将迎来更多机遇和挑战。",
        "hasOriginal": true,
        "diggCount": 6,
        "commentCount": 0,
        "postTime": 1742617839000,
        "createTime": 1742617839000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437855",
        "articleType": 1,
        "viewCount": 386,
        "picList": [
          "https://i-blog.csdnimg.cn/blog_migrate/tags/671f42ab07fd990f949a1c903140dd83.png"
        ],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437855",
        "collectCount": 2,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "47 分钟前",
        "title": "Go 语言在人工智能场景下的性能优化策略",
        "description": "在人工智能领域，Go 语言凭借其独特优势为开发者提供了强大的技术支撑。通过优化计算资源利用、数据处理以及模型部署与推理等方面的策略，能够显著提升 Go 语言在人工智能场景下的性能表现。在实际项目中，这些优化策略已在智能图像识别系统、自然语言处理聊天机器人等各类人工智能应用中取得了良好效果，有效提升了人工智能应用的竞争力。展望未来，随着人工智能技术的不断发展和 Go 语言生态的持续完善，Go 语言在人工智能开发中将迎来更多机遇和挑战。",
        "hasOriginal": true,
        "diggCount": 10,
        "commentCount": 0,
        "postTime": 1742617804000,
        "createTime": 1742617804000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437847",
        "articleType": 1,
        "viewCount": 305,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437847",
        "collectCount": 8,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "48 分钟前",
        "title": "Go 语言在边缘计算场景下的性能优化策略",
        "description": "在边缘计算领域，Go 语言凭借其独特优势为开发者提供了强大的技术支撑。通过优化资源管理、数据处理和通信等方面的策略，能够显著提升 Go 语言在边缘计算场景下的性能表现。在实际项目中，这些优化策略已在智能工厂、智能交通等各类边缘计算应用中取得了良好效果，有效提升了边缘计算系统的竞争力。展望未来，随着边缘计算技术的不断发展和 Go 语言生态的持续完善，Go 语言在边缘计算开发中将迎来更多机遇和挑战。未来可能会出现更高效的资源管理技术、更智能的数据处理算法以及更可靠的通信协议。",
        "hasOriginal": true,
        "diggCount": 10,
        "commentCount": 0,
        "postTime": 1742617736000,
        "createTime": 1742617736000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437842",
        "articleType": 1,
        "viewCount": 370,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437842",
        "collectCount": 4,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "50 分钟前",
        "title": "Go 语言在物联网场景下的性能优化策略",
        "description": "在物联网领域，Go 语言凭借其独特优势为开发者提供了强大的技术支撑。通过优化资源管理、数据处理和通信等方面的策略，能够显著提升 Go 语言在物联网场景下的性能表现。在实际项目中，这些优化策略已在智能家居系统、工业物联网设备等各类物联网应用中取得了良好效果，有效提升了物联网系统的竞争力。展望未来，随着物联网技术的不断发展和 Go 语言生态的持续完善，Go 语言在物联网开发中将迎来更多机遇和挑战。未来可能会出现更高效的资源管理技术、更智能的数据处理算法以及更可靠的通信协议。",
        "hasOriginal": true,
        "diggCount": 2,
        "commentCount": 0,
        "postTime": 1742617609000,
        "createTime": 1742617609000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437818",
        "articleType": 1,
        "viewCount": 292,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437818",
        "collectCount": 9,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "51 分钟前",
        "title": "Go 语言在分布式系统中的性能优化策略",
        "description": "在分布式系统领域，Go 语言凭借其独特优势为开发者提供了强大的技术支撑。通过优化网络通信、保障数据一致性以及提升负载均衡和节点协作效率等策略，能够显著提升 Go 语言在分布式系统中的性能表现。在实际项目中，这些优化策略已在分布式缓存系统、分布式数据库等各类分布式应用中取得了良好效果，有效提升了系统的竞争力。展望未来，随着分布式系统技术的不断演进和 Go 语言生态的持续完善，Go 语言在分布式系统开发中将迎来更多机遇和挑战。",
        "hasOriginal": true,
        "diggCount": 6,
        "commentCount": 0,
        "postTime": 1742617562000,
        "createTime": 1742617562000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437813",
        "articleType": 1,
        "viewCount": 180,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437813",
        "collectCount": 3,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "51 分钟前",
        "title": "Go 语言在云原生场景下的性能优化策略",
        "description": "在云原生时代，Go 语言凭借其独特优势，为构建高性能应用提供了有力支持。通过深入理解云原生应用的特点，针对性地采取优化内存使用、提升网络通信效率、利用容器编排特性等策略，能够显著提升 Go 语言在云原生场景下的性能表现。在实际项目中，这些优化策略已在微服务架构、大数据处理等各类云原生应用中取得了良好效果，有效提升了应用的竞争力。展望未来，随着云原生技术的不断发展和 Go 语言生态的持续完善，Go 语言在云原生领域将迎来更多机遇和挑战。",
        "hasOriginal": true,
        "diggCount": 5,
        "commentCount": 0,
        "postTime": 1742617531000,
        "createTime": 1742617531000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437808",
        "articleType": 1,
        "viewCount": 215,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437808",
        "collectCount": 9,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "52 分钟前",
        "title": "优化 Go 语言垃圾回收机制，提升程序性能",
        "description": "Go 语言的垃圾回收机制为开发者提供了便捷的内存管理方式，但在实际应用中，需要深入理解其工作原理，精准识别因垃圾回收引发的性能问题，并采取有效的优化策略。通过减少不必要的内存分配、优化数据结构与算法、合理调整垃圾回收参数等方法，能够显著提升垃圾回收性能，降低其对程序运行效率的影响。展望未来，随着 Go 语言生态系统的不断发展，垃圾回收机制有望得到进一步优化。例如，可能会出现更高效的垃圾回收算法，进一步减少 STW 时间，提高并发性能；或者在内存管理方面有新的突破，更好地应对内存碎片化等问题。",
        "hasOriginal": true,
        "diggCount": 4,
        "commentCount": 0,
        "postTime": 1742617472000,
        "createTime": 1742617472000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437797",
        "articleType": 1,
        "viewCount": 154,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437797",
        "collectCount": 5,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "53 分钟前",
        "title": "Go 语言并发编程中的同步机制：保障程序稳健运行的基石",
        "description": "为避免死锁，应确保 Goroutine 按照相同的顺序获取锁，或者使用defer语句在函数结束时自动释放锁，保证锁的释放逻辑的确定性。同时，频繁地获取和释放互斥锁会带来一定的性能开销，因此在高并发场景下，应尽量减少锁的粒度，只在必要的代码段使用互斥锁，以提高程序的并发性能。同时，合理选择Broadcast和Signal方法，Broadcast适用于所有等待 Goroutine 都需要响应条件变化的场景，而Signal适用于只需要唤醒一个等待 Goroutine 的情况，避免不必要的唤醒操作，提高程序效率。",
        "hasOriginal": true,
        "diggCount": 2,
        "commentCount": 0,
        "postTime": 1742617426000,
        "createTime": 1742617426000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437792",
        "articleType": 1,
        "viewCount": 110,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437792",
        "collectCount": 12,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "54 分钟前",
        "title": "Go 语言性能测试与调优工具：解锁高效编程的钥匙",
        "description": "pprof是 Go 语言标准库中用于性能分析的强大工具，它能够收集程序运行时的 CPU 使用情况、内存分配情况、Goroutine 状态等多方面的数据，并生成直观的分析报告，帮助开发者快速定位性能瓶颈。pprof支持通过 HTTP 接口或命令行工具两种方式进行性能数据采集与分析。Go 语言丰富的性能测试与调优工具为开发者提供了全方位、多层次的性能分析手段。",
        "hasOriginal": true,
        "diggCount": 4,
        "commentCount": 0,
        "postTime": 1742617349000,
        "createTime": 1742617349000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437773",
        "articleType": 1,
        "viewCount": 261,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437773",
        "collectCount": 4,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "55 分钟前",
        "title": "避免内存分配陷阱：Go 语言性能优化关键技巧",
        "description": "在 Go 语言编程实践中，避免内存分配陷阱是提升程序性能的关键环节。通过深入理解 Go 语言内存分配机制，精准识别频繁创建临时对象、函数返回值导致内存分配、切片扩容、闭包捕获变量等常见陷阱，并运用复用已有内存资源、合理设计数据结构与算法、利用编译器优化与逃逸分析等优化策略，能够有效减少内存分配开销，降低垃圾回收频率，提升程序运行效率。随着 Go 语言生态系统的不断发展，未来内存管理机制可能会进一步优化，如垃圾回收算法的改进、内存分配器性能的提升等。",
        "hasOriginal": true,
        "diggCount": 6,
        "commentCount": 0,
        "postTime": 1742617319000,
        "createTime": 1742617319000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437765",
        "articleType": 1,
        "viewCount": 141,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437765",
        "collectCount": 9,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "56 分钟前",
        "title": "Go 语言数据结构选择与性能优化的深度探讨",
        "description": "在 Go 语言编程实践中，数据结构的选择与性能优化是一项复杂而关键的任务。通过深入理解数组、切片、映射、链表、树等常见数据结构的特性，运用时间复杂度、空间复杂度分析以及实际性能测试等方法，结合数据规模、访问模式、有序性需求和内存使用限制等因素，能够制定出基于性能优化的数据结构选择策略。在实际案例中，合理选择和优化数据结构能够显著提升系统性能，满足不同应用场景的需求。展望未来，随着 Go 语言生态系统的不断发展和硬件技术的持续进步，新的数据结构和优化技术将不断涌现。",
        "hasOriginal": true,
        "diggCount": 4,
        "commentCount": 0,
        "postTime": 1742617264000,
        "createTime": 1742617264000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437752",
        "articleType": 1,
        "viewCount": 401,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437752",
        "collectCount": 8,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "57 分钟前",
        "title": "巧用 Goroutine 与 Channel 提升 Go 程序并发性能",
        "description": "经过重构和优化，新的订单处理系统在并发性能方面取得了显著提升。在相同的硬件环境下，订单处理速度提高了 15 倍以上，用户平均等待时间从原来的 10 秒缩短至 0.6 秒以内，系统的吞吐量和稳定性得到了极大改善。合理拆分业务逻辑，将复杂的任务分解为多个简单、独立的子任务，利用 Goroutine 实现并行处理，能够充分发挥多核处理器。",
        "hasOriginal": true,
        "diggCount": 5,
        "commentCount": 0,
        "postTime": 1742617220000,
        "createTime": 1742617220000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437749",
        "articleType": 1,
        "viewCount": 293,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437749",
        "collectCount": 5,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "59 分钟前",
        "title": "Go 语言垃圾回收机制对性能的影响及优化方法",
        "description": "Go 语言的垃圾回收机制旨在自动识别并回收程序运行过程中不再被使用的内存空间，从而减轻开发者手动管理内存的负担，降低因内存泄漏、悬空指针等问题导致的程序错误风险。其核心工作流程基于三色标记清除（Tri - Color Mark and Sweep）算法。在垃圾回收过程伊始，所有内存对象均被标记为白色，代表其未被访问。随后，垃圾回收器从根对象（如全局变量、栈上变量等）出发，通过深度优先搜索等算法遍历对象引用关系图。在遍历过程中，可达对象会被依次标记为灰色，表示这些对象正在被访问。",
        "hasOriginal": true,
        "diggCount": 10,
        "commentCount": 0,
        "postTime": 1742617096000,
        "createTime": 1742617096000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437727",
        "articleType": 1,
        "viewCount": 225,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437727",
        "collectCount": 13,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "1 小时前",
        "title": "从原理到实践：Go 语言内存优化策略深度解析",
        "description": "内存优化在 Go 语言编程中是一项持续且重要的工作，贯穿于程序开发的整个生命周期。通过深入理解 Go 语言内存管理的底层原理，灵活运用诸如合理指针传递、避免不必要内存分配、优化数据结构使用、控制变量作用域以及减少闭包导致的变量逃逸等一系列内存优化策略，并借助pprof等强大的性能分析工具，开发者能够有效地提升 Go 语言程序的内存使用效率，减少内存相关问题的出现，显著提升程序的性能与稳定性。展望未来，随着 Go 语言的不断发展与演进，其内存管理机制与性能优化工具也将持续完善。",
        "hasOriginal": true,
        "diggCount": 8,
        "commentCount": 0,
        "postTime": 1742617013000,
        "createTime": 1742617013000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437709",
        "articleType": 1,
        "viewCount": 389,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437709",
        "collectCount": 11,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "1 小时前",
        "title": "Go 语言在高并发场景下的性能优势剖析",
        "description": "例如，在一个包含 10 个节点的 Etcd 集群进行的性能测试中，当集群面临每秒 5000 次的读写操作并发压力时，其数据一致性能够得到有效保障，并且整体的响应延迟控制在 100 毫秒以内，展现出强大的分布式处理能力和高并发性能。例如，将 Go 语言编写的 Web 服务器程序与使用解释型语言开发的类似服务器进行对比测试，在高并发负载下，Go 语言服务器能够以更低的延迟处理更多的请求，展现出明显的性能优势。展望未来，随着云计算、大数据、人工智能等技术的持续发展，高并发场景的应用需求将愈发旺盛。",
        "hasOriginal": true,
        "diggCount": 8,
        "commentCount": 0,
        "postTime": 1742616968000,
        "createTime": 1742616968000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146437699",
        "articleType": 1,
        "viewCount": 109,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146437699",
        "collectCount": 7,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "2025.03.19",
        "title": "Go 数组作为函数参数的传递方式剖析",
        "description": "在 Go 语言编程中，函数是构建程序逻辑的重要模块，而数据在函数间的传递方式则深刻影响着程序的行为与性能。数组作为一种基础数据结构，其作为函数参数的传递方式具有独特之处。理解 Go 数组在函数间传递的机制，对于开发者编写高效、健壮的代码至关重要。",
        "hasOriginal": true,
        "diggCount": 11,
        "commentCount": 0,
        "postTime": 1742346062000,
        "createTime": 1742346062000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359793",
        "articleType": 1,
        "viewCount": 497,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146359793",
        "collectCount": 17,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "2025.03.19",
        "title": "Go 数组的并发访问：问题与解决方案",
        "description": "在 Go 语言编程中，并发编程是充分利用多核处理器性能的关键手段。数组作为一种常用的数据结构，在并发环境下的访问控制至关重要。不当的并发访问可能导致数据不一致、程序崩溃等严重问题。因此，深入理解 Go 数组并发访问的问题，并掌握相应的解决方案，是编写高效、可靠并发程序的基础。",
        "hasOriginal": true,
        "diggCount": 18,
        "commentCount": 0,
        "postTime": 1742346025000,
        "createTime": 1742346025000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359785",
        "articleType": 1,
        "viewCount": 818,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146359785",
        "collectCount": 18,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "2025.03.19",
        "title": "Go 数组的搜索算法：从线性到二分",
        "description": "在 Go 语言编程中，对数组进行搜索是一项常见的操作，用于查找特定元素在数组中的位置。搜索算法的选择直接影响程序的效率，尤其是在处理大规模数据时。线性搜索和二分搜索是两种基本且广泛应用的搜索算法，它们各有特点，适用于不同的场景。理解这两种算法在 Go 数组中的实现与应用，对于开发者编写高效、优化的代码至关重要。",
        "hasOriginal": true,
        "diggCount": 7,
        "commentCount": 0,
        "postTime": 1742345978000,
        "createTime": 1742345978000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359767",
        "articleType": 1,
        "viewCount": 752,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146359767",
        "collectCount": 11,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "2025.03.19",
        "title": "Go 数组与结构体的结合应用案例详解",
        "description": "结构体数组是指数组中的每个元素都是一个结构体。首先，需要定义结构体类型，然后声明该结构体类型的数组。例如，定义一个表示学生信息的结构体Student，并创建一个包含多个学生信息的结构体数组：// 定义Student结构体Age int// 声明并初始化Student结构体数组在上述代码中，先定义了Student结构体，它包含Name（字符串类型）、Age（整数类型）和Grade（浮点数类型）三个字段。",
        "hasOriginal": true,
        "diggCount": 12,
        "commentCount": 0,
        "postTime": 1742345914000,
        "createTime": 1742345914000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359747",
        "articleType": 1,
        "viewCount": 755,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146359747",
        "collectCount": 15,
        "rtype": "article"
      },
      {
        "type": "blog",
        "formatTime": "2025.03.19",
        "title": "Go 数组基础：声明、初始化与访问",
        "description": "在 Go 语言的编程世界里，数组是一种基本的数据结构，它能够存储固定数量的同一类型元素。理解数组的声明、初始化与访问方式，是掌握 Go 语言编程基础的重要一环，无论是构建简单的程序脚本，还是开发复杂的系统，数组的正确运用都至关重要。",
        "hasOriginal": true,
        "diggCount": 3,
        "commentCount": 0,
        "postTime": 1742345519000,
        "createTime": 1742345061000,
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359416",
        "articleType": 1,
        "viewCount": 311,
        "picList": [],
        "editUrl": "https://mp.csdn.net/console/editor/html/146359416",
        "collectCount": 7,
        "rtype": "article"
      },
      {
        "articleId": 146359515,
        "title": "Go 数组与接口：实现灵活的数据处理",
        "description": "在 Go 语言中，可以定义一个接口类型的数组，该数组的每个元素都可以是实现了该接口的任意类型。例如，定义一个Shape接口，包含一个Area方法用于计算形状的面积，然后创建一个Shape接口类型的数组：import (\"fmt\"在这段代码中，Shape接口定义了Area方法。Rectangle和Circle结构体都实现了Shape接口。通过创建Shape接口类型的数组shapes，可以将不同类型（Rectangle和Circle）的对象存储在同一个数组中，并通过接口方法Area统一计算它们的面积。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359515",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 510,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359515",
        "postTime": "2025-03-19 08:51:55",
        "diggCount": 6,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 13,
        "tags": [
          "算法"
        ]
      },
      {
        "articleId": 146359581,
        "title": "Go 数组的多维应用场景与使用方法",
        "description": "在 Go 语言的编程领域中，多维数组作为一种强大的数据结构，为开发者提供了处理复杂数据关系的有效手段。多维数组本质上是数组的数组，通过多个索引来访问元素，这使得它在诸多领域有着广泛的应用。深入了解多维数组的应用场景与使用方法，对于编写高效、结构清晰的 Go 程序至关重要。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359581",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 661,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359581",
        "postTime": "2025-03-19 08:51:43",
        "diggCount": 14,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 20,
        "tags": [
          "java",
          "前端",
          "javascript"
        ]
      },
      {
        "articleId": 146359478,
        "title": "Go 数组在不同类型数据存储中的表现",
        "description": "在 Go 语言的编程实践里，数组作为一种基础数据结构，承担着存储数据的关键职责。不同类型的数据存储在数组中时，数组的性能、内存占用及操作特性等方面会呈现出各异的表现。深入探究这些差异，有助于开发者在编写程序时，根据具体需求精准选择合适的数据存储方式，从而打造出高效、稳定的应用程序。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359478",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 785,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359478",
        "postTime": "2025-03-19 08:47:07",
        "diggCount": 20,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "算法"
        ]
      },
      {
        "articleId": 146359454,
        "title": "Go 数组的生命周期管理与内存释放",
        "description": "在 Go 语言编程中，数组作为一种基础数据结构，其生命周期管理与内存释放机制深刻影响着程序的性能与稳定性。了解数组在内存中的创建、使用以及最终释放的全过程，对于开发者优化内存使用、避免内存泄漏至关重要。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359454",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 720,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359454",
        "postTime": "2025-03-19 08:46:06",
        "diggCount": 9,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "算法"
        ]
      },
      {
        "articleId": 146359428,
        "title": "Go 数组在算法实现中的角色与优化策略",
        "description": "在 Go 语言丰富的编程生态中，算法是解决各类复杂问题的核心。数组，作为基础数据结构，在众多算法实现里扮演着关键角色。无论是排序、搜索，还是数值计算等算法，数组都为数据的存储与处理提供了基础支撑。深入理解数组在算法中的作用，并掌握与之适配的优化策略，是开发者提升算法效率、打造高性能程序的关键。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359428",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 742,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359428",
        "postTime": "2025-03-19 08:44:59",
        "diggCount": 32,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 21,
        "tags": [
          "算法",
          "排序算法",
          "数据结构"
        ]
      },
      {
        "articleId": 146359402,
        "title": "Go 数组的扩容机制：何时与如何操作",
        "description": "在 Go 语言的编程实践中，数组作为一种基础的数据结构，常被用于存储一系列相同类型的数据。然而，数组的长度在声明时便已固定，这在某些情况下会限制其灵活性。为了满足动态存储数据的需求，Go 语言引入了切片（slice），而切片的扩容机制在一定程度上弥补了数组长度固定的不足。深入理解 Go 数组（切片）的扩容机制，对于开发者优化程序性能、避免潜在错误至关重要。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359402",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 492,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359402",
        "postTime": "2025-03-19 08:43:40",
        "diggCount": 6,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 6,
        "tags": [
          "golang",
          "xcode",
          "算法"
        ]
      },
      {
        "articleId": 146359391,
        "title": "在 Go 中高效地对数组进行排序",
        "description": "当标准库提供的排序方式不能满足需求时，Go 语言允许开发者自定义排序函数。自定义排序主要通过实现LenLess和Swap。假设有一个包含Person结构体的数组，每个Person结构体有Name和Age字段，现在需要根据Age对数组进行降序排序。代码如下：goimport (\"fmt\"\"sort\"Age int在这段代码中，首先定义了Person结构体。然后创建了一个ByAge类型，它是Person类型切片的别名。接着实现了Len方法返回切片的长度；Swap方法交换切片中两个元素的位置；Less。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359391",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 715,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359391",
        "postTime": "2025-03-19 08:43:03",
        "diggCount": 9,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 17,
        "tags": [
          "c++",
          "算法",
          "数据结构"
        ]
      },
      {
        "articleId": 146359377,
        "title": "Go 数组与切片：相似性与关键差异解析",
        "description": "从定义形式上看，数组与切片有一定相似性。数组的声明需明确指定长度与元素类型，例如，表示创建了一个长度为 5，元素类型为int的数组。而切片的声明则通过来实现，这里没有指定长度，它像是一个动态灵活的数组引用。在基本特性方面，二者都支持通过索引访问元素，且索引均从 0 开始。比如对于上述数组numbers，可通过numbers[2]访问其第三个元素；对于切片，若已赋值，同样能用获取对应元素。这种相似的元素访问方式，使得开发者在对二者进行基础操作时，有着类似的编程体验。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359377",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 403,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359377",
        "postTime": "2025-03-19 08:42:29",
        "diggCount": 24,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 19,
        "tags": [
          "javascript",
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 146359361,
        "title": "Go 数组的遍历技巧与最佳实践",
        "description": "在 Go 语言编程中，对数组进行遍历是一项极为常见的操作。无论是处理数据、查找特定元素，还是对数组中的数据进行转换，遍历都是实现这些功能的基础。掌握高效且恰当的遍历技巧，不仅能提升代码的执行效率，还能使代码结构更加清晰、易读。本文将深入探讨 Go 数组的各种遍历技巧及最佳实践。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359361",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 600,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359361",
        "postTime": "2025-03-19 08:41:58",
        "diggCount": 8,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 15,
        "tags": [
          "算法"
        ]
      },
      {
        "articleId": 146359350,
        "title": "Go 数组内存布局探秘",
        "description": "在 Go 语言编程中，深入理解数组的内存布局，不仅能帮助开发者写出更高效的代码，还能对程序的运行机制有更透彻的认识。数组作为一种基本数据结构，其内存布局方式直接影响着数据的存储与访问效率。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146359350",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 714,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146359350",
        "postTime": "2025-03-19 08:41:17",
        "diggCount": 15,
        "formatTime": "2025.03.19",
        "picList": [],
        "collectCount": 17,
        "tags": [
          "java",
          "算法",
          "数据结构"
        ]
      },
      {
        "articleId": 146334175,
        "title": "Go字符串拼接技巧大汇总：性能优化之道",
        "description": "由于strings.Builder内部使用的是可变的字节切片，在拼接过程中只会在必要时进行内存扩展，避免了大量的内存重新分配，因此在循环拼接大量字符串时，性能表现远远优于+运算符和fmt.Sprintf函数。这种方式简洁易懂，符合大多数开发者的编程习惯，在拼接少量字符串时，代码可读性高且性能损耗可以忽略不计。在性能方面，bytes.Buffer和strings.Builder相当，但strings.Builder针对字符串拼接进行了更优化，在纯字符串拼接场景下，建议优先使用strings.Builder。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146334175",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 304,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334175",
        "postTime": "2025-03-18 10:05:58",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/84c8558fd2db456f86e33d1b2184083f.png"
        ],
        "collectCount": 4,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146334023,
        "title": "Go字符串的遍历方法及应用场景剖析",
        "description": "在这段代码中，len(str)获取字符串字节长度，通过for循环从0到len(str) - 1遍历，str[i]访问每个字节。但这种方式存在局限性，对于非ASCII字符，如中文字符，一个字符可能由多个字节表示，按字节遍历会导致一个字符被拆分，无法正确处理多字节字符。i表示字符的起始字节位置，r表示字符的rune值，能正确遍历包含各种字符的字符串，适用于处理多语言文本、统计字符数量等场景。strings.Split函数可将字符串按指定分隔符拆分成字符串切片，结合遍历切片元素，可实现按单词或指定分隔部分遍历。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146334023",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 240,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146334023",
        "postTime": "2025-03-18 10:01:29",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/3577025a2ae34f89a7a1fc7fe6faeee4.png"
        ],
        "collectCount": 8,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333996,
        "title": "Go语言中字符串与字节切片的相互转换详解",
        "description": "Go语言中字符串与字节切片的相互转换详解在Go语言的编程实践里，字符串与字节切片（[]byte）之间的相互转换是极为常见的操作。由于它们在底层存储和使用场景上既有联系又有区别，深入理解二者的转换原理与方法，对于高效编写Go代码至关重要。一、字符串转字节切片（一）使用类型转换在Go语言中，将字符串转换为字节切片最直接的方式就是使用类型转换，语法如下：str := \"Hello, 世界\"byteSlice := []byte(str)在这个例子中，通过[]byte(str)将字符串str转换为字节切片by",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333996",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 376,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333996",
        "postTime": "2025-03-18 10:00:25",
        "diggCount": 3,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/51cd1d2963fb495ab9b9b7e86de37054.png"
        ],
        "collectCount": 9,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333946,
        "title": "Go字符串的常用操作函数深度解读",
        "description": "在Go语言中，字符串操作频繁，标准库strings包提供了一系列实用函数，能帮助开发者高效处理字符串。它基于Unicode标准进行大小写折叠，处理复杂的Unicode字符，适用于需要不区分大小写比较字符串的场景，如用户输入验证、搜索功能实现。Replace将字符串中指定子串替换为新字符串，可指定替换次数， - 1表示全部替换。ReplaceAll是Replace的简化版本，将字符串中所有指定子串替换为新字符串。常用于修改文本内容、格式化字符串，如将模板字符串中的占位符替换为实际值。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333946",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 258,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333946",
        "postTime": "2025-03-18 09:59:08",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/626b76f3411746b291e97d4d7057aa11.png"
        ],
        "collectCount": 3,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333904,
        "title": "Go字符串比较：原理、方法及易错点分析",
        "description": "例如，对于字符串\"apple\"和\"banana\"，在比较时，首先比较'a'和'b'，由于'a'的ASCII码值小于'b'的ASCII码值，所以\"apple\"小于\"banana\"。这种基于字节的比较方式，在处理ASCII字符集时相对简单直接，但在涉及到非ASCII字符，如中文字符时，就需要考虑字符的编码方式。由于Go语言使用UTF - 8编码，在比较包含非ASCII字符的字符串时，如果没有正确理解UTF - 8编码规则，可能会得到错误的比较结果。在Go语言中，最常用的字符串比较方式是使用==和!",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333904",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 373,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333904",
        "postTime": "2025-03-18 09:58:03",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/8ecc27acdac94f65beabf59a9c6be9da.png"
        ],
        "collectCount": 7,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333872,
        "title": "正则表达式在Go字符串处理中的实战应用",
        "description": "正则表达式在Go字符串处理中应用广泛，从简单的字符匹配到复杂的文本提取、替换和验证，都能发挥重要作用。在Go语言的字符串处理领域，正则表达式是功能强大的工具，能够实现复杂的文本匹配、查找、替换等操作。([a-zA-Z0-9_.+-]+)和([a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+)是两个分组，FindStringSubmatch会返回包含所有匹配项及分组内容的切片。^表示字符串开头，$表示字符串结尾，1[3-9]\\d{9}表示以1开头，第二位是3到9中的一个数字，后面跟着9个任意数字。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333872",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 349,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333872",
        "postTime": "2025-03-18 09:57:05",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/ee7cdf332d374c9693331b1f843e7ba5.png"
        ],
        "collectCount": 3,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333836,
        "title": "Go字符串格式化：各种场景下的最佳实践",
        "description": "在Go语言编程中，字符串格式化是一项常用的操作，它能够将各种数据类型按照特定的格式转换为字符串，以便于展示、存储或传输。通过掌握fmt包的基本占位符、time包的日期时间格式化以及encoding/json包的JSON格式化等技巧，能够满足各种数据处理和展示的需求，编写出更加规范、易读的代码。Go语言的fmt包是进行字符串格式化的核心工具，它提供了一系列的函数，如fmt.Sprintf、fmt.Printf和fmt.Fprintf ，其中fmt.Sprintf最为常用，它返回一个格式化后的字符串。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333836",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 307,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333836",
        "postTime": "2025-03-18 09:56:02",
        "diggCount": 3,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/da18faf6cbfa43aaa7fc06537f790150.png"
        ],
        "collectCount": 8,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333773,
        "title": "Go语言中字符串的编码与解码原理剖析",
        "description": "例如，英文字母 \"a\" 的UTF - 8编码是 0x61，而中文字符 \"中\" 的UTF - 8编码是 0xe4 b8 ad。对于码点在U+0080到U+07FF的字符，使用两个字节表示，第一个字节的前两位是110，第二个字节的前两位是10。对于更大范围的码点，以此类推，使用更多字节表示，每个后续字节的前两位始终是10，用于标识这是一个多字节字符的后续部分。例如，在HTTP请求中发送JSON数据，JSON数据中的字符串通常是UTF - 8编码的，接收方在解析JSON时会按照UTF - 8编码规则解码字符串。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333773",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 402,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333773",
        "postTime": "2025-03-18 09:54:10",
        "diggCount": 4,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/14f2813e2679476d967ea8810c6d0d45.png"
        ],
        "collectCount": 7,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333728,
        "title": "Go字符串在文件读写中的应用与优化",
        "description": "无论是读取文件内容进行分析，还是将处理后的字符串写入文件保存，掌握字符串在文件读写中的应用与优化技巧，能有效提升程序的性能和稳定性。字符串在Go语言的文件读写中应用广泛，选择合适的读取和写入方式，结合优化策略，能显著提升文件操作的效率和性能。若要逐行写入字符串，可使用bufio.Writer，它会在内存中缓存数据，减少磁盘I/O操作次数，提升写入效率。若文件存在，会覆盖原有内容。bufio.Scanner会自动处理换行符，按行读取文件内容，将每行内容作为一个字符串返回，大大减少内存占用。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333728",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 353,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333728",
        "postTime": "2025-03-18 09:52:42",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/f1f8b70d8924418997add3defc9057d9.png"
        ],
        "collectCount": 7,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333687,
        "title": "Go语言十年：从诞生到云原生时代的核心驱动力",
        "description": "**核心团队**：Robert Griesemer（V8引擎）、Rob Pike（UTF-8发明者）、Ken Thompson（Unix之父）的协作目标。- **Go 1.5（2015）**：自举编译器（Go编译器由Go自身编写），并发GC优化（停顿时间从秒级降至毫秒级）。- **数据支撑**：CNCF（云原生计算基金会）项目中，超过$70\\%$的核心组件使用Go开发。- **设计原则**：通过公式化的语言设计实现**$开发效率=代码简洁性/编译时间$**。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333687",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 284,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333687",
        "postTime": "2025-03-18 09:51:37",
        "diggCount": 3,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/b3e2a24e937343c9aa3c5a2941fd13f3.png"
        ],
        "collectCount": 10,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333485,
        "title": "并发环境下Go字符串处理的挑战与解决方案",
        "description": "并发环境下Go字符串处理的挑战与解决方案在Go语言的编程领域，并发编程是其强大特性之一，它允许程序高效利用多核处理器资源，提升整体性能。然而，当涉及字符串处理时，并发环境会带来一系列独特的挑战，需要开发者谨慎应对。接下来，我们将深入探讨这些挑战，并提供相应的解决方案。一、并发环境下的挑战（一）数据竞争字符串在Go语言中是不可变的，但在并发环境下对字符串进行操作时，若多个协程同时访问和修改与字符串相关的数据结构，就可能引发数据竞争问题。例如，多个协程同时向一个共享的字节切片中追加数据，而这个字节切片最终会被转",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333485",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 337,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333485",
        "postTime": "2025-03-18 09:45:58",
        "diggCount": 3,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/b8bbaeedb587483888c02ad9666066c7.png"
        ],
        "collectCount": 3,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333450,
        "title": "并发环境下Go字符串处理的挑战与解决方案",
        "description": "字符串在Go语言中是不可变的，但在并发环境下对字符串进行操作时，若多个协程同时访问和修改与字符串相关的数据结构，就可能引发数据竞争问题。例如，多个协程同时向一个共享的字节切片中追加数据，而这个字节切片最终会被转换为字符串，由于没有适当的同步机制，就可能导致数据不一致，使最终生成的字符串内容错误。在并发环境下进行字符串拼接时，由于字符串的不可变性，每次拼接都会生成一个新的字符串对象，这在单线程环境下就存在性能问题，在并发环境下会更加严重。在对共享的与字符串相关的数据结构进行操作前，获取锁，操作完成后释放锁。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333450",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 343,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333450",
        "postTime": "2025-03-18 09:44:33",
        "diggCount": 4,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/4539e0366b7d40daa073654131d5d0e7.png"
        ],
        "collectCount": 3,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333420,
        "title": "Go字符串的安全处理：避免常见漏洞",
        "description": "恶意用户可通过输入包含恶意JavaScript代码的字符串，当其他用户访问该页面时，恶意代码会在其浏览器中执行，从而窃取用户信息、篡改页面内容等。当用户输入的数据被直接拼接到SQL语句中，而未进行有效过滤和转义时，恶意用户可通过输入特殊字符改变SQL语句的逻辑结构，从而实现非法数据查询、修改甚至删除操作。然而，若处理不当，字符串操作可能引发安全漏洞，威胁程序乃至整个系统的安全性。当用户输入的数据被直接拼接到命令字符串中，而未经过严格验证和处理时，恶意用户可注入额外的命令，让程序执行非预期的系统命令。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333420",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 319,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333420",
        "postTime": "2025-03-18 09:43:37",
        "diggCount": 5,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/91f27a1f7dca496984e78bcabd4d5b30.png"
        ],
        "collectCount": 7,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333343,
        "title": "Go字符串与标准库其他包的协同使用案例",
        "description": "在这个例子中，使用strings.TrimSpace处理从URL参数获取的字符串，去除首尾空格，再通过fmt.Sprintf格式化字符串生成响应内容，展示了字符串与net/http包在服务器端的协同工作。在这个例子中，通过json.Marshal将User结构体转换为字节切片，再将其转换为字符串，展示了字符串与encoding/json包在JSON编码中的协同。这里，字符串用于定义请求URL，将响应的字节数据转换为字符串以便处理，体现了字符串在HTTP客户端的关键作用。三、字符串与io/ioutil包。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333343",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 297,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333343",
        "postTime": "2025-03-18 09:41:19",
        "diggCount": 3,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/2471c69b723a43a895286533dce01efc.png"
        ],
        "collectCount": 9,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146333277,
        "title": "Go字符串性能调优的高级技巧与工具",
        "description": "通过合理运用strings.Builder、map等数据结构，减少字符串转换和重复计算，再结合pprof、benchmark测试等工具进行性能分析与优化，能显著提升字符串处理的效率，使程序在处理大量字符串数据时表现更出色。在Go语言编程中，字符串操作频繁，若处理不当，易成为性能瓶颈。strings.Builder是Go 1.10引入的用于高效构建字符串的数据结构，通过维护可变的字节缓冲区，避免每次字符串拼接时的内存重新分配与拷贝，显著提升性能。在处理字符串时，要注意避免重复计算。二、避免不必要的操作。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146333277",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 340,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146333277",
        "postTime": "2025-03-18 09:39:29",
        "diggCount": 4,
        "formatTime": "2025.03.18",
        "picList": [
          "https://i-blog.csdnimg.cn/direct/c00ec004dfcd48029c5c43064376dfaf.png"
        ],
        "collectCount": 4,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146328392,
        "title": "人工智能驱动的图像识别：原理与最新应用",
        "description": "在数字化时代，图像数据呈爆炸式增长，从日常拍摄的照片到医疗影像、卫星图像等专业领域的数据，如何高效处理和理解这些图像信息成为关键。人工智能驱动的图像识别技术应运而生，它正深刻改变着我们生活与工作的方方面面。本文将深入探讨其原理，并展示一些令人瞩目的最新应用。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328392",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 509,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328392",
        "postTime": "2025-03-17 22:58:42",
        "diggCount": 8,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146328306,
        "title": "机器学习中的无监督学习算法详解",
        "description": "在机器学习领域，算法类型丰富多样，其中无监督学习算法以其独特的学习方式和广泛的应用场景，成为了数据挖掘和分析的重要工具。与有监督学习不同，无监督学习旨在从无标签的数据中发现潜在的模式和结构，为我们理解数据背后的规律提供了新的视角。本文将深入探讨无监督学习的概念，并详细介绍几种常见的无监督学习算法及其应用。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328306",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 824,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328306",
        "postTime": "2025-03-17 22:58:39",
        "diggCount": 14,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 8,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146328207,
        "title": "物联网设备安全漏洞分析与防范措施",
        "description": "在物联网（IoT）蓬勃发展的当下，各类物联网设备广泛应用于生活与工作的各个领域，从智能家居设备到工业生产中的传感器，它们为我们带来了极大的便利。然而，随着物联网设备数量的急剧增加，其安全问题也日益凸显。众多安全漏洞的存在，使得物联网设备面临着被攻击、数据泄露等风险，严重威胁个人隐私、企业运营甚至国家安全。本文将深入分析物联网设备常见的安全漏洞，并提出相应的防范措施。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328207",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 643,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328207",
        "postTime": "2025-03-17 22:58:29",
        "diggCount": 18,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 12,
        "tags": [
          "网络"
        ]
      },
      {
        "articleId": 146328194,
        "title": "边缘计算的概念、优势及应用场景",
        "description": "在数字化时代，数据呈爆炸式增长，传统的云计算模式在处理海量数据时面临着一些挑战，如网络延迟、带宽限制等。边缘计算作为一种新兴的计算模式应运而生，它正逐渐改变着数据处理和应用交付的方式。本文将深入探讨边缘计算的概念、优势以及在不同领域的应用场景。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328194",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 499,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328194",
        "postTime": "2025-03-17 22:58:25",
        "diggCount": 5,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146328331,
        "title": "智能家居系统的技术架构与发展趋势",
        "description": "随着科技的飞速发展，智能家居系统正逐渐走进人们的生活，为我们带来更加便捷、舒适、安全的居住体验。智能家居系统集成了多种先进技术，通过对家居设备的智能化控制和管理，实现家居生活的自动化和智能化。在本文中，我们将深入探讨智能家居系统的技术架构，并展望其未来的发展趋势。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328331",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 766,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328331",
        "postTime": "2025-03-17 22:58:22",
        "diggCount": 20,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 9,
        "tags": [
          "智能家居"
        ]
      },
      {
        "articleId": 146328165,
        "title": "软件开发中的敏捷方法：实践与经验分享",
        "description": "在当今快速变化的软件开发生态中，传统的软件开发方法常常难以应对需求的频繁变更以及紧迫的交付期限。敏捷方法应运而生，它以其灵活性、高效性和对客户需求的快速响应能力，逐渐成为软件开发领域的主流方法。本文将深入探讨敏捷方法的核心原则，并分享在实际项目中的应用经验。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328165",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 421,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328165",
        "postTime": "2025-03-17 22:58:19",
        "diggCount": 6,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 19,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146328181,
        "title": "大数据分析中的数据清洗技巧与实战",
        "description": "在大数据时代，数据已成为企业和组织的重要资产。通过对海量数据的分析，能够挖掘出有价值的信息，为决策提供有力支持。然而，原始数据往往存在各种问题，如缺失值、重复数据、错误数据等，这些问题严重影响了数据分析的准确性和可靠性。因此，数据清洗作为大数据分析的关键前置步骤，显得尤为重要。本文将深入探讨大数据分析中的数据清洗技巧，并通过实战案例展示如何有效运用这些技巧。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328181",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 626,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328181",
        "postTime": "2025-03-17 22:58:10",
        "diggCount": 22,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "智能家居"
        ]
      },
      {
        "articleId": 146328158,
        "title": "虚拟现实（VR）在教育领域的创新应用",
        "description": "在科技日新月异的今天，教育领域也在不断探索创新，力求为学生提供更优质、高效的学习体验。虚拟现实（VR）技术作为一项前沿科技，正逐渐融入教育体系，为教育带来了前所未有的变革。它以其独特的沉浸式、交互性和想象性特点，为学生创造了全新的学习环境，突破了传统教育的诸多限制。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328158",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 442,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328158",
        "postTime": "2025-03-17 22:58:06",
        "diggCount": 24,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 16,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146328264,
        "title": "量子计算的基本原理与近期突破",
        "description": "在科技飞速发展的当下，量子计算作为一项极具潜力的前沿技术，正逐渐走进人们的视野。它与传统计算截然不同，基于量子力学原理构建，有望在众多领域带来革命性的变革。本文将深入探讨量子计算的基本原理，并梳理近期该领域取得的令人瞩目的突破。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328264",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 887,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328264",
        "postTime": "2025-03-17 22:57:58",
        "diggCount": 7,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 10,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146328141,
        "title": "低代码开发平台的优势与潜在挑战",
        "description": "在当今数字化快速发展的时代，企业对应用程序的需求呈爆发式增长。传统的软件开发方式往往面临开发周期长、成本高、技术门槛高等问题，难以满足企业快速响应市场变化的需求。低代码开发平台应运而生，它以其独特的优势为企业开发应用提供了新的途径。然而，如同任何新兴技术一样，低代码开发平台在带来便利的同时，也存在一些潜在挑战。本文将深入探讨低代码开发平台的优势与潜在挑战。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328141",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 416,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328141",
        "postTime": "2025-03-17 22:57:54",
        "diggCount": 11,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 14,
        "tags": [
          "低代码"
        ]
      },
      {
        "articleId": 146328286,
        "title": "网络安全防御体系：如何构建坚不可摧的防线",
        "description": "在数字化时代，网络已深度融入我们生活与工作的方方面面。从企业的日常运营到个人的信息交互，都高度依赖网络。然而，网络安全威胁也如影随形，黑客攻击、恶意软件肆虐、数据泄露事件频发，给个人隐私、企业运营乃至国家安全带来了严重挑战。构建一个坚不可摧的网络安全防御体系，成为保障网络空间安全的关键。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328286",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 526,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328286",
        "postTime": "2025-03-17 22:57:50",
        "diggCount": 24,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 10,
        "tags": [
          "web安全",
          "安全"
        ]
      },
      {
        "articleId": 146328231,
        "title": "5G 网络的关键技术及对物联网发展的推动",
        "description": "随着科技的飞速发展，5G 网络已逐渐从概念走进现实，成为推动各行各业数字化变革的重要力量。与此同时，物联网（IoT）作为连接物理世界与数字世界的桥梁，也在不断拓展其应用领域。5G 网络凭借其独特的关键技术，为物联网的发展注入了强大动力，开启了万物互联的新时代。本文将深入探讨 5G 网络的关键技术，并分析其如何推动物联网的蓬勃发展。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328231",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 718,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328231",
        "postTime": "2025-03-17 22:57:47",
        "diggCount": 15,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 15,
        "tags": [
          "智能家居"
        ]
      },
      {
        "articleId": 146328129,
        "title": "云计算成本优化策略：企业如何节省开支",
        "description": "在数字化转型的浪潮中，云计算已成为企业提升业务敏捷性、降低运营成本的关键技术。然而，随着企业对云计算依赖程度的加深，云计算成本也逐渐成为一项不可忽视的开支。如何在充分利用云计算优势的同时，有效优化成本，成为众多企业关注的焦点。本文将深入剖析云计算成本的构成，并为企业提供一系列实用的成本优化策略。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328129",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 729,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328129",
        "postTime": "2025-03-17 22:57:40",
        "diggCount": 18,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146328352,
        "title": "Python 3.12 新特性解析及对开发效率的提升",
        "description": "Python 作为一种广泛应用于数据科学、人工智能、Web 开发等众多领域的编程语言，始终在不断进化。Python 3.12 版本带来了一系列令人兴奋的新特性，这些特性不仅增强了语言的功能，还显著提升了开发效率。在本文中，我们将深入探讨 Python 3.12 的主要新特性，并通过实际代码示例展示它们如何为开发者带来便利。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328352",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 617,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328352",
        "postTime": "2025-03-17 22:57:30",
        "diggCount": 25,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "python",
          "开发语言"
        ]
      },
      {
        "articleId": 146328113,
        "title": "深入理解区块链：从基础架构到实际应用案例",
        "description": "近年来，区块链技术成为了科技领域中备受瞩目的焦点。从最初作为比特币的底层技术支撑，到如今在众多行业展现出巨大的应用潜力，区块链正以其独特的架构和特性，重塑着我们对信息交互、信任建立以及价值传递的认知。在这篇文章中，我们将深入剖析区块链的基础架构，并通过实际案例展示其在不同领域的应用成果。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146328113",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 452,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146328113",
        "postTime": "2025-03-17 22:49:50",
        "diggCount": 17,
        "formatTime": "2025.03.17",
        "picList": [],
        "collectCount": 15,
        "tags": [
          "区块链"
        ]
      },
      {
        "articleId": 146298654,
        "title": "深入理解区块链：从基础架构到实际应用案例",
        "description": "近年来，区块链技术成为了科技领域中备受瞩目的焦点。从最初作为比特币的底层技术支撑，到如今在众多行业展现出巨大的应用潜力，区块链正以其独特的架构和特性，重塑着我们对信息交互、信任建立以及价值传递的认知。在这篇文章中，我们将深入剖析区块链的基础架构，并通过实际案例展示其在不同领域的应用成果。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298654",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 660,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298654",
        "postTime": "2025-03-16 18:07:31",
        "diggCount": 17,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 15,
        "tags": [
          "开发语言"
        ]
      },
      {
        "articleId": 146298645,
        "title": "Python 3.12 新特性解析及对开发效率的提升",
        "description": "Python 作为一种广泛应用于数据科学、人工智能、Web 开发等众多领域的编程语言，始终在不断进化。Python 3.12 版本带来了一系列令人兴奋的新特性，这些特性不仅增强了语言的功能，还显著提升了开发效率。在本文中，我们将深入探讨 Python 3.12 的主要新特性，并通过实际代码示例展示它们如何为开发者带来便利。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298645",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 669,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298645",
        "postTime": "2025-03-16 18:06:53",
        "diggCount": 23,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "python",
          "开发语言"
        ]
      },
      {
        "articleId": 146298638,
        "title": "云计算成本优化策略：企业如何节省开支",
        "description": "在数字化转型的浪潮中，云计算已成为企业提升业务敏捷性、降低运营成本的关键技术。然而，随着企业对云计算依赖程度的加深，云计算成本也逐渐成为一项不可忽视的开支。如何在充分利用云计算优势的同时，有效优化成本，成为众多企业关注的焦点。本文将深入剖析云计算成本的构成，并为企业提供一系列实用的成本优化策略。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298638",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 575,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298638",
        "postTime": "2025-03-16 18:06:18",
        "diggCount": 17,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 10,
        "tags": [
          "智能家居"
        ]
      },
      {
        "articleId": 146298629,
        "title": "5G 网络的关键技术及对物联网发展的推动",
        "description": "随着科技的飞速发展，5G 网络已逐渐从概念走进现实，成为推动各行各业数字化变革的重要力量。与此同时，物联网（IoT）作为连接物理世界与数字世界的桥梁，也在不断拓展其应用领域。5G 网络凭借其独特的关键技术，为物联网的发展注入了强大动力，开启了万物互联的新时代。本文将深入探讨 5G 网络的关键技术，并分析其如何推动物联网的蓬勃发展。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298629",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 619,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298629",
        "postTime": "2025-03-16 18:05:38",
        "diggCount": 8,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 10,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146298619,
        "title": "5G 网络的关键技术及对物联网发展的推动",
        "description": "随着科技的飞速发展，5G 网络已逐渐从概念走进现实，成为推动各行各业数字化变革的重要力量。与此同时，物联网（IoT）作为连接物理世界与数字世界的桥梁，也在不断拓展其应用领域。5G 网络凭借其独特的关键技术，为物联网的发展注入了强大动力，开启了万物互联的新时代。本文将深入探讨 5G 网络的关键技术，并分析其如何推动物联网的蓬勃发展。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298619",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 664,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298619",
        "postTime": "2025-03-16 18:04:51",
        "diggCount": 23,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 16,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146298607,
        "title": "网络安全防御体系：如何构建坚不可摧的防线",
        "description": "在数字化时代，网络已深度融入我们生活与工作的方方面面。从企业的日常运营到个人的信息交互，都高度依赖网络。然而，网络安全威胁也如影随形，黑客攻击、恶意软件肆虐、数据泄露事件频发，给个人隐私、企业运营乃至国家安全带来了严重挑战。构建一个坚不可摧的网络安全防御体系，成为保障网络空间安全的关键。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298607",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 602,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298607",
        "postTime": "2025-03-16 18:04:06",
        "diggCount": 19,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 10,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146298599,
        "title": "低代码开发平台的优势与潜在挑战",
        "description": "在当今数字化快速发展的时代，企业对应用程序的需求呈爆发式增长。传统的软件开发方式往往面临开发周期长、成本高、技术门槛高等问题，难以满足企业快速响应市场变化的需求。低代码开发平台应运而生，它以其独特的优势为企业开发应用提供了新的途径。然而，如同任何新兴技术一样，低代码开发平台在带来便利的同时，也存在一些潜在挑战。本文将深入探讨低代码开发平台的优势与潜在挑战。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298599",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 587,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298599",
        "postTime": "2025-03-16 18:03:27",
        "diggCount": 13,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 13,
        "tags": [
          "智能家居"
        ]
      },
      {
        "articleId": 146298589,
        "title": "量子计算的基本原理与近期突破",
        "description": "目录一、量子计算基本原理（一）量子比特（qubit）（二）量子门（Quantum Gates）（三）量子纠缠（Quantum Entanglement）二、近期突破（一）量子霸权的实现（二）量子纠错取得进展（三）量子算法的创新在科技飞速发展的当下，量子计算作为一项极具潜力的前沿技术，正逐渐走进人们的视野。它与传统计算截然不同，基于量子力学原理构建，有望在众多领域带来革命性的变革。本文将深入探讨量子计算的基本原理，并梳理近期该领域取得的令人瞩目的突破。传统计算基于二进制系统，使用比特（bit）作为信息存储和处",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298589",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 588,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298589",
        "postTime": "2025-03-16 18:02:44",
        "diggCount": 18,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 19,
        "tags": [
          "量子计算"
        ]
      },
      {
        "articleId": 146298582,
        "title": "虚拟现实（VR）在教育领域的创新应用",
        "description": "在科技日新月异的今天，教育领域也在不断探索创新，力求为学生提供更优质、高效的学习体验。虚拟现实（VR）技术作为一项前沿科技，正逐渐融入教育体系，为教育带来了前所未有的变革。它以其独特的沉浸式、交互性和想象性特点，为学生创造了全新的学习环境，突破了传统教育的诸多限制。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298582",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 633,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298582",
        "postTime": "2025-03-16 18:02:05",
        "diggCount": 16,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 20,
        "tags": [
          "vr"
        ]
      },
      {
        "articleId": 146298574,
        "title": "大数据分析中的数据清洗技巧与实战",
        "description": "在大数据时代，数据已成为企业和组织的重要资产。通过对海量数据的分析，能够挖掘出有价值的信息，为决策提供有力支持。然而，原始数据往往存在各种问题，如缺失值、重复数据、错误数据等，这些问题严重影响了数据分析的准确性和可靠性。因此，数据清洗作为大数据分析的关键前置步骤，显得尤为重要。本文将深入探讨大数据分析中的数据清洗技巧，并通过实战案例展示如何有效运用这些技巧。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298574",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 611,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298574",
        "postTime": "2025-03-16 18:01:31",
        "diggCount": 23,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 7,
        "tags": [
          "r语言-4.2.1"
        ]
      },
      {
        "articleId": 146298562,
        "title": "软件开发中的敏捷方法：实践与经验分享",
        "description": "在当今快速变化的软件开发生态中，传统的软件开发方法常常难以应对需求的频繁变更以及紧迫的交付期限。敏捷方法应运而生，它以其灵活性、高效性和对客户需求的快速响应能力，逐渐成为软件开发领域的主流方法。本文将深入探讨敏捷方法的核心原则，并分享在实际项目中的应用经验。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298562",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 912,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298562",
        "postTime": "2025-03-16 18:00:41",
        "diggCount": 18,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 16,
        "tags": [
          "算法"
        ]
      },
      {
        "articleId": 146298544,
        "title": "智能家居系统的技术架构与发展趋势",
        "description": "随着科技的飞速发展，智能家居系统正逐渐走进人们的生活，为我们带来更加便捷、舒适、安全的居住体验。智能家居系统集成了多种先进技术，通过对家居设备的智能化控制和管理，实现家居生活的自动化和智能化。在本文中，我们将深入探讨智能家居系统的技术架构，并展望其未来的发展趋势。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298544",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 773,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298544",
        "postTime": "2025-03-16 17:59:54",
        "diggCount": 10,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 13,
        "tags": [
          "智能家居",
          "架构"
        ]
      },
      {
        "articleId": 146298536,
        "title": "边缘计算的概念、优势及应用场景",
        "description": "在数字化时代，数据呈爆炸式增长，传统的云计算模式在处理海量数据时面临着一些挑战，如网络延迟、带宽限制等。边缘计算作为一种新兴的计算模式应运而生，它正逐渐改变着数据处理和应用交付的方式。本文将深入探讨边缘计算的概念、优势以及在不同领域的应用场景。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298536",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 486,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298536",
        "postTime": "2025-03-16 17:58:59",
        "diggCount": 13,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 4,
        "tags": [
          "边缘计算",
          "人工智能"
        ]
      },
      {
        "articleId": 146298505,
        "title": "物联网设备安全漏洞分析与防范措施",
        "description": "在物联网（IoT）蓬勃发展的当下，各类物联网设备广泛应用于生活与工作的各个领域，从智能家居设备到工业生产中的传感器，它们为我们带来了极大的便利。然而，随着物联网设备数量的急剧增加，其安全问题也日益凸显。众多安全漏洞的存在，使得物联网设备面临着被攻击、数据泄露等风险，严重威胁个人隐私、企业运营甚至国家安全。本文将深入分析物联网设备常见的安全漏洞，并提出相应的防范措施。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298505",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 581,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298505",
        "postTime": "2025-03-16 17:56:03",
        "diggCount": 12,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 20,
        "tags": [
          "网络"
        ]
      },
      {
        "articleId": 146298500,
        "title": "机器学习中的无监督学习算法详解",
        "description": "在机器学习领域，算法类型丰富多样，其中无监督学习算法以其独特的学习方式和广泛的应用场景，成为了数据挖掘和分析的重要工具。与有监督学习不同，无监督学习旨在从无标签的数据中发现潜在的模式和结构，为我们理解数据背后的规律提供了新的视角。本文将深入探讨无监督学习的概念，并详细介绍几种常见的无监督学习算法及其应用。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146298500",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 491,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146298500",
        "postTime": "2025-03-16 17:55:25",
        "diggCount": 17,
        "formatTime": "2025.03.16",
        "picList": [],
        "collectCount": 14,
        "tags": [
          "r语言-4.2.1"
        ]
      },
      {
        "articleId": 146278960,
        "title": "提升 Java 代码整洁度的编码习惯养成",
        "description": "在 Java 编程的旅程中，写出整洁、规范且易于理解的代码是每位开发者的追求。良好的编码习惯如同建筑中的基石，不仅能提升代码的质量，还能极大提高开发效率，降低维护成本。接下来，我们深入探讨一系列有助于提升 Java 代码整洁度的编码习惯，帮助开发者打造更优质的代码。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278960",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 509,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278960",
        "postTime": "2025-03-15 14:26:42",
        "diggCount": 18,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 17,
        "tags": [
          "python",
          "java",
          "算法"
        ]
      },
      {
        "articleId": 146278915,
        "title": "Java 代码的重构技巧：从混乱到整洁的蜕变",
        "description": "在 Java 项目的生命周期中，随着业务的不断发展和功能的持续迭代，代码往往会逐渐变得复杂和混乱。代码中可能出现重复逻辑、不合理的类与方法设计以及难以理解的复杂算法等问题，这不仅增加了开发人员的理解成本，还使得后续的维护与扩展工作变得困难重重。此时，代码重构就成为了改善代码质量、提升代码可维护性的关键手段。通过合理运用重构技巧，我们能够将混乱的代码转变为整洁、高效且易于理解的代码结构。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278915",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 798,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278915",
        "postTime": "2025-03-15 14:24:43",
        "diggCount": 37,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "java",
          "重构",
          "python"
        ]
      },
      {
        "articleId": 146278797,
        "title": "避免 Java 代码中的代码异味：保持代码的清爽",
        "description": "在 Java 开发过程中，随着项目规模的不断扩大，代码库也逐渐变得庞大复杂。此时，代码异味（Code Smells）便可能悄然出现。代码异味并非指代码存在语法错误，而是那些看似正常运行，但却隐藏着潜在问题，影响代码质量、可维护性与扩展性的代码结构或编程习惯。识别并避免代码异味，对于打造清爽、高效且易于维护的 Java 代码至关重要。接下来，我们深入探讨常见的 Java 代码异味及其应对策略。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278797",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 653,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278797",
        "postTime": "2025-03-15 14:15:59",
        "diggCount": 11,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 18,
        "tags": [
          "java",
          "前端",
          "python"
        ]
      },
      {
        "articleId": 146278764,
        "title": "Java 代码中的异常处理策略：整洁的错误管理之道",
        "description": "在某些特定业务场景下，Java 自带的异常类无法满足需求，此时可以定义自定义异常类。自定义异常类通常继承自Exception（用于受检异常）或RuntimeException（用于运行时异常）。例如，在一个用户注册系统中，如果用户名已存在，可以抛出一个自定义的UsernameAlreadyExistsException：在业务逻辑中，当检测到用户名已存在时，抛出自定义异常：throw new UsernameAlreadyExistsException(\"用户名已存在\");",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278764",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 437,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278764",
        "postTime": "2025-03-15 14:13:52",
        "diggCount": 18,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 14,
        "tags": [
          "log4j",
          "python",
          "开发语言"
        ]
      },
      {
        "articleId": 146278731,
        "title": "运用设计模式优化 Java 代码：实现简洁与可维护",
        "description": "策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换。这使得算法的变化独立于使用算法的客户端。在 Java 中，通过接口和实现类来实现策略模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象状态发生变化时，它的所有观察者都会收到通知并自动更新。在 Java 中，java.util.Observer和java.util.Observable类提供了对观察者模式的支持。工厂模式用于创建对象，将对象的创建和使用分离。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278731",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 741,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278731",
        "postTime": "2025-03-15 14:11:25",
        "diggCount": 17,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 20,
        "tags": [
          "bash",
          "开发语言"
        ]
      },
      {
        "articleId": 146278695,
        "title": "Java 注释的正确打开方式：有效注释提升代码可读性",
        "description": "在 Java 编程领域，代码可读性是衡量代码质量的重要标准。而注释，作为代码的 “说明书”，在提升可读性方面发挥着关键作用。恰当的注释能帮助开发者快速理解代码意图、功能以及实现逻辑，无论是对于项目的初次接触者，还是后续的维护者，都意义重大。接下来，我们深入探讨 Java 注释的正确使用方法，助力打造更易读、可维护的代码。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278695",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 238,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278695",
        "postTime": "2025-03-15 14:09:09",
        "diggCount": 4,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "python",
          "开发语言"
        ]
      },
      {
        "articleId": 146278678,
        "title": "优化 Java 代码结构：让你的程序逻辑更清晰",
        "description": "在 Java 编程中，良好的代码结构如同稳固的建筑框架，支撑着整个软件系统的运行。清晰、合理的代码结构不仅能提高代码的可读性，让开发者更容易理解程序逻辑，还能增强代码的可维护性和扩展性。当项目规模逐渐增大，代码结构的重要性愈发凸显。接下来，我们深入探讨优化 Java 代码结构的关键方法与技巧。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278678",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 360,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278678",
        "postTime": "2025-03-15 14:07:49",
        "diggCount": 5,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 5,
        "tags": [
          "java",
          "性能优化",
          "数据库",
          "安全",
          "mysql"
        ]
      },
      {
        "articleId": 146278654,
        "title": "Java 命名艺术：如何为变量、方法和类精准命名",
        "description": "在 Java 编程的世界里，代码的可读性和可维护性是衡量代码质量的重要标准。而精准的命名，就像是给代码赋予了清晰的 “说明书”，让阅读和理解代码变得更加轻松。无论是经验丰富的开发者，还是初涉 Java 编程的新手，掌握变量、方法和类的命名艺术，都能显著提升代码的品质。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278654",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 264,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278654",
        "postTime": "2025-03-15 14:06:36",
        "diggCount": 5,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 3,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 146278560,
        "title": "MySQL 性能优化：让你的数据库飞速运转",
        "description": "哈喽，各位技术爱好者！今天咱们深入探讨一下 MySQL 性能优化这个关键领域。在数据量与日俱增的当下，MySQL 作为众多应用的数据存储核心，其性能表现直接决定了整个系统的响应速度和用户体验。接下来，就和大家分享一些超实用的 MySQL 性能优化技巧，让你的数据库飞速运转起来。​。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278560",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 800,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278560",
        "postTime": "2025-03-15 14:02:05",
        "diggCount": 17,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 18,
        "tags": [
          "数据库",
          "mysql",
          "性能优化"
        ]
      },
      {
        "articleId": 146278581,
        "title": "深入探索 Java：强大编程语言的魅力与实践",
        "description": "在当今的软件开发领域，Java 以其卓越的性能、广泛的应用场景和强大的生态系统，占据着举足轻重的地位。无论是大型企业级应用、移动应用后端，还是分布式系统、大数据处理，Java 都展现出了无可比拟的优势。接下来，让我们一同深入探索 Java 这门强大编程语言的魅力与实践。​。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278581",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 540,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278581",
        "postTime": "2025-03-15 14:01:59",
        "diggCount": 10,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 8,
        "tags": [
          "java",
          "开发语言"
        ]
      },
      {
        "articleId": 146278533,
        "title": "MySQL 安全管理：为你的数据堡垒添砖加瓦",
        "description": "嘿，各位技术小伙伴们！今天咱们来聊聊 MySQL 安全管理这个超重要的话题。在这个数据爆炸的时代，MySQL 作为开源关系型数据库的 “明星选手”，被广泛应用，存储着海量关键数据。但与此同时，它面临的安全威胁也越来越复杂，恶意攻击、数据泄露等风险，时刻威胁着企业的数据资产，所以构建一个严密的 MySQL 安全管理体系刻不容缓。​。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278533",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 899,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278533",
        "postTime": "2025-03-15 13:58:04",
        "diggCount": 21,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 20,
        "tags": [
          "mysql",
          "安全",
          "数据库"
        ]
      },
      {
        "articleId": 146278500,
        "title": "MySQL 安全管理：筑牢数据库安全堡垒",
        "description": "在数字化浪潮中，MySQL 作为一款广泛应用的开源关系型数据库，承载着海量关键数据。然而，数据库面临的安全威胁日益复杂多样，从恶意攻击到数据泄露风险，都对企业数据资产构成严重挑战。构建严密的 MySQL 安全管理体系，成为保障数据安全、维护企业正常运营的当务之急。​。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278500",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 660,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278500",
        "postTime": "2025-03-15 13:55:39",
        "diggCount": 12,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 11,
        "tags": [
          "mysql",
          "安全",
          "数据库"
        ]
      },
      {
        "articleId": 146278479,
        "title": "MySQL 数据库备份与恢复策略：守护数据安全的防线",
        "description": "在数据驱动的业务环境中，MySQL 数据库存储着企业至关重要的信息。然而，数据面临着各种潜在风险，如硬件故障、人为误操作、恶意攻击等。为确保数据的安全性和完整性，制定有效的备份与恢复策略成为 MySQL 管理的关键环节。本文将深入探讨 MySQL 数据库备份与恢复的多种方法及相关策略。​。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278479",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 987,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278479",
        "postTime": "2025-03-15 13:53:57",
        "diggCount": 26,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 14,
        "tags": [
          "数据库",
          "mysql"
        ]
      },
      {
        "articleId": 146278446,
        "title": "MySQL 性能优化：让数据库运行如飞",
        "description": "在当今数据驱动的时代，MySQL 作为一款广泛使用的开源关系型数据库管理系统，其性能表现直接影响到整个应用程序的响应速度和用户体验。对于开发者和运维人员而言，掌握 MySQL 性能优化技巧至关重要。本文将深入探讨 MySQL 性能优化的多个关键方面，帮助您充分发挥 MySQL 的潜力，让数据库运行如飞。​。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278446",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 993,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278446",
        "postTime": "2025-03-15 13:52:05",
        "diggCount": 26,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 14,
        "tags": [
          "数据库",
          "mysql",
          "性能优化"
        ]
      },
      {
        "articleId": 146278427,
        "title": "MySQL：数据库世界的基石",
        "description": "MySQL 是一款开源的关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 旗下产品。自 1995 年发布以来，凭借其出色的性能、稳定性和丰富的功能，在 Web 应用开发、数据仓库、企业级应用等领域广泛应用。无论是小型初创企业，还是大型跨国公司，都能借助 MySQL 构建可靠的数据存储和管理解决方案。​。",
        "url": "https://blog.csdn.net/DJV29807654/article/details/146278427",
        "type": 1,
        "top": false,
        "forcePlan": false,
        "viewCount": 898,
        "commentCount": 0,
        "editUrl": "https://mp.csdn.net/console/editor/html/146278427",
        "postTime": "2025-03-15 13:49:51",
        "diggCount": 18,
        "formatTime": "2025.03.15",
        "picList": [],
        "collectCount": 13,
        "tags": [
          "数据库",
          "mysql"
        ]
      }
    ]
  }
]